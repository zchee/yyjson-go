// Code generated by 'ccgo -pkgname=yyjson -export-defines "" -export-enums "" -export-externs "" -export-fields "" -export-structs "" -export-typedefs "" -static-locals-prefix "" -Dyyjson_api_inline=__attribute__((visibility("default"))) -ignored-includes=math.h -trace-translation-units -o ./internal/yyjson/yyjson_darwin_amd64.go vendor/yyjson.c vendor/yyjson.h', DO NOT EDIT.

package yyjson

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ *libc.TLS
var _ types.Size_t

const (
	BIGINT_MAX_CHUNKS                         = 64
	BIG_ENDIAN                                = 4321
	BUFSIZ                                    = 1024
	BUS_ADRALN                                = 1
	BUS_ADRERR                                = 2
	BUS_NOOP                                  = 0
	BUS_OBJERR                                = 3
	BYTE_ORDER                                = 1234
	CHAR_BIT                                  = 8
	CHAR_ESC_ASCII                            = 1
	CHAR_ESC_NONE                             = 0
	CHAR_ESC_UTF8_1                           = 2
	CHAR_ESC_UTF8_2                           = 3
	CHAR_ESC_UTF8_3                           = 4
	CHAR_ESC_UTF8_4                           = 5
	CHAR_MAX                                  = 127
	CHAR_MIN                                  = -128
	CLD_CONTINUED                             = 6
	CLD_DUMPED                                = 3
	CLD_EXITED                                = 1
	CLD_KILLED                                = 2
	CLD_NOOP                                  = 0
	CLD_STOPPED                               = 5
	CLD_TRAPPED                               = 4
	CPUMON_MAKE_FATAL                         = 0x1000
	DBL_DECIMAL_DIG                           = 17
	DBL_DIG                                   = 15
	DBL_EPSILON                               = 0
	DBL_HAS_SUBNORM                           = 1
	DBL_MANT_DIG                              = 53
	DBL_MAX                                   = 0
	DBL_MAX_10_EXP                            = 308
	DBL_MAX_EXP                               = 1024
	DBL_MIN                                   = 0
	DBL_MIN_10_EXP                            = -307
	DBL_MIN_EXP                               = -1021
	DBL_TRUE_MIN                              = 0
	DECIMAL_DIG                               = 21
	EOF                                       = -1
	EXIT_FAILURE                              = 1
	EXIT_SUCCESS                              = 0
	F64_BITS                                  = 64
	F64_DEC_DIG                               = 17
	F64_EXP_BIAS                              = 1023
	F64_EXP_BITS                              = 11
	F64_MAX_BIN_EXP                           = 1024
	F64_MAX_DEC_DIG                           = 768
	F64_MAX_DEC_EXP                           = 308
	F64_MIN_BIN_EXP                           = -1021
	F64_MIN_DEC_EXP                           = -324
	F64_POW10_EXP_MAX_EXACT                   = 22
	F64_SIG_BITS                              = 52
	F64_SIG_FULL_BITS                         = 53
	FD_SETSIZE                                = 1024
	FILENAME_MAX                              = 1024
	FLT_DECIMAL_DIG                           = 9
	FLT_DIG                                   = 6
	FLT_EPSILON                               = 0
	FLT_EVAL_METHOD                           = 0
	FLT_HAS_SUBNORM                           = 1
	FLT_MANT_DIG                              = 24
	FLT_MAX                                   = 0
	FLT_MAX_10_EXP                            = 38
	FLT_MAX_EXP                               = 128
	FLT_MIN                                   = 0
	FLT_MIN_10_EXP                            = -37
	FLT_MIN_EXP                               = -125
	FLT_RADIX                                 = 2
	FLT_TRUE_MIN                              = 0
	FOOTPRINT_INTERVAL_RESET                  = 0x1
	FOPEN_MAX                                 = 20
	FPE_FLTDIV                                = 1
	FPE_FLTINV                                = 5
	FPE_FLTOVF                                = 2
	FPE_FLTRES                                = 4
	FPE_FLTSUB                                = 6
	FPE_FLTUND                                = 3
	FPE_INTDIV                                = 7
	FPE_INTOVF                                = 8
	FPE_NOOP                                  = 0
	FP_CHOP                                   = 3
	FP_PREC_24B                               = 0
	FP_PREC_53B                               = 2
	FP_PREC_64B                               = 3
	FP_RND_DOWN                               = 1
	FP_RND_NEAR                               = 0
	FP_RND_UP                                 = 2
	FP_STATE_BYTES                            = 512
	GCC_HAS_CLZLL                             = 1
	GCC_HAS_CTZLL                             = 0
	ILL_BADSTK                                = 8
	ILL_COPROC                                = 7
	ILL_ILLADR                                = 5
	ILL_ILLOPC                                = 1
	ILL_ILLOPN                                = 4
	ILL_ILLTRP                                = 2
	ILL_NOOP                                  = 0
	ILL_PRVOPC                                = 3
	ILL_PRVREG                                = 6
	INT16_MAX                                 = 32767
	INT16_MIN                                 = -32768
	INT32_MAX                                 = 2147483647
	INT32_MIN                                 = -2147483648
	INT64_MAX                                 = 9223372036854775807
	INT64_MIN                                 = -9223372036854775808
	INT8_MAX                                  = 127
	INT8_MIN                                  = -128
	INTMAX_MAX                                = 9223372036854775807
	INTMAX_MIN                                = -9223372036854775808
	INTPTR_MAX                                = 9223372036854775807
	INTPTR_MIN                                = -9223372036854775808
	INT_FAST16_MAX                            = 32767
	INT_FAST16_MIN                            = -32768
	INT_FAST32_MAX                            = 2147483647
	INT_FAST32_MIN                            = -2147483648
	INT_FAST64_MAX                            = 9223372036854775807
	INT_FAST64_MIN                            = -9223372036854775808
	INT_FAST8_MAX                             = 127
	INT_FAST8_MIN                             = -128
	INT_LEAST16_MAX                           = 32767
	INT_LEAST16_MIN                           = -32768
	INT_LEAST32_MAX                           = 2147483647
	INT_LEAST32_MIN                           = -2147483648
	INT_LEAST64_MAX                           = 9223372036854775807
	INT_LEAST64_MIN                           = -9223372036854775808
	INT_LEAST8_MAX                            = 127
	INT_LEAST8_MIN                            = -128
	INT_MAX                                   = 2147483647
	INT_MIN                                   = -2147483648
	IOPOL_APPLICATION                         = 5
	IOPOL_ATIME_UPDATES_DEFAULT               = 0
	IOPOL_ATIME_UPDATES_OFF                   = 1
	IOPOL_DEFAULT                             = 0
	IOPOL_IMPORTANT                           = 1
	IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT  = 0
	IOPOL_MATERIALIZE_DATALESS_FILES_OFF      = 1
	IOPOL_MATERIALIZE_DATALESS_FILES_ON       = 2
	IOPOL_NORMAL                              = 1
	IOPOL_PASSIVE                             = 2
	IOPOL_SCOPE_DARWIN_BG                     = 2
	IOPOL_SCOPE_PROCESS                       = 0
	IOPOL_SCOPE_THREAD                        = 1
	IOPOL_STANDARD                            = 5
	IOPOL_THROTTLE                            = 3
	IOPOL_TYPE_DISK                           = 0
	IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES     = 9
	IOPOL_TYPE_VFS_ATIME_UPDATES              = 2
	IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION  = 6
	IOPOL_TYPE_VFS_IGNORE_PERMISSIONS         = 7
	IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3
	IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE          = 8
	IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME      = 4
	IOPOL_TYPE_VFS_TRIGGER_RESOLVE            = 5
	IOPOL_UTILITY                             = 4
	IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF      = 0
	IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON       = 1
	IOPOL_VFS_CONTENT_PROTECTION_DEFAULT      = 0
	IOPOL_VFS_CONTENT_PROTECTION_IGNORE       = 1
	IOPOL_VFS_IGNORE_PERMISSIONS_OFF          = 0
	IOPOL_VFS_IGNORE_PERMISSIONS_ON           = 1
	IOPOL_VFS_SKIP_MTIME_UPDATE_OFF           = 0
	IOPOL_VFS_SKIP_MTIME_UPDATE_ON            = 1
	IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME     = 1
	IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT   = 0
	IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT         = 0
	IOPOL_VFS_TRIGGER_RESOLVE_OFF             = 1
	LDBL_DECIMAL_DIG                          = 21
	LDBL_DIG                                  = 18
	LDBL_EPSILON                              = 0
	LDBL_HAS_SUBNORM                          = 1
	LDBL_MANT_DIG                             = 64
	LDBL_MAX                                  = 0
	LDBL_MAX_10_EXP                           = 4932
	LDBL_MAX_EXP                              = 16384
	LDBL_MIN                                  = 0
	LDBL_MIN_10_EXP                           = -4931
	LDBL_MIN_EXP                              = -16381
	LDBL_TRUE_MIN                             = 0
	LITTLE_ENDIAN                             = 1234
	LLONG_MAX                                 = 9223372036854775807
	LLONG_MIN                                 = -9223372036854775808
	LONG_LONG_MAX                             = 9223372036854775807
	LONG_LONG_MIN                             = -9223372036854775808
	LONG_MAX                                  = 9223372036854775807
	LONG_MIN                                  = -9223372036854775808
	L_ctermid                                 = 1024
	L_tmpnam                                  = 1024
	MAC_OS_VERSION_11_0                       = 110000
	MAC_OS_VERSION_12_0                       = 120000
	MAC_OS_X_VERSION_10_0                     = 1000
	MAC_OS_X_VERSION_10_1                     = 1010
	MAC_OS_X_VERSION_10_10                    = 101000
	MAC_OS_X_VERSION_10_10_2                  = 101002
	MAC_OS_X_VERSION_10_10_3                  = 101003
	MAC_OS_X_VERSION_10_11                    = 101100
	MAC_OS_X_VERSION_10_11_2                  = 101102
	MAC_OS_X_VERSION_10_11_3                  = 101103
	MAC_OS_X_VERSION_10_11_4                  = 101104
	MAC_OS_X_VERSION_10_12                    = 101200
	MAC_OS_X_VERSION_10_12_1                  = 101201
	MAC_OS_X_VERSION_10_12_2                  = 101202
	MAC_OS_X_VERSION_10_12_4                  = 101204
	MAC_OS_X_VERSION_10_13                    = 101300
	MAC_OS_X_VERSION_10_13_1                  = 101301
	MAC_OS_X_VERSION_10_13_2                  = 101302
	MAC_OS_X_VERSION_10_13_4                  = 101304
	MAC_OS_X_VERSION_10_14                    = 101400
	MAC_OS_X_VERSION_10_14_1                  = 101401
	MAC_OS_X_VERSION_10_14_4                  = 101404
	MAC_OS_X_VERSION_10_14_6                  = 101406
	MAC_OS_X_VERSION_10_15                    = 101500
	MAC_OS_X_VERSION_10_15_1                  = 101501
	MAC_OS_X_VERSION_10_16                    = 101600
	MAC_OS_X_VERSION_10_2                     = 1020
	MAC_OS_X_VERSION_10_3                     = 1030
	MAC_OS_X_VERSION_10_4                     = 1040
	MAC_OS_X_VERSION_10_5                     = 1050
	MAC_OS_X_VERSION_10_6                     = 1060
	MAC_OS_X_VERSION_10_7                     = 1070
	MAC_OS_X_VERSION_10_8                     = 1080
	MAC_OS_X_VERSION_10_9                     = 1090
	MB_LEN_MAX                                = 1
	MINSIGSTKSZ                               = 32768
	MSC_HAS_BIT_SCAN                          = 0
	MSC_HAS_BIT_SCAN_64                       = 0
	MSC_HAS_UMUL128                           = 0
	NBBY                                      = 8
	NSIG                                      = 32
	PDP_ENDIAN                                = 3412
	POLL_ERR                                  = 4
	POLL_HUP                                  = 6
	POLL_IN                                   = 1
	POLL_MSG                                  = 3
	POLL_OUT                                  = 2
	POLL_PRI                                  = 5
	POW10_SIG_TABLE_MAX_EXACT_EXP             = 55
	POW10_SIG_TABLE_MAX_EXP                   = 324
	POW10_SIG_TABLE_MIN_EXACT_EXP             = 0
	POW10_SIG_TABLE_MIN_EXP                   = -343
	PRIO_DARWIN_BG                            = 0x1000
	PRIO_DARWIN_NONUI                         = 0x1001
	PRIO_DARWIN_PROCESS                       = 4
	PRIO_DARWIN_THREAD                        = 3
	PRIO_MAX                                  = 20
	PRIO_MIN                                  = -20
	PRIO_PGRP                                 = 1
	PRIO_PROCESS                              = 0
	PRIO_USER                                 = 2
	PTRDIFF_MAX                               = 9223372036854775807
	PTRDIFF_MIN                               = -9223372036854775808
	P_tmpdir                                  = "/var/tmp/"
	RAND_MAX                                  = 0x7fffffff
	RENAME_EXCL                               = 0x00000004
	RENAME_NOFOLLOW_ANY                       = 0x00000010
	RENAME_RESERVED1                          = 0x00000008
	RENAME_SECLUDE                            = 0x00000001
	RENAME_SWAP                               = 0x00000002
	RLIMIT_AS                                 = 5
	RLIMIT_CORE                               = 4
	RLIMIT_CPU                                = 0
	RLIMIT_CPU_USAGE_MONITOR                  = 0x2
	RLIMIT_DATA                               = 2
	RLIMIT_FOOTPRINT_INTERVAL                 = 0x4
	RLIMIT_FSIZE                              = 1
	RLIMIT_MEMLOCK                            = 6
	RLIMIT_NOFILE                             = 8
	RLIMIT_NPROC                              = 7
	RLIMIT_RSS                                = 5
	RLIMIT_STACK                              = 3
	RLIMIT_THREAD_CPULIMITS                   = 0x3
	RLIMIT_WAKEUPS_MONITOR                    = 0x1
	RLIM_NLIMITS                              = 9
	RSIZE_MAX                                 = 9223372036854775807
	RUSAGE_CHILDREN                           = -1
	RUSAGE_INFO_CURRENT                       = 5
	RUSAGE_INFO_V0                            = 0
	RUSAGE_INFO_V1                            = 1
	RUSAGE_INFO_V2                            = 2
	RUSAGE_INFO_V3                            = 3
	RUSAGE_INFO_V4                            = 4
	RUSAGE_INFO_V5                            = 5
	RUSAGE_SELF                               = 0
	RU_PROC_RUNS_RESLIDE                      = 0x00000001
	SA_64REGSET                               = 0x0200
	SA_NOCLDSTOP                              = 0x0008
	SA_NOCLDWAIT                              = 0x0020
	SA_NODEFER                                = 0x0010
	SA_ONSTACK                                = 0x0001
	SA_RESETHAND                              = 0x0004
	SA_RESTART                                = 0x0002
	SA_SIGINFO                                = 0x0040
	SA_USERSPACE_MASK                         = 127
	SA_USERTRAMP                              = 0x0100
	SCHAR_MAX                                 = 127
	SCHAR_MIN                                 = -128
	SEEK_CUR                                  = 1
	SEEK_END                                  = 2
	SEEK_SET                                  = 0
	SEGV_ACCERR                               = 2
	SEGV_MAPERR                               = 1
	SEGV_NOOP                                 = 0
	SHRT_MAX                                  = 32767
	SHRT_MIN                                  = -32768
	SIGABRT                                   = 6
	SIGALRM                                   = 14
	SIGBUS                                    = 10
	SIGCHLD                                   = 20
	SIGCONT                                   = 19
	SIGEMT                                    = 7
	SIGEV_NONE                                = 0
	SIGEV_SIGNAL                              = 1
	SIGEV_THREAD                              = 3
	SIGFPE                                    = 8
	SIGHUP                                    = 1
	SIGILL                                    = 4
	SIGINFO                                   = 29
	SIGINT                                    = 2
	SIGIO                                     = 23
	SIGIOT                                    = 6
	SIGKILL                                   = 9
	SIGPIPE                                   = 13
	SIGPROF                                   = 27
	SIGQUIT                                   = 3
	SIGSEGV                                   = 11
	SIGSTKSZ                                  = 131072
	SIGSTOP                                   = 17
	SIGSYS                                    = 12
	SIGTERM                                   = 15
	SIGTRAP                                   = 5
	SIGTSTP                                   = 18
	SIGTTIN                                   = 21
	SIGTTOU                                   = 22
	SIGURG                                    = 16
	SIGUSR1                                   = 30
	SIGUSR2                                   = 31
	SIGVTALRM                                 = 26
	SIGWINCH                                  = 28
	SIGXCPU                                   = 24
	SIGXFSZ                                   = 25
	SIG_ATOMIC_MAX                            = 2147483647
	SIG_ATOMIC_MIN                            = -2147483648
	SIG_BLOCK                                 = 1
	SIG_SETMASK                               = 3
	SIG_UNBLOCK                               = 2
	SIZE_MAX                                  = 18446744073709551615
	SI_ASYNCIO                                = 0x10004
	SI_MESGQ                                  = 0x10005
	SI_QUEUE                                  = 0x10002
	SI_TIMER                                  = 0x10003
	SI_USER                                   = 0x10001
	SS_DISABLE                                = 0x0004
	SS_ONSTACK                                = 0x0001
	SV_INTERRUPT                              = 2
	SV_NOCLDSTOP                              = 8
	SV_NODEFER                                = 16
	SV_ONSTACK                                = 1
	SV_RESETHAND                              = 4
	SV_SIGINFO                                = 64
	TMP_MAX                                   = 308915776
	TRAP_BRKPT                                = 1
	TRAP_TRACE                                = 2
	U64_POW10_MAX_EXP                         = 19
	U64_SAFE_DIG                              = 19
	UCHAR_MAX                                 = 255
	UINT16_MAX                                = 65535
	UINT32_MAX                                = 4294967295
	UINT64_MAX                                = 18446744073709551615
	UINT8_MAX                                 = 255
	UINTMAX_MAX                               = 18446744073709551615
	UINTPTR_MAX                               = 18446744073709551615
	UINT_FAST16_MAX                           = 65535
	UINT_FAST32_MAX                           = 4294967295
	UINT_FAST64_MAX                           = 18446744073709551615
	UINT_FAST8_MAX                            = 255
	UINT_LEAST16_MAX                          = 65535
	UINT_LEAST32_MAX                          = 4294967295
	UINT_LEAST64_MAX                          = 18446744073709551615
	UINT_LEAST8_MAX                           = 255
	UINT_MAX                                  = 4294967295
	ULLONG_MAX                                = 18446744073709551615
	ULONG_LONG_MAX                            = 18446744073709551615
	ULONG_MAX                                 = 18446744073709551615
	USHRT_MAX                                 = 65535
	WAIT_ANY                                  = -1
	WAIT_MYPGRP                               = 0
	WAKEMON_DISABLE                           = 0x02
	WAKEMON_ENABLE                            = 0x01
	WAKEMON_GET_PARAMS                        = 0x04
	WAKEMON_MAKE_FATAL                        = 0x10
	WAKEMON_SET_DEFAULTS                      = 0x08
	WCHAR_MAX                                 = 2147483647
	WCHAR_MIN                                 = -2147483648
	WCONTINUED                                = 0x00000010
	WCOREFLAG                                 = 0200
	WEXITED                                   = 0x00000004
	WINT_MAX                                  = 2147483647
	WINT_MIN                                  = -2147483648
	WNOHANG                                   = 0x00000001
	WNOWAIT                                   = 0x00000020
	WSTOPPED                                  = 0x00000008
	WUNTRACED                                 = 0x00000002
	YYJSON_BIG_ENDIAN                         = 4321
	YYJSON_CPP_VER                            = 0
	YYJSON_DISABLE_FAST_FP_CONV               = 0
	YYJSON_DISABLE_NON_STANDARD               = 0
	YYJSON_DISABLE_READER                     = 0
	YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS    = 0
	YYJSON_DISABLE_WRITER                     = 0
	YYJSON_DOUBLE_MATH_CORRECT                = 1
	YYJSON_ENDIAN                             = 1234
	YYJSON_FOPEN_EXT                          = 0
	YYJSON_GCC_VER                            = 4
	YYJSON_H                                  = 0
	YYJSON_HAS_IEEE_754                       = 1
	YYJSON_HAS_INT128                         = 1
	YYJSON_IS_REAL_GCC                        = 0
	YYJSON_LITTLE_ENDIAN                      = 1234
	YYJSON_MSC_VER                            = 0
	YYJSON_PADDING_SIZE                       = 4
	YYJSON_READER_ESTIMATED_MINIFY_RATIO      = 6
	YYJSON_READER_ESTIMATED_PRETTY_RATIO      = 16
	YYJSON_STDC_VER                           = 0
	YYJSON_U64_TO_F64_NO_IMPL                 = 0
	YYJSON_VERSION_HEX                        = 0x000400
	YYJSON_VERSION_MAJOR                      = 0
	YYJSON_VERSION_MINOR                      = 4
	YYJSON_VERSION_PATCH                      = 0
	YYJSON_VERSION_STRING                     = "0.4.0"
	YYJSON_WRITER_ESTIMATED_MINIFY_RATIO      = 18
	YYJSON_WRITER_ESTIMATED_PRETTY_RATIO      = 32
	X_ALLOCA_H_                               = 0
	X_BLKCNT_T                                = 0
	X_BLKSIZE_T                               = 0
	X_BSD_I386__TYPES_H_                      = 0
	X_BSD_MACHINE_ENDIAN_H_                   = 0
	X_BSD_MACHINE_SIGNAL_H_                   = 0
	X_BSD_MACHINE_TYPES_H_                    = 0
	X_BSD_MACHINE__MCONTEXT_H_                = 0
	X_BSD_MACHINE__TYPES_H_                   = 0
	X_CADDR_T                                 = 0
	X_CDEFS_H_                                = 0
	X_CLOCK_T                                 = 0
	X_CTERMID_H_                              = 0
	X_CT_RUNE_T                               = 0
	X_DARWIN_FEATURE_64_BIT_INODE             = 1
	X_DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE    = 1
	X_DARWIN_FEATURE_UNIX_CONFORMANCE         = 3
	X_DEV_T                                   = 0
	X_ERRNO_T                                 = 0
	X_FD_SET                                  = 0
	X_FILE_OFFSET_BITS                        = 64
	X_FORTIFY_SOURCE                          = 2
	X_FSBLKCNT_T                              = 0
	X_FSFILCNT_T                              = 0
	X_FSTDIO                                  = 0
	X_GCC_LIMITS_H_                           = 0
	X_GID_T                                   = 0
	X_I386_MACHTYPES_H_                       = 0
	X_I386_SIGNAL_H_                          = 1
	X_I386__ENDIAN_H_                         = 0
	X_ID_T                                    = 0
	X_INO64_T                                 = 0
	X_INO_T                                   = 0
	X_INT16_T                                 = 0
	X_INT32_T                                 = 0
	X_INT64_T                                 = 0
	X_INT8_T                                  = 0
	X_INTPTR_T                                = 0
	X_IN_ADDR_T                               = 0
	X_IN_PORT_T                               = 0
	X_IOFBF                                   = 0
	X_IOLBF                                   = 1
	X_IONBF                                   = 2
	X_KEY_T                                   = 0
	X_LP64                                    = 1
	X_MACHTYPES_H_                            = 0
	X_MACH_I386__STRUCTS_H_                   = 0
	X_MACH_MACHINE__STRUCTS_H_                = 0
	X_MALLOC_UNDERSCORE_MALLOC_H_             = 0
	X_MCONTEXT_T                              = 0
	X_MODE_T                                  = 0
	X_NLINK_T                                 = 0
	X_Nonnull                                 = 0
	X_Null_unspecified                        = 0
	X_Nullable                                = 0
	X_OFF_T                                   = 0
	X_OS__OSBYTEORDERI386_H                   = 0
	X_OS__OSBYTEORDER_H                       = 0
	X_PID_T                                   = 0
	X_PTHREAD_ATTR_T                          = 0
	X_PTHREAD_CONDATTR_T                      = 0
	X_PTHREAD_COND_T                          = 0
	X_PTHREAD_KEY_T                           = 0
	X_PTHREAD_MUTEXATTR_T                     = 0
	X_PTHREAD_MUTEX_T                         = 0
	X_PTHREAD_ONCE_T                          = 0
	X_PTHREAD_RWLOCKATTR_T                    = 0
	X_PTHREAD_RWLOCK_T                        = 0
	X_PTHREAD_T                               = 0
	X_PTRDIFF_T                               = 0
	X_QUAD_HIGHWORD                           = 1
	X_QUAD_LOWWORD                            = 0
	X_RLIMIT_POSIX_FLAG                       = 0x1000
	X_RSIZE_T                                 = 0
	X_RUNE_T                                  = 0
	X_SECURE__COMMON_H_                       = 0
	X_SECURE__STDIO_H_                        = 0
	X_SECURE__STRINGS_H_                      = 0
	X_SECURE__STRING_H_                       = 0
	X_SIGSET_T                                = 0
	X_SIZE_T                                  = 0
	X_SSIZE_T                                 = 0
	X_STDIO_H_                                = 0
	X_STDLIB_H_                               = 0
	X_STRINGS_H_                              = 0
	X_STRING_H_                               = 0
	X_SUSECONDS_T                             = 0
	X_SYS_RESOURCE_H_                         = 0
	X_SYS_SIGNAL_H_                           = 0
	X_SYS_STDIO_H_                            = 0
	X_SYS_TYPES_H_                            = 0
	X_SYS_WAIT_H_                             = 0
	X_SYS__ENDIAN_H_                          = 0
	X_SYS__PTHREAD_TYPES_H_                   = 0
	X_SYS__TYPES_H_                           = 0
	X_TIME_T                                  = 0
	X_UID_T                                   = 0
	X_UINT32_T                                = 0
	X_UINTPTR_T                               = 0
	X_USECONDS_T                              = 0
	X_USE_FORTIFY_LEVEL                       = 2
	X_U_CHAR                                  = 0
	X_U_INT                                   = 0
	X_U_INT16_T                               = 0
	X_U_INT32_T                               = 0
	X_U_INT64_T                               = 0
	X_U_INT8_T                                = 0
	X_U_LONG                                  = 0
	X_U_SHORT                                 = 0
	X_VA_LIST_T                               = 0
	X_WCHAR_T                                 = 0
	X_WSTOPPED                                = 0177
	X_X86_INSTRUCTION_STATE_CACHELINE_SIZE    = 64
	X_X86_INSTRUCTION_STATE_MAX_INSN_BYTES    = 2380
	False                                     = 0
	True                                      = 1
)

// Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1989, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)wait.h	8.2 (Berkeley) 7/10/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// This file holds definitions relevent to the wait4 system call
// and the alternate interfaces that use it (wait, wait3, waitpid).

// [XSI] The type idtype_t shall be defined as an enumeration type whose
// possible values shall include at least P_ALL, P_PID, and P_PGID.
const ( /* wait.h:79:1: */
	P_ALL  = 0
	P_PID  = 1
	P_PGID = 2
)

type Ptrdiff_t = int64 /* <builtin>:3:26 */

type Size_t = uint64 /* <builtin>:9:23 */

type Wchar_t = int32 /* <builtin>:15:24 */

type X__int128_t = struct {
	Lo int64
	Hi int64
} /* <builtin>:21:43 */ // must match modernc.org/mathutil.Int128
type X__uint128_t = struct {
	Lo uint64
	Hi uint64
} /* <builtin>:22:44 */ // must match modernc.org/mathutil.Int128

type X__builtin_va_list = uintptr /* <builtin>:46:14 */
type X__float128 = float64        /* <builtin>:47:21 */

var X__darwin_check_fd_set_overflow uintptr /* <builtin>:146:5: */

// ==============================================================================
// Created by Yaoyuan on 2019/3/9.
// Copyright (C) 2019 Yaoyuan <ibireme@gmail.com>.
//
// Released under the MIT License:
// https://github.com/ibireme/yyjson/blob/master/LICENSE
//============================================================================

// ==============================================================================
// Created by Yaoyuan on 2019/3/9.
// Copyright (C) 2019 Yaoyuan <ibireme@gmail.com>.
//
// Released under the MIT License:
// https://github.com/ibireme/yyjson/blob/master/LICENSE
//============================================================================

// ==============================================================================
// Header Files
//============================================================================

// Copyright (c) 2000, 2002 - 2008 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

//
//     These macros are for use in OS header files. They enable function prototypes
//     and Objective-C methods to be tagged with the OS version in which they
//     were first available; and, if applicable, the OS version in which they
//     became deprecated.
//
//     The desktop Mac OS X and iOS each have different version numbers.
//     The __OSX_AVAILABLE_STARTING() macro allows you to specify both the desktop
//     and iOS version numbers.  For instance:
//         __OSX_AVAILABLE_STARTING(__MAC_10_2,__IPHONE_2_0)
//     means the function/method was first available on Mac OS X 10.2 on the desktop
//     and first available in iOS 2.0 on the iPhone.
//
//     If a function is available on one platform, but not the other a _NA (not
//     applicable) parameter is used.  For instance:
//             __OSX_AVAILABLE_STARTING(__MAC_10_3,__IPHONE_NA)
//     means that the function/method was first available on Mac OS X 10.3, and it
//     currently not implemented on the iPhone.
//
//     At some point, a function/method may be deprecated.  That means Apple
//     recommends applications stop using the function, either because there is a
//     better replacement or the functionality is being phased out.  Deprecated
//     functions/methods can be tagged with a __OSX_AVAILABLE_BUT_DEPRECATED()
//     macro which specifies the OS version where the function became available
//     as well as the OS version in which it became deprecated.  For instance:
//         __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_0,__MAC_10_5,__IPHONE_NA,__IPHONE_NA)
//     means that the function/method was introduced in Mac OS X 10.0, then
//     became deprecated beginning in Mac OS X 10.5.  On iOS the function
//     has never been available.
//
//     For these macros to function properly, a program must specify the OS version range
//     it is targeting.  The min OS version is specified as an option to the compiler:
//     -mmacosx-version-min=10.x when building for Mac OS X, and -miphoneos-version-min=y.z
//     when building for the iPhone.  The upper bound for the OS version is rarely needed,
//     but it can be set on the command line via: -D__MAC_OS_X_VERSION_MAX_ALLOWED=10x0 for
//     Mac OS X and __IPHONE_OS_VERSION_MAX_ALLOWED = y0z00 for iOS.
//
//     Examples:
//
//         A function available in Mac OS X 10.5 and later, but not on the phone:
//
//             extern void mymacfunc() __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
//
//
//         An Objective-C method in Mac OS X 10.5 and later, but not on the phone:
//
//             @interface MyClass : NSObject
//             -(void) mymacmethod __OSX_AVAILABLE_STARTING(__MAC_10_5,__IPHONE_NA);
//             @end
//
//
//         An enum available on the phone, but not available on Mac OS X:
//
//             #if __IPHONE_OS_VERSION_MIN_REQUIRED
//                 enum { myEnum = 1 };
//             #endif
//            Note: this works when targeting the Mac OS X platform because
//            __IPHONE_OS_VERSION_MIN_REQUIRED is undefined which evaluates to zero.
//
//
//         An enum with values added in different iPhoneOS versions:
//
// 			enum {
// 			    myX  = 1,	// Usable on iPhoneOS 2.1 and later
// 			    myY  = 2,	// Usable on iPhoneOS 3.0 and later
// 			    myZ  = 3,	// Usable on iPhoneOS 3.0 and later
// 				...
// 		      Note: you do not want to use #if with enumeration values
// 			  when a client needs to see all values at compile time
// 			  and use runtime logic to only use the viable values.
//
//
//     It is also possible to use the *_VERSION_MIN_REQUIRED in source code to make one
//     source base that can be compiled to target a range of OS versions.  It is best
//     to not use the _MAC_* and __IPHONE_* macros for comparisons, but rather their values.
//     That is because you might get compiled on an old OS that does not define a later
//     OS version macro, and in the C preprocessor undefined values evaluate to zero
//     in expresssions, which could cause the #if expression to evaluate in an unexpected
//     way.
//
//         #ifdef __MAC_OS_X_VERSION_MIN_REQUIRED
//             // code only compiled when targeting Mac OS X and not iPhone
//             // note use of 1050 instead of __MAC_10_5
//             #if __MAC_OS_X_VERSION_MIN_REQUIRED < 1050
//                 // code in here might run on pre-Leopard OS
//             #else
//                 // code here can assume Leopard or later
//             #endif
//         #endif
//
//

// __API_TO_BE_DEPRECATED is used as a version number in API that will be deprecated
// in an upcoming release. This soft deprecation is an intermediate step before formal
// deprecation to notify developers about the API before compiler warnings are generated.
// You can find all places in your code that use soft deprecated API by redefining the
// value of this macro to your current minimum deployment target, for example:
// (macOS)
//   clang -D__API_TO_BE_DEPRECATED=10.12 <other compiler flags>
// (iOS)
//   clang -D__API_TO_BE_DEPRECATED=11.0 <other compiler flags>

// Copyright (c) 2019 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// __MAC_NA is not defined to a value but is used as a token by macros to indicate that the API is unavailable

// __IPHONE_NA is not defined to a value but is used as a token by macros to indicate that the API is unavailable

// Set up standard Mac OS X versions

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

//
//     File:       AvailabilityInternal.h
//
//     Contains:   implementation details of __OSX_AVAILABLE_* macros from <Availability.h>
//

// compiler for Mac OS X sets __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__

// make sure a default max version is set

//
//  Macros for defining which versions/platform a given symbol can be used.
//
//  @see http://clang.llvm.org/docs/AttributeReference.html#availability
//

// Evaluate to nothing for compilers that don't support clang language extensions.

// Swift compiler version
// Allows for project-agnostic "epochs" for frameworks imported into Swift via the Clang importer, like #if _compiler_version for Swift
// Example:
//
//  #if __swift_compiler_version_at_least(800, 2, 20)
//  - (nonnull NSString *)description;
//  #else
//  - (NSString *)description;
//  #endif

// If __SPI_AVAILABLE has not been defined elsewhere, disable it.

// for use to document app extension usage

// for use marking APIs available info for Mac OSX

// for use marking APIs available info for iOS

// for use marking APIs available info for tvOS

// for use marking APIs available info for Watch OS

// for use marking APIs unavailable for swift

//
//  Macros for defining which versions/platform a given symbol can be used.
//
//  @see http://clang.llvm.org/docs/AttributeReference.html#availability
//
//  * Note that these macros are only compatible with clang compilers that
//  * support the following target selection options:
//  *
//  * -mmacosx-version-min
//  * -miphoneos-version-min
//  * -mwatchos-version-min
//  * -mtvos-version-min
//

// Evaluate to nothing for compilers that don't support clang language extensions.

// If SPI decorations have not been defined elsewhere, disable them.

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// This SDK is designed to work with clang and specific versions of
// gcc >= 4.0 with Apple's patch sets

// Compatibility with compilers and environments that don't support compiler
// feature checking function-like macros.

// The __CONCAT macro is used to concatenate parts of symbol names, e.g.
// with "#define OLD(foo) __CONCAT(old,foo)", OLD(foo) produces oldfoo.
// The __CONCAT macro is a bit tricky -- make sure you don't put spaces
// in between its arguments.  __CONCAT can also concatenate double-quoted
// strings produced by the __STRING macro, but this only works with ANSI C.

// In non-ANSI C environments, new programs will want ANSI-only C keywords
// deleted from the program and old programs will want them left alone.
// When using a compiler other than gcc, programs using the ANSI C keywords
// const, inline etc. as normal identifiers should define -DNO_ANSI_KEYWORDS.
// When using "gcc -traditional", we assume that this is the intent; if
// __GNUC__ is defined but __STDC__ is not, we leave the new keywords alone.

// __pure2 can be used for functions that are only a function of their scalar
// arguments (meaning they can't dereference pointers).
//
// __stateful_pure can be used for functions that have no side effects,
// but depend on the state of the memory.

// __unused denotes variables and functions that may not be used, preventing
// the compiler from warning about it if not used.

// __used forces variables and functions to be included even if it appears
// to the compiler that they are not used (and would thust be discarded).

// __cold marks code used for debugging or that is rarely taken
// and tells the compiler to optimize for size and outline code.

// __exported denotes symbols that should be exported even when symbols
// are hidden by default.
// __exported_push/_exported_pop are pragmas used to delimit a range of
//  symbols that should be exported even when symbols are hidden by default.

// __deprecated causes the compiler to produce a warning when encountering
// code using the deprecated functionality.
// __deprecated_msg() does the same, and compilers that support it will print
// a message along with the deprecation warning.
// This may require turning on such warning with the -Wdeprecated flag.
// __deprecated_enum_msg() should be used on enums, and compilers that support
// it will print the deprecation warning.
// __kpi_deprecated() specifically indicates deprecation of kernel programming
// interfaces in Kernel.framework used by KEXTs.

// __unavailable causes the compiler to error out when encountering
// code using the tagged function

// Delete pseudo-keywords wherever they are not available or needed.

// We use `__restrict' as a way to define the `restrict' type qualifier
// without disturbing older software that is unaware of C99 keywords.

// Compatibility with compilers and environments that don't support the
// nullability feature.

// __disable_tail_calls causes the compiler to not perform tail call
// optimization inside the marked function.

// __not_tail_called causes the compiler to prevent tail call optimization
// on statically bound calls to the function.  It has no effect on indirect
// calls.  Virtual functions, objective-c methods, and functions marked as
// "always_inline" cannot be marked as __not_tail_called.

// __result_use_check warns callers of a function that not using the function
// return value is a bug, i.e. dismissing malloc() return value results in a
// memory leak.

// __swift_unavailable causes the compiler to mark a symbol as specifically
// unavailable in Swift, regardless of any other availability in C.

// __abortlike is the attribute to put on functions like abort() that are
// typically used to mark assertions. These optimize the codegen
// for outlining while still maintaining debugability.

// Declaring inline functions within headers is error-prone due to differences
// across various versions of the C language and extensions.  __header_inline
// can be used to declare inline functions within system headers.  In cases
// where you want to force inlining instead of letting the compiler make
// the decision, you can use __header_always_inline.
//
// Be aware that using inline for functions which compilers may also provide
// builtins can behave differently under various compilers.  If you intend to
// provide an inline version of such a function, you may want to use a macro
// instead.
//
// The check for !__GNUC__ || __clang__ is because gcc doesn't correctly
// support c99 inline in some cases:
// http://gcc.gnu.org/bugzilla/show_bug.cgi?id=55965

// Compiler-dependent macros that bracket portions of code where the
// "-Wunreachable-code" warning should be ignored. Please use sparingly.

// Compiler-dependent macros to declare that functions take printf-like
// or scanf-like arguments.  They are null except for versions of gcc
// that are known to support the features properly.  Functions declared
// with these attributes will cause compilation warnings if there is a
// mismatch between the format string and subsequent function parameter
// types.

// Source compatibility only, ID string not emitted in object file

// __alloc_size can be used to label function arguments that represent the
// size of memory that the function allocates and returns. The one-argument
// form labels a single argument that gives the allocation size (where the
// arguments are numbered from 1):
//
// void	*malloc(size_t __size) __alloc_size(1);
//
// The two-argument form handles the case where the size is calculated as the
// product of two arguments:
//
// void	*calloc(size_t __count, size_t __size) __alloc_size(1,2);

// COMPILATION ENVIRONMENTS -- see compat(5) for additional detail
//
// DEFAULT	By default newly complied code will get POSIX APIs plus
//		Apple API extensions in scope.
//
//		Most users will use this compilation environment to avoid
//		behavioral differences between 32 and 64 bit code.
//
// LEGACY	Defining _NONSTD_SOURCE will get pre-POSIX APIs plus Apple
//		API extensions in scope.
//
//		This is generally equivalent to the Tiger release compilation
//		environment, except that it cannot be applied to 64 bit code;
//		its use is discouraged.
//
//		We expect this environment to be deprecated in the future.
//
// STRICT	Defining _POSIX_C_SOURCE or _XOPEN_SOURCE restricts the
//		available APIs to exactly the set of APIs defined by the
//		corresponding standard, based on the value defined.
//
//		A correct, portable definition for _POSIX_C_SOURCE is 200112L.
//		A correct, portable definition for _XOPEN_SOURCE is 600L.
//
//		Apple API extensions are not visible in this environment,
//		which can cause Apple specific code to fail to compile,
//		or behave incorrectly if prototypes are not in scope or
//		warnings about missing prototypes are not enabled or ignored.
//
// In any compilation environment, for correct symbol resolution to occur,
// function prototypes must be in scope.  It is recommended that all Apple
// tools users add either the "-Wall" or "-Wimplicit-function-declaration"
// compiler flags to their projects to be warned when a function is being
// used without a prototype in scope.

// These settings are particular to each product.
// Platform: MacOSX

// The __DARWIN_ALIAS macros are used to do symbol renaming; they allow
// legacy code to use the old symbol, thus maintaining binary compatibility
// while new code can use a standards compliant version of the same function.
//
// __DARWIN_ALIAS is used by itself if the function signature has not
// changed, it is used along with a #ifdef check for __DARWIN_UNIX03
// if the signature has changed.  Because the __LP64__ environment
// only supports UNIX03 semantics it causes __DARWIN_UNIX03 to be
// defined, but causes __DARWIN_ALIAS to do no symbol mangling.
//
// As a special case, when XCode is used to target a specific version of the
// OS, the manifest constant __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
// will be defined by the compiler, with the digits representing major version
// time 100 + minor version times 10 (e.g. 10.5 := 1050).  If we are targeting
// pre-10.5, and it is the default compilation environment, revert the
// compilation environment to pre-__DARWIN_UNIX03.

// symbol suffixes used for symbol versioning

// symbol versioning macros

// symbol release macros
// Copyright (c) 2010 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// POSIX.1 requires that the macros we test be defined before any standard
// header file is included.  This permits us to convert values for feature
// testing, as necessary, using only _POSIX_C_SOURCE.
//
// Here's a quick run-down of the versions:
//  defined(_POSIX_SOURCE)		1003.1-1988
//  _POSIX_C_SOURCE == 1L		1003.1-1990
//  _POSIX_C_SOURCE == 2L		1003.2-1992 C Language Binding Option
//  _POSIX_C_SOURCE == 199309L		1003.1b-1993
//  _POSIX_C_SOURCE == 199506L		1003.1c-1995, 1003.1i-1995,
//					and the omnibus ISO/IEC 9945-1: 1996
//  _POSIX_C_SOURCE == 200112L		1003.1-2001
//  _POSIX_C_SOURCE == 200809L		1003.1-2008
//
// In addition, the X/Open Portability Guide, which is now the Single UNIX
// Specification, defines a feature-test macro which indicates the version of
// that specification, and which subsumes _POSIX_C_SOURCE.

// Deal with IEEE Std. 1003.1-1990, in which _POSIX_C_SOURCE == 1L.

// Deal with IEEE Std. 1003.2-1992, in which _POSIX_C_SOURCE == 2L.

// Deal with various X/Open Portability Guides and Single UNIX Spec.

// Deal with all versions of POSIX.  The ordering relative to the tests above is
// important.

// POSIX C deprecation macros
// Copyright (c) 2010 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Set a single macro which will always be defined and can be used to determine
// the appropriate namespace.  For POSIX, these values will correspond to
// _POSIX_C_SOURCE value.  Currently there are two additional levels corresponding
// to ANSI (_ANSI_SOURCE) and Darwin extensions (_DARWIN_C_SOURCE)

// If the developer has neither requested a strict language mode nor a version
// of POSIX, turn on functionality provided by __STDC_WANT_LIB_EXT1__ as part
// of __DARWIN_C_FULL.

// long long is not supported in c89 (__STRICT_ANSI__), but g++ -ansi and
// c99 still want long longs.  While not perfect, we allow long longs for
// g++.

// ****************************************
//
//  Public darwin-specific feature macros
//

// _DARWIN_FEATURE_64_BIT_INODE indicates that the ino_t type is 64-bit, and
// structures modified for 64-bit inodes (like struct stat) will be used.

// _DARWIN_FEATURE_64_ONLY_BIT_INODE indicates that the ino_t type may only
// be 64-bit; there is no support for 32-bit ino_t when this macro is defined
// (and non-zero).  There is no struct stat64 either, as the regular
// struct stat will already be the 64-bit version.

// _DARWIN_FEATURE_ONLY_VERS_1050 indicates that only those APIs updated
// in 10.5 exists; no pre-10.5 variants are available.

// _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE indicates only UNIX conforming API
// are available (the legacy BSD APIs are not available)

// _DARWIN_FEATURE_UNIX_CONFORMANCE indicates whether UNIX conformance is on,
// and specifies the conformance level (3 is SUSv3)

// This macro casts away the qualifier from the variable
//
// Note: use at your own risk, removing qualifiers can result in
// catastrophic run-time failures.

// __XNU_PRIVATE_EXTERN is a linkage decoration indicating that a symbol can be
// used from other compilation units, but not other libraries or executables.

// We intentionally define to nothing pointer attributes which do not have an
// impact on the ABI. __indexable and __bidi_indexable are not defined because
// of the ABI incompatibility that makes the diagnostic preferable.

// Similarly, we intentionally define to nothing the
// __ptrcheck_abi_assume_single and __ptrcheck_abi_assume_unsafe_indexable
// macros because they do not lead to an ABI incompatibility. However, we do not
// define the indexable and unsafe_indexable ones because the diagnostic is
// better than the silent ABI break.

// __unsafe_forge intrinsics are defined as regular C casts.

// decay operates normally; attribute is meaningless without pointer checks.

// Architecture validation for current SDK

// Similar to OS_ENUM/OS_CLOSED_ENUM/OS_OPTIONS/OS_CLOSED_OPTIONS
//
// This provides more advanced type checking on compilers supporting
// the proper extensions, even in C.

// Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2003 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// This header file contains integer types.  It's intended to also contain
// flotaing point and other arithmetic types, as needed, later.

type X__int8_t = int8     /* _types.h:39:33 */
type X__uint8_t = uint8   /* _types.h:43:33 */
type X__int16_t = int16   /* _types.h:44:33 */
type X__uint16_t = uint16 /* _types.h:45:33 */
type X__int32_t = int32   /* _types.h:46:33 */
type X__uint32_t = uint32 /* _types.h:47:33 */
type X__int64_t = int64   /* _types.h:48:33 */
type X__uint64_t = uint64 /* _types.h:49:33 */

type X__darwin_intptr_t = int64   /* _types.h:51:33 */
type X__darwin_natural_t = uint32 /* _types.h:52:33 */

// The rune type below is declared to be an ``int'' instead of the more natural
// ``unsigned long'' or ``long''.  Two things are happening here.  It is not
// unsigned so that EOF (-1) can be naturally assigned to it and used.  Also,
// it looks like 10646 will be a 31 bit standard.  This means that if your
// ints cannot hold 32 bits, you will be in trouble.  The reason an int was
// chosen over a long is that the is*() and to*() routines take ints (says
// ANSI C), but they use __darwin_ct_rune_t instead of int.  By changing it
// here, you lose a bit of ANSI conformance, but your programs will still
// work.
//
// NOTE: rune_t is not covered by ANSI nor other standards, and should not
// be instantiated outside of lib/libc/locale.  Use wchar_t.  wchar_t and
// rune_t must be the same type.  Also wint_t must be no narrower than
// wchar_t, and should also be able to hold all members of the largest
// character set plus one extra value (WEOF). wint_t must be at least 16 bits.

type X__darwin_ct_rune_t = int32 /* _types.h:72:33 */ // ct_rune_t

// mbstate_t is an opaque object to keep conversion state, during multibyte
// stream conversions.  The content must not be referenced by user programs.
type X__mbstate_t = struct {
	__ccgo_pad1 [0]uint64
	X__mbstate8 [128]int8
} /* _types.h:81:3 */

type X__darwin_mbstate_t = X__mbstate_t /* _types.h:83:33 */ // mbstate_t

type X__darwin_ptrdiff_t = int64 /* _types.h:86:33 */ // ptr1 - ptr2

type X__darwin_size_t = uint64 /* _types.h:94:33 */ // sizeof()

type X__darwin_va_list = X__builtin_va_list /* _types.h:100:33 */ // va_list

type X__darwin_wchar_t = int32 /* _types.h:106:33 */ // wchar_t

type X__darwin_rune_t = X__darwin_wchar_t /* _types.h:111:33 */ // rune_t

type X__darwin_wint_t = int32 /* _types.h:114:33 */ // wint_t

type X__darwin_clock_t = uint64        /* _types.h:119:33 */ // clock()
type X__darwin_socklen_t = X__uint32_t /* _types.h:120:33 */ // socklen_t (duh)
type X__darwin_ssize_t = int64         /* _types.h:121:33 */ // byte count or error
type X__darwin_time_t = int64          /* _types.h:122:33 */ // time()

// Type definitions; takes common type definitions that must be used
// in multiple header files due to [XSI], removes them from the system
// space, and puts them in the implementation space.

type X__darwin_blkcnt_t = X__int64_t                    /* _types.h:55:25 */ // total blocks
type X__darwin_blksize_t = X__int32_t                   /* _types.h:56:25 */ // preferred block size
type X__darwin_dev_t = X__int32_t                       /* _types.h:57:25 */ // dev_t
type X__darwin_fsblkcnt_t = uint32                      /* _types.h:58:25 */ // Used by statvfs and fstatvfs
type X__darwin_fsfilcnt_t = uint32                      /* _types.h:59:25 */ // Used by statvfs and fstatvfs
type X__darwin_gid_t = X__uint32_t                      /* _types.h:60:25 */ // [???] process and group IDs
type X__darwin_id_t = X__uint32_t                       /* _types.h:61:25 */ // [XSI] pid_t, uid_t, or gid_t
type X__darwin_ino64_t = X__uint64_t                    /* _types.h:62:25 */ // [???] Used for 64 bit inodes
type X__darwin_ino_t = X__darwin_ino64_t                /* _types.h:64:26 */ // [???] Used for inodes
type X__darwin_mach_port_name_t = X__darwin_natural_t   /* _types.h:68:28 */ // Used by mach
type X__darwin_mach_port_t = X__darwin_mach_port_name_t /* _types.h:69:35 */ // Used by mach
type X__darwin_mode_t = X__uint16_t                     /* _types.h:70:25 */ // [???] Some file attributes
type X__darwin_off_t = X__int64_t                       /* _types.h:71:25 */ // [???] Used for file sizes
type X__darwin_pid_t = X__int32_t                       /* _types.h:72:25 */ // [???] process and group IDs
type X__darwin_sigset_t = X__uint32_t                   /* _types.h:73:25 */ // [???] signal set
type X__darwin_suseconds_t = X__int32_t                 /* _types.h:74:25 */ // [???] microseconds
type X__darwin_uid_t = X__uint32_t                      /* _types.h:75:25 */ // [???] user IDs
type X__darwin_useconds_t = X__uint32_t                 /* _types.h:76:25 */ // [???] microseconds
type X__darwin_uuid_t = [16]uint8                       /* _types.h:77:25 */
type X__darwin_uuid_string_t = [37]int8                 /* _types.h:78:17 */

// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// pthread opaque structures

type X__darwin_pthread_handler_rec = struct {
	X__routine uintptr
	X__arg     uintptr
	X__next    uintptr
} /* _pthread_types.h:57:1 */

type X_opaque_pthread_attr_t = struct {
	X__sig    int64
	X__opaque [56]int8
} /* _pthread_types.h:63:1 */

type X_opaque_pthread_cond_t = struct {
	X__sig    int64
	X__opaque [40]int8
} /* _pthread_types.h:68:1 */

type X_opaque_pthread_condattr_t = struct {
	X__sig    int64
	X__opaque [8]int8
} /* _pthread_types.h:73:1 */

type X_opaque_pthread_mutex_t = struct {
	X__sig    int64
	X__opaque [56]int8
} /* _pthread_types.h:78:1 */

type X_opaque_pthread_mutexattr_t = struct {
	X__sig    int64
	X__opaque [8]int8
} /* _pthread_types.h:83:1 */

type X_opaque_pthread_once_t = struct {
	X__sig    int64
	X__opaque [8]int8
} /* _pthread_types.h:88:1 */

type X_opaque_pthread_rwlock_t = struct {
	X__sig    int64
	X__opaque [192]int8
} /* _pthread_types.h:93:1 */

type X_opaque_pthread_rwlockattr_t = struct {
	X__sig    int64
	X__opaque [16]int8
} /* _pthread_types.h:98:1 */

type X_opaque_pthread_t = struct {
	X__sig           int64
	X__cleanup_stack uintptr
	X__opaque        [8176]int8
} /* _pthread_types.h:103:1 */

type X__darwin_pthread_attr_t = X_opaque_pthread_attr_t             /* _pthread_types.h:109:39 */
type X__darwin_pthread_cond_t = X_opaque_pthread_cond_t             /* _pthread_types.h:110:39 */
type X__darwin_pthread_condattr_t = X_opaque_pthread_condattr_t     /* _pthread_types.h:111:43 */
type X__darwin_pthread_key_t = uint64                               /* _pthread_types.h:112:23 */
type X__darwin_pthread_mutex_t = X_opaque_pthread_mutex_t           /* _pthread_types.h:113:40 */
type X__darwin_pthread_mutexattr_t = X_opaque_pthread_mutexattr_t   /* _pthread_types.h:114:44 */
type X__darwin_pthread_once_t = X_opaque_pthread_once_t             /* _pthread_types.h:115:39 */
type X__darwin_pthread_rwlock_t = X_opaque_pthread_rwlock_t         /* _pthread_types.h:116:41 */
type X__darwin_pthread_rwlockattr_t = X_opaque_pthread_rwlockattr_t /* _pthread_types.h:117:45 */
type X__darwin_pthread_t = uintptr                                  /* _pthread_types.h:118:34 */

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type X__darwin_nl_item = int32        /* _types.h:40:14 */
type X__darwin_wctrans_t = int32      /* _types.h:41:14 */
type X__darwin_wctype_t = X__uint32_t /* _types.h:43:20 */

// Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1989, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)wait.h	8.2 (Berkeley) 7/10/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// This file holds definitions relevent to the wait4 system call
// and the alternate interfaces that use it (wait, wait3, waitpid).

// [XSI] The type idtype_t shall be defined as an enumeration type whose
// possible values shall include at least P_ALL, P_PID, and P_PGID.
type Idtype_t = uint32 /* wait.h:83:3 */

// [XSI] The id_t and pid_t types shall be defined as described
// in <sys/types.h>
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pid_t = X__darwin_pid_t /* _pid_t.h:31:31 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Id_t = X__darwin_id_t /* _id_t.h:31:25 */ // can hold pid_t, gid_t, or uid_t

// [XSI] The siginfo_t type shall be defined as described in <signal.h>
// [XSI] The rusage structure shall be defined as described in <sys/resource.h>
// [XSI] Inclusion of the <sys/wait.h> header may also make visible all
// symbols from <signal.h> and <sys/resource.h>
//
// NOTE:	This requirement is currently being satisfied by the direct
//		inclusion of <sys/signal.h> and <sys/resource.h>, below.
//
//		Software should not depend on the exposure of anything other
//		than the types siginfo_t and struct rusage as a result of
//		this inclusion.  If you depend on any types or manifest
//		values othe than siginfo_t and struct rusage from either of
//		those files, you should explicitly include them yourself, as
//		well, or in future releases your stware may not compile
//		without modification.
// Copyright (c) 2000-2006 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1989, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)signal.h	8.2 (Berkeley) 1/21/94

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1992 NeXT Computer, Inc.
//

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

type Sig_atomic_t = int32 /* signal.h:41:13 */

// Language spec sez we must list exactly one parameter, even though we
// actually supply three.  Ugh!
// SIG_HOLD is chosen to avoid KERN_SIG_* values in <sys/signalvar.h>

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2017 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2004-2006 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// @OSF_COPYRIGHT@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

// Copyright (c) 2000-2008 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)types.h	8.3 (Berkeley) 1/5/94

// Copyright (c) 2000-2003 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Basic integral types.  Omit the typedef if
// not possible for a machine/compiler combination.
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Int8_t = int8 /* _int8_t.h:30:31 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Int16_t = int16 /* _int16_t.h:30:33 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Int32_t = int32 /* _int32_t.h:30:33 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Int64_t = int64 /* _int64_t.h:30:33 */

// Copyright (c) 2016 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_int8_t = uint8 /* _u_int8_t.h:30:33 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_int16_t = uint16 /* _u_int16_t.h:30:41 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_int32_t = uint32 /* _u_int32_t.h:30:33 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_int64_t = uint64 /* _u_int64_t.h:30:33 */

type Register_t = Int64_t /* types.h:90:33 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

type Intptr_t = X__darwin_intptr_t /* _intptr_t.h:32:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Uintptr_t = uint64 /* _uintptr_t.h:34:33 */

// These types are used for reserving the largest possible size.
type User_addr_t = U_int64_t  /* types.h:100:33 */
type User_size_t = U_int64_t  /* types.h:101:33 */
type User_ssize_t = Int64_t   /* types.h:102:33 */
type User_long_t = Int64_t    /* types.h:103:33 */
type User_ulong_t = U_int64_t /* types.h:104:33 */
type User_time_t = Int64_t    /* types.h:105:33 */
type User_off_t = Int64_t     /* types.h:106:33 */

// This defines the size of syscall arguments after copying into the kernel:
type Syscall_arg_t = U_int64_t /* types.h:114:33 */

// i386 is the structure that is exported to user threads for
// use in status/mutate calls.  This structure should never change.
//

type X__darwin_i386_thread_state = struct {
	X__eax    uint32
	X__ebx    uint32
	X__ecx    uint32
	X__edx    uint32
	X__edi    uint32
	X__esi    uint32
	X__ebp    uint32
	X__esp    uint32
	X__ss     uint32
	X__eflags uint32
	X__eip    uint32
	X__cs     uint32
	X__ds     uint32
	X__es     uint32
	X__fs     uint32
	X__gs     uint32
} /* _structs.h:48:1 */

// This structure should be double-word aligned for performance

type X__darwin_fp_control = struct {
	__ccgo_pad1 [0]uint16
	X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
} /* _structs.h:94:1 */

type X__darwin_fp_control_t = X__darwin_fp_control /* _structs.h:119:28 */

// Status word.

type X__darwin_fp_status = struct {
	__ccgo_pad1 [0]uint16
	X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
} /* _structs.h:152:1 */

type X__darwin_fp_status_t = X__darwin_fp_status /* _structs.h:169:27 */

// defn of 80bit x87 FPU or MMX register

type X__darwin_mmst_reg = struct {
	X__mmst_reg  [10]int8
	X__mmst_rsrv [6]int8
} /* _structs.h:196:1 */

// defn of 128 bit XMM regs

type X__darwin_xmm_reg = struct{ X__xmm_reg [16]int8 } /* _structs.h:215:1 */

// defn of 256 bit YMM regs

type X__darwin_ymm_reg = struct{ X__ymm_reg [32]int8 } /* _structs.h:231:1 */

// defn of 512 bit ZMM regs

type X__darwin_zmm_reg = struct{ X__zmm_reg [64]int8 } /* _structs.h:247:1 */

type X__darwin_opmask_reg = struct{ X__opmask_reg [8]int8 } /* _structs.h:261:1 */

// Floating point state.

type X__darwin_i386_float_state = struct {
	X__fpu_reserved [2]int32
	X__fpu_fcw      struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	X__fpu_fsw struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	X__fpu_ftw       X__uint8_t
	X__fpu_rsrv1     X__uint8_t
	X__fpu_fop       X__uint16_t
	X__fpu_ip        X__uint32_t
	X__fpu_cs        X__uint16_t
	X__fpu_rsrv2     X__uint16_t
	X__fpu_dp        X__uint32_t
	X__fpu_ds        X__uint16_t
	X__fpu_rsrv3     X__uint16_t
	X__fpu_mxcsr     X__uint32_t
	X__fpu_mxcsrmask X__uint32_t
	X__fpu_stmm0     struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm1 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm2 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm3 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm4 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm5 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm6 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm7 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
	X__fpu_rsrv4     [224]int8
	X__fpu_reserved1 int32
} /* _structs.h:283:1 */

type X__darwin_i386_avx_state = struct {
	X__fpu_reserved [2]int32
	X__fpu_fcw      struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	X__fpu_fsw struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	X__fpu_ftw       X__uint8_t
	X__fpu_rsrv1     X__uint8_t
	X__fpu_fop       X__uint16_t
	X__fpu_ip        X__uint32_t
	X__fpu_cs        X__uint16_t
	X__fpu_rsrv2     X__uint16_t
	X__fpu_dp        X__uint32_t
	X__fpu_ds        X__uint16_t
	X__fpu_rsrv3     X__uint16_t
	X__fpu_mxcsr     X__uint32_t
	X__fpu_mxcsrmask X__uint32_t
	X__fpu_stmm0     struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm1 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm2 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm3 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm4 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm5 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm6 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm7 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
	X__fpu_rsrv4     [224]int8
	X__fpu_reserved1 int32
	X__avx_reserved1 [64]int8
	X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
} /* _structs.h:320:1 */

type X__darwin_i386_avx512_state = struct {
	X__fpu_reserved [2]int32
	X__fpu_fcw      struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	X__fpu_fsw struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	X__fpu_ftw       X__uint8_t
	X__fpu_rsrv1     X__uint8_t
	X__fpu_fop       X__uint16_t
	X__fpu_ip        X__uint32_t
	X__fpu_cs        X__uint16_t
	X__fpu_rsrv2     X__uint16_t
	X__fpu_dp        X__uint32_t
	X__fpu_ds        X__uint16_t
	X__fpu_rsrv3     X__uint16_t
	X__fpu_mxcsr     X__uint32_t
	X__fpu_mxcsrmask X__uint32_t
	X__fpu_stmm0     struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm1 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm2 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm3 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm4 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm5 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm6 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm7 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
	X__fpu_rsrv4     [224]int8
	X__fpu_reserved1 int32
	X__avx_reserved1 [64]int8
	X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
	X__fpu_k0        struct{ X__opmask_reg [8]int8 }
	X__fpu_k1        struct{ X__opmask_reg [8]int8 }
	X__fpu_k2        struct{ X__opmask_reg [8]int8 }
	X__fpu_k3        struct{ X__opmask_reg [8]int8 }
	X__fpu_k4        struct{ X__opmask_reg [8]int8 }
	X__fpu_k5        struct{ X__opmask_reg [8]int8 }
	X__fpu_k6        struct{ X__opmask_reg [8]int8 }
	X__fpu_k7        struct{ X__opmask_reg [8]int8 }
	X__fpu_zmmh0     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh1     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh2     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh3     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh4     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh5     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh6     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh7     struct{ X__ymm_reg [32]int8 }
} /* _structs.h:366:1 */

type X__darwin_i386_exception_state = struct {
	X__trapno     X__uint16_t
	X__cpu        X__uint16_t
	X__err        X__uint32_t
	X__faultvaddr X__uint32_t
} /* _structs.h:577:1 */

type X__darwin_x86_debug_state32 = struct {
	X__dr0 uint32
	X__dr1 uint32
	X__dr2 uint32
	X__dr3 uint32
	X__dr4 uint32
	X__dr5 uint32
	X__dr6 uint32
	X__dr7 uint32
} /* _structs.h:597:1 */

type X__x86_instruction_state = struct {
	X__insn_stream_valid_bytes int32
	X__insn_offset             int32
	X__out_of_synch            int32
	X__insn_bytes              [2380]X__uint8_t
	X__insn_cacheline          [64]X__uint8_t
} /* _structs.h:610:1 */

type X__last_branch_record = struct {
	X__from_ip    X__uint64_t
	X__to_ip      X__uint64_t
	X__mispredict uint32 /* __uint32_t __mispredict: 1, __uint32_t __tsx_abort: 1, __uint32_t __in_tsx: 1, __uint32_t __cycle_count: 16, __uint32_t __reserved: 13 */
	__ccgo_pad1   [4]byte
} /* _structs.h:626:1 */

type X__last_branch_state = struct {
	X__lbr_count         int32
	X__lbr_supported_tsx uint32 /* __uint32_t __lbr_supported_tsx: 1, __uint32_t __lbr_supported_cycle_count: 1, __uint32_t __reserved: 30 */
	__ccgo_pad1          [8]byte
	X__lbrs              [32]struct {
		X__from_ip    X__uint64_t
		X__to_ip      X__uint64_t
		X__mispredict uint32 /* __uint32_t __mispredict: 1, __uint32_t __tsx_abort: 1, __uint32_t __in_tsx: 1, __uint32_t __cycle_count: 16, __uint32_t __reserved: 13 */
		__ccgo_pad1   [4]byte
	}
} /* _structs.h:638:1 */

type X__x86_pagein_state = struct{ X__pagein_error int32 } /* _structs.h:704:1 */

// 64 bit versions of the above

type X__darwin_x86_thread_state64 = struct {
	X__rax    X__uint64_t
	X__rbx    X__uint64_t
	X__rcx    X__uint64_t
	X__rdx    X__uint64_t
	X__rdi    X__uint64_t
	X__rsi    X__uint64_t
	X__rbp    X__uint64_t
	X__rsp    X__uint64_t
	X__r8     X__uint64_t
	X__r9     X__uint64_t
	X__r10    X__uint64_t
	X__r11    X__uint64_t
	X__r12    X__uint64_t
	X__r13    X__uint64_t
	X__r14    X__uint64_t
	X__r15    X__uint64_t
	X__rip    X__uint64_t
	X__rflags X__uint64_t
	X__cs     X__uint64_t
	X__fs     X__uint64_t
	X__gs     X__uint64_t
} /* _structs.h:715:1 */

// 64 bit versions of the above (complete)

type X__darwin_x86_thread_full_state64 = struct {
	X__ss64 struct {
		X__rax    X__uint64_t
		X__rbx    X__uint64_t
		X__rcx    X__uint64_t
		X__rdx    X__uint64_t
		X__rdi    X__uint64_t
		X__rsi    X__uint64_t
		X__rbp    X__uint64_t
		X__rsp    X__uint64_t
		X__r8     X__uint64_t
		X__r9     X__uint64_t
		X__r10    X__uint64_t
		X__r11    X__uint64_t
		X__r12    X__uint64_t
		X__r13    X__uint64_t
		X__r14    X__uint64_t
		X__r15    X__uint64_t
		X__rip    X__uint64_t
		X__rflags X__uint64_t
		X__cs     X__uint64_t
		X__fs     X__uint64_t
		X__gs     X__uint64_t
	}
	X__ds     X__uint64_t
	X__es     X__uint64_t
	X__ss     X__uint64_t
	X__gsbase X__uint64_t
} /* _structs.h:773:1 */

type X__darwin_x86_float_state64 = struct {
	X__fpu_reserved [2]int32
	X__fpu_fcw      struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	X__fpu_fsw struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	X__fpu_ftw       X__uint8_t
	X__fpu_rsrv1     X__uint8_t
	X__fpu_fop       X__uint16_t
	X__fpu_ip        X__uint32_t
	X__fpu_cs        X__uint16_t
	X__fpu_rsrv2     X__uint16_t
	X__fpu_dp        X__uint32_t
	X__fpu_ds        X__uint16_t
	X__fpu_rsrv3     X__uint16_t
	X__fpu_mxcsr     X__uint32_t
	X__fpu_mxcsrmask X__uint32_t
	X__fpu_stmm0     struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm1 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm2 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm3 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm4 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm5 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm6 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm7 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
	X__fpu_rsrv4     [96]int8
	X__fpu_reserved1 int32
} /* _structs.h:796:1 */

type X__darwin_x86_avx_state64 = struct {
	X__fpu_reserved [2]int32
	X__fpu_fcw      struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	X__fpu_fsw struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	X__fpu_ftw       X__uint8_t
	X__fpu_rsrv1     X__uint8_t
	X__fpu_fop       X__uint16_t
	X__fpu_ip        X__uint32_t
	X__fpu_cs        X__uint16_t
	X__fpu_rsrv2     X__uint16_t
	X__fpu_dp        X__uint32_t
	X__fpu_ds        X__uint16_t
	X__fpu_rsrv3     X__uint16_t
	X__fpu_mxcsr     X__uint32_t
	X__fpu_mxcsrmask X__uint32_t
	X__fpu_stmm0     struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm1 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm2 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm3 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm4 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm5 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm6 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm7 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
	X__fpu_rsrv4     [96]int8
	X__fpu_reserved1 int32
	X__avx_reserved1 [64]int8
	X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh8     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh9     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh10    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh11    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh12    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh13    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh14    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh15    struct{ X__xmm_reg [16]int8 }
} /* _structs.h:847:1 */

type X__darwin_x86_avx512_state64 = struct {
	X__fpu_reserved [2]int32
	X__fpu_fcw      struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
	}
	X__fpu_fsw struct {
		__ccgo_pad1 [0]uint16
		X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
	}
	X__fpu_ftw       X__uint8_t
	X__fpu_rsrv1     X__uint8_t
	X__fpu_fop       X__uint16_t
	X__fpu_ip        X__uint32_t
	X__fpu_cs        X__uint16_t
	X__fpu_rsrv2     X__uint16_t
	X__fpu_dp        X__uint32_t
	X__fpu_ds        X__uint16_t
	X__fpu_rsrv3     X__uint16_t
	X__fpu_mxcsr     X__uint32_t
	X__fpu_mxcsrmask X__uint32_t
	X__fpu_stmm0     struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm1 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm2 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm3 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm4 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm5 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm6 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_stmm7 struct {
		X__mmst_reg  [10]int8
		X__mmst_rsrv [6]int8
	}
	X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
	X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
	X__fpu_rsrv4     [96]int8
	X__fpu_reserved1 int32
	X__avx_reserved1 [64]int8
	X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh8     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh9     struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh10    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh11    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh12    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh13    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh14    struct{ X__xmm_reg [16]int8 }
	X__fpu_ymmh15    struct{ X__xmm_reg [16]int8 }
	X__fpu_k0        struct{ X__opmask_reg [8]int8 }
	X__fpu_k1        struct{ X__opmask_reg [8]int8 }
	X__fpu_k2        struct{ X__opmask_reg [8]int8 }
	X__fpu_k3        struct{ X__opmask_reg [8]int8 }
	X__fpu_k4        struct{ X__opmask_reg [8]int8 }
	X__fpu_k5        struct{ X__opmask_reg [8]int8 }
	X__fpu_k6        struct{ X__opmask_reg [8]int8 }
	X__fpu_k7        struct{ X__opmask_reg [8]int8 }
	X__fpu_zmmh0     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh1     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh2     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh3     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh4     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh5     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh6     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh7     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh8     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh9     struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh10    struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh11    struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh12    struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh13    struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh14    struct{ X__ymm_reg [32]int8 }
	X__fpu_zmmh15    struct{ X__ymm_reg [32]int8 }
	X__fpu_zmm16     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm17     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm18     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm19     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm20     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm21     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm22     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm23     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm24     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm25     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm26     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm27     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm28     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm29     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm30     struct{ X__zmm_reg [64]int8 }
	X__fpu_zmm31     struct{ X__zmm_reg [64]int8 }
} /* _structs.h:915:1 */

type X__darwin_x86_exception_state64 = struct {
	X__trapno     X__uint16_t
	X__cpu        X__uint16_t
	X__err        X__uint32_t
	X__faultvaddr X__uint64_t
} /* _structs.h:1254:1 */

type X__darwin_x86_debug_state64 = struct {
	X__dr0 X__uint64_t
	X__dr1 X__uint64_t
	X__dr2 X__uint64_t
	X__dr3 X__uint64_t
	X__dr4 X__uint64_t
	X__dr5 X__uint64_t
	X__dr6 X__uint64_t
	X__dr7 X__uint64_t
} /* _structs.h:1274:1 */

type X__darwin_x86_cpmu_state64 = struct{ X__ctrs [16]X__uint64_t } /* _structs.h:1302:1 */

type X__darwin_mcontext32 = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint32_t
	}
	X__ss struct {
		X__eax    uint32
		X__ebx    uint32
		X__ecx    uint32
		X__edx    uint32
		X__edi    uint32
		X__esi    uint32
		X__ebp    uint32
		X__esp    uint32
		X__ss     uint32
		X__eflags uint32
		X__eip    uint32
		X__cs     uint32
		X__ds     uint32
		X__es     uint32
		X__fs     uint32
		X__gs     uint32
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [224]int8
		X__fpu_reserved1 int32
	}
} /* _mcontext.h:41:1 */

type X__darwin_mcontext_avx32 = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint32_t
	}
	X__ss struct {
		X__eax    uint32
		X__ebx    uint32
		X__ecx    uint32
		X__edx    uint32
		X__edi    uint32
		X__esi    uint32
		X__ebp    uint32
		X__esp    uint32
		X__ss     uint32
		X__eflags uint32
		X__eip    uint32
		X__cs     uint32
		X__ds     uint32
		X__es     uint32
		X__fs     uint32
		X__gs     uint32
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [224]int8
		X__fpu_reserved1 int32
		X__avx_reserved1 [64]int8
		X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
	}
} /* _mcontext.h:49:1 */

type X__darwin_mcontext_avx512_32 = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint32_t
	}
	X__ss struct {
		X__eax    uint32
		X__ebx    uint32
		X__ecx    uint32
		X__edx    uint32
		X__edi    uint32
		X__esi    uint32
		X__ebp    uint32
		X__esp    uint32
		X__ss     uint32
		X__eflags uint32
		X__eip    uint32
		X__cs     uint32
		X__ds     uint32
		X__es     uint32
		X__fs     uint32
		X__gs     uint32
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [224]int8
		X__fpu_reserved1 int32
		X__avx_reserved1 [64]int8
		X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
		X__fpu_k0        struct{ X__opmask_reg [8]int8 }
		X__fpu_k1        struct{ X__opmask_reg [8]int8 }
		X__fpu_k2        struct{ X__opmask_reg [8]int8 }
		X__fpu_k3        struct{ X__opmask_reg [8]int8 }
		X__fpu_k4        struct{ X__opmask_reg [8]int8 }
		X__fpu_k5        struct{ X__opmask_reg [8]int8 }
		X__fpu_k6        struct{ X__opmask_reg [8]int8 }
		X__fpu_k7        struct{ X__opmask_reg [8]int8 }
		X__fpu_zmmh0     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh1     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh2     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh3     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh4     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh5     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh6     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh7     struct{ X__ymm_reg [32]int8 }
	}
} /* _mcontext.h:58:1 */

type X__darwin_mcontext64 = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint64_t
	}
	X__ss struct {
		X__rax    X__uint64_t
		X__rbx    X__uint64_t
		X__rcx    X__uint64_t
		X__rdx    X__uint64_t
		X__rdi    X__uint64_t
		X__rsi    X__uint64_t
		X__rbp    X__uint64_t
		X__rsp    X__uint64_t
		X__r8     X__uint64_t
		X__r9     X__uint64_t
		X__r10    X__uint64_t
		X__r11    X__uint64_t
		X__r12    X__uint64_t
		X__r13    X__uint64_t
		X__r14    X__uint64_t
		X__r15    X__uint64_t
		X__rip    X__uint64_t
		X__rflags X__uint64_t
		X__cs     X__uint64_t
		X__fs     X__uint64_t
		X__gs     X__uint64_t
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [96]int8
		X__fpu_reserved1 int32
	}
	__ccgo_pad1 [4]byte
} /* _mcontext.h:99:1 */

type X__darwin_mcontext64_full = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint64_t
	}
	X__ss struct {
		X__ss64 struct {
			X__rax    X__uint64_t
			X__rbx    X__uint64_t
			X__rcx    X__uint64_t
			X__rdx    X__uint64_t
			X__rdi    X__uint64_t
			X__rsi    X__uint64_t
			X__rbp    X__uint64_t
			X__rsp    X__uint64_t
			X__r8     X__uint64_t
			X__r9     X__uint64_t
			X__r10    X__uint64_t
			X__r11    X__uint64_t
			X__r12    X__uint64_t
			X__r13    X__uint64_t
			X__r14    X__uint64_t
			X__r15    X__uint64_t
			X__rip    X__uint64_t
			X__rflags X__uint64_t
			X__cs     X__uint64_t
			X__fs     X__uint64_t
			X__gs     X__uint64_t
		}
		X__ds     X__uint64_t
		X__es     X__uint64_t
		X__ss     X__uint64_t
		X__gsbase X__uint64_t
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [96]int8
		X__fpu_reserved1 int32
	}
	__ccgo_pad1 [4]byte
} /* _mcontext.h:107:1 */

type X__darwin_mcontext_avx64 = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint64_t
	}
	X__ss struct {
		X__rax    X__uint64_t
		X__rbx    X__uint64_t
		X__rcx    X__uint64_t
		X__rdx    X__uint64_t
		X__rdi    X__uint64_t
		X__rsi    X__uint64_t
		X__rbp    X__uint64_t
		X__rsp    X__uint64_t
		X__r8     X__uint64_t
		X__r9     X__uint64_t
		X__r10    X__uint64_t
		X__r11    X__uint64_t
		X__r12    X__uint64_t
		X__r13    X__uint64_t
		X__r14    X__uint64_t
		X__r15    X__uint64_t
		X__rip    X__uint64_t
		X__rflags X__uint64_t
		X__cs     X__uint64_t
		X__fs     X__uint64_t
		X__gs     X__uint64_t
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [96]int8
		X__fpu_reserved1 int32
		X__avx_reserved1 [64]int8
		X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh8     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh9     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh10    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh11    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh12    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh13    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh14    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh15    struct{ X__xmm_reg [16]int8 }
	}
	__ccgo_pad1 [4]byte
} /* _mcontext.h:115:1 */

type X__darwin_mcontext_avx64_full = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint64_t
	}
	X__ss struct {
		X__ss64 struct {
			X__rax    X__uint64_t
			X__rbx    X__uint64_t
			X__rcx    X__uint64_t
			X__rdx    X__uint64_t
			X__rdi    X__uint64_t
			X__rsi    X__uint64_t
			X__rbp    X__uint64_t
			X__rsp    X__uint64_t
			X__r8     X__uint64_t
			X__r9     X__uint64_t
			X__r10    X__uint64_t
			X__r11    X__uint64_t
			X__r12    X__uint64_t
			X__r13    X__uint64_t
			X__r14    X__uint64_t
			X__r15    X__uint64_t
			X__rip    X__uint64_t
			X__rflags X__uint64_t
			X__cs     X__uint64_t
			X__fs     X__uint64_t
			X__gs     X__uint64_t
		}
		X__ds     X__uint64_t
		X__es     X__uint64_t
		X__ss     X__uint64_t
		X__gsbase X__uint64_t
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [96]int8
		X__fpu_reserved1 int32
		X__avx_reserved1 [64]int8
		X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh8     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh9     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh10    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh11    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh12    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh13    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh14    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh15    struct{ X__xmm_reg [16]int8 }
	}
	__ccgo_pad1 [4]byte
} /* _mcontext.h:123:1 */

type X__darwin_mcontext_avx512_64 = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint64_t
	}
	X__ss struct {
		X__rax    X__uint64_t
		X__rbx    X__uint64_t
		X__rcx    X__uint64_t
		X__rdx    X__uint64_t
		X__rdi    X__uint64_t
		X__rsi    X__uint64_t
		X__rbp    X__uint64_t
		X__rsp    X__uint64_t
		X__r8     X__uint64_t
		X__r9     X__uint64_t
		X__r10    X__uint64_t
		X__r11    X__uint64_t
		X__r12    X__uint64_t
		X__r13    X__uint64_t
		X__r14    X__uint64_t
		X__r15    X__uint64_t
		X__rip    X__uint64_t
		X__rflags X__uint64_t
		X__cs     X__uint64_t
		X__fs     X__uint64_t
		X__gs     X__uint64_t
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [96]int8
		X__fpu_reserved1 int32
		X__avx_reserved1 [64]int8
		X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh8     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh9     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh10    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh11    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh12    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh13    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh14    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh15    struct{ X__xmm_reg [16]int8 }
		X__fpu_k0        struct{ X__opmask_reg [8]int8 }
		X__fpu_k1        struct{ X__opmask_reg [8]int8 }
		X__fpu_k2        struct{ X__opmask_reg [8]int8 }
		X__fpu_k3        struct{ X__opmask_reg [8]int8 }
		X__fpu_k4        struct{ X__opmask_reg [8]int8 }
		X__fpu_k5        struct{ X__opmask_reg [8]int8 }
		X__fpu_k6        struct{ X__opmask_reg [8]int8 }
		X__fpu_k7        struct{ X__opmask_reg [8]int8 }
		X__fpu_zmmh0     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh1     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh2     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh3     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh4     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh5     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh6     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh7     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh8     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh9     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh10    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh11    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh12    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh13    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh14    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh15    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmm16     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm17     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm18     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm19     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm20     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm21     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm22     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm23     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm24     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm25     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm26     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm27     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm28     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm29     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm30     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm31     struct{ X__zmm_reg [64]int8 }
	}
	__ccgo_pad1 [4]byte
} /* _mcontext.h:132:1 */

type X__darwin_mcontext_avx512_64_full = struct {
	X__es struct {
		X__trapno     X__uint16_t
		X__cpu        X__uint16_t
		X__err        X__uint32_t
		X__faultvaddr X__uint64_t
	}
	X__ss struct {
		X__ss64 struct {
			X__rax    X__uint64_t
			X__rbx    X__uint64_t
			X__rcx    X__uint64_t
			X__rdx    X__uint64_t
			X__rdi    X__uint64_t
			X__rsi    X__uint64_t
			X__rbp    X__uint64_t
			X__rsp    X__uint64_t
			X__r8     X__uint64_t
			X__r9     X__uint64_t
			X__r10    X__uint64_t
			X__r11    X__uint64_t
			X__r12    X__uint64_t
			X__r13    X__uint64_t
			X__r14    X__uint64_t
			X__r15    X__uint64_t
			X__rip    X__uint64_t
			X__rflags X__uint64_t
			X__cs     X__uint64_t
			X__fs     X__uint64_t
			X__gs     X__uint64_t
		}
		X__ds     X__uint64_t
		X__es     X__uint64_t
		X__ss     X__uint64_t
		X__gsbase X__uint64_t
	}
	X__fs struct {
		X__fpu_reserved [2]int32
		X__fpu_fcw      struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short : 2, unsigned short __pc: 2, unsigned short __rc: 2, unsigned short : 1, unsigned short : 3 */
		}
		X__fpu_fsw struct {
			__ccgo_pad1 [0]uint16
			X__invalid  uint16 /* unsigned short __invalid: 1, unsigned short __denorm: 1, unsigned short __zdiv: 1, unsigned short __ovrfl: 1, unsigned short __undfl: 1, unsigned short __precis: 1, unsigned short __stkflt: 1, unsigned short __errsumm: 1, unsigned short __c0: 1, unsigned short __c1: 1, unsigned short __c2: 1, unsigned short __tos: 3, unsigned short __c3: 1, unsigned short __busy: 1 */
		}
		X__fpu_ftw       X__uint8_t
		X__fpu_rsrv1     X__uint8_t
		X__fpu_fop       X__uint16_t
		X__fpu_ip        X__uint32_t
		X__fpu_cs        X__uint16_t
		X__fpu_rsrv2     X__uint16_t
		X__fpu_dp        X__uint32_t
		X__fpu_ds        X__uint16_t
		X__fpu_rsrv3     X__uint16_t
		X__fpu_mxcsr     X__uint32_t
		X__fpu_mxcsrmask X__uint32_t
		X__fpu_stmm0     struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm1 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm2 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm3 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm4 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm5 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm6 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_stmm7 struct {
			X__mmst_reg  [10]int8
			X__mmst_rsrv [6]int8
		}
		X__fpu_xmm0      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm1      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm2      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm3      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm4      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm5      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm6      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm7      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm8      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm9      struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm10     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm11     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm12     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm13     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm14     struct{ X__xmm_reg [16]int8 }
		X__fpu_xmm15     struct{ X__xmm_reg [16]int8 }
		X__fpu_rsrv4     [96]int8
		X__fpu_reserved1 int32
		X__avx_reserved1 [64]int8
		X__fpu_ymmh0     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh1     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh2     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh3     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh4     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh5     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh6     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh7     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh8     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh9     struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh10    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh11    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh12    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh13    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh14    struct{ X__xmm_reg [16]int8 }
		X__fpu_ymmh15    struct{ X__xmm_reg [16]int8 }
		X__fpu_k0        struct{ X__opmask_reg [8]int8 }
		X__fpu_k1        struct{ X__opmask_reg [8]int8 }
		X__fpu_k2        struct{ X__opmask_reg [8]int8 }
		X__fpu_k3        struct{ X__opmask_reg [8]int8 }
		X__fpu_k4        struct{ X__opmask_reg [8]int8 }
		X__fpu_k5        struct{ X__opmask_reg [8]int8 }
		X__fpu_k6        struct{ X__opmask_reg [8]int8 }
		X__fpu_k7        struct{ X__opmask_reg [8]int8 }
		X__fpu_zmmh0     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh1     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh2     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh3     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh4     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh5     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh6     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh7     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh8     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh9     struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh10    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh11    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh12    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh13    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh14    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmmh15    struct{ X__ymm_reg [32]int8 }
		X__fpu_zmm16     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm17     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm18     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm19     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm20     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm21     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm22     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm23     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm24     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm25     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm26     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm27     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm28     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm29     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm30     struct{ X__zmm_reg [64]int8 }
		X__fpu_zmm31     struct{ X__zmm_reg [64]int8 }
	}
	__ccgo_pad1 [4]byte
} /* _mcontext.h:140:1 */

type Mcontext_t = uintptr /* _mcontext.h:206:33 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_attr_t = X__darwin_pthread_attr_t /* _pthread_attr_t.h:31:33 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Structure used in sigaltstack call.

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

type X__darwin_sigaltstack = struct {
	Ss_sp       uintptr
	Ss_size     X__darwin_size_t
	Ss_flags    int32
	__ccgo_pad1 [4]byte
} /* _sigaltstack.h:42:1 */

type Stack_t = X__darwin_sigaltstack /* _sigaltstack.h:48:33 */ // [???] signal stack

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Structure used in sigaltstack call.

type X__darwin_ucontext = struct {
	Uc_onstack int32
	Uc_sigmask X__darwin_sigset_t
	Uc_stack   struct {
		Ss_sp       uintptr
		Ss_size     X__darwin_size_t
		Ss_flags    int32
		__ccgo_pad1 [4]byte
	}
	Uc_link     uintptr
	Uc_mcsize   X__darwin_size_t
	Uc_mcontext uintptr
} /* _ucontext.h:43:1 */

// user context
type Ucontext_t = X__darwin_ucontext /* _ucontext.h:57:33 */ // [???] user context

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Sigset_t = X__darwin_sigset_t /* _sigset_t.h:31:41 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Uid_t = X__darwin_uid_t /* _uid_t.h:31:31 */

type Sigval = struct {
	__ccgo_pad1 [0]uint64
	Sival_int   int32
	__ccgo_pad2 [4]byte
} /* signal.h:158:1 */

type Sigevent = struct {
	Sigev_notify int32
	Sigev_signo  int32
	Sigev_value  struct {
		__ccgo_pad1 [0]uint64
		Sival_int   int32
		__ccgo_pad2 [4]byte
	}
	Sigev_notify_function   uintptr
	Sigev_notify_attributes uintptr
} /* signal.h:168:1 */

type X__siginfo = struct {
	Si_signo  int32
	Si_errno  int32
	Si_code   int32
	Si_pid    Pid_t
	Si_uid    Uid_t
	Si_status int32
	Si_addr   uintptr
	Si_value  struct {
		__ccgo_pad1 [0]uint64
		Sival_int   int32
		__ccgo_pad2 [4]byte
	}
	Si_band int64
	X__pad  [7]uint64
} /* signal.h:177:9 */

type Siginfo_t = X__siginfo /* signal.h:188:3 */

// When the signal is SIGILL or SIGFPE, si_addr contains the address of
// the faulting instruction.
// When the signal is SIGSEGV or SIGBUS, si_addr contains the address of
// the faulting memory reference. Although for x86 there are cases of SIGSEGV
// for which si_addr cannot be determined and is NULL.
// If the signal is SIGCHLD, the si_pid field will contain the child process ID,
//  si_status contains the exit value or signal and
//  si_uid contains the real user ID of the process that sent the signal.

// Values for si_code

// Codes for SIGILL

// Codes for SIGFPE

// Codes for SIGSEGV

// Codes for SIGBUS

// Codes for SIGTRAP

// Codes for SIGCHLD

// Codes for SIGPOLL

// union for signal handlers
type X__sigaction_u = struct{ X__sa_handler uintptr } /* signal.h:269:1 */

// Signal vector template for Kernel user boundary
type X__sigaction = struct {
	X__sigaction_u struct{ X__sa_handler uintptr }
	Sa_tramp       uintptr
	Sa_mask        Sigset_t
	Sa_flags       int32
} /* signal.h:276:1 */

// Signal vector "template" used in sigaction call.
type Sigaction = struct {
	X__sigaction_u struct{ X__sa_handler uintptr }
	Sa_mask        Sigset_t
	Sa_flags       int32
} /* signal.h:286:1 */

// if SA_SIGINFO is set, sa_sigaction is to be used instead of sa_handler.

// This will provide 64bit register set in a 32bit user address space

// the following are the only bits we support from user space, the
// rest are for kernel use only.

// Flags for sigprocmask:

// POSIX 1003.1b required values.

type Sig_t = uintptr /* signal.h:331:14 */ // type of signal function

// Structure used in sigaltstack call.

// 4.3 compatibility:
// Signal vector "template" used in sigvec call.
type Sigvec = struct {
	Sv_handler uintptr
	Sv_mask    int32
	Sv_flags   int32
} /* signal.h:348:1 */

// Structure used in sigstack call.
type Sigstack = struct {
	Ss_sp       uintptr
	Ss_onstack  int32
	__ccgo_pad1 [4]byte
} /* signal.h:367:1 */

type Uint64_t = uint64 /* stdint.h:98:25 */

type Int_least64_t = Int64_t   /* stdint.h:110:25 */
type Uint_least64_t = Uint64_t /* stdint.h:111:26 */
type Int_fast64_t = Int64_t    /* stdint.h:112:25 */
type Uint_fast64_t = Uint64_t  /* stdint.h:113:26 */

type Uint32_t = uint32 /* stdint.h:172:25 */

type Int_least32_t = Int32_t   /* stdint.h:184:25 */
type Uint_least32_t = Uint32_t /* stdint.h:185:26 */
type Int_fast32_t = Int32_t    /* stdint.h:186:25 */
type Uint_fast32_t = Uint32_t  /* stdint.h:187:26 */
type Uint16_t = uint16         /* stdint.h:207:25 */

type Int_least16_t = Int16_t   /* stdint.h:215:25 */
type Uint_least16_t = Uint16_t /* stdint.h:216:26 */
type Int_fast16_t = Int16_t    /* stdint.h:217:25 */
type Uint_fast16_t = Uint16_t  /* stdint.h:218:26 */
type Uint8_t = uint8           /* stdint.h:226:24 */

type Int_least8_t = Int8_t   /* stdint.h:232:24 */
type Uint_least8_t = Uint8_t /* stdint.h:233:25 */
type Int_fast8_t = Int8_t    /* stdint.h:234:24 */
type Uint_fast8_t = Uint8_t  /* stdint.h:235:25 */

// prevent glibc sys/types.h from defining conflicting types

// C99 7.18.1.4 Integer types capable of holding object pointers.

// C99 7.18.1.5 Greatest-width integer types.
type Intmax_t = int64   /* stdint.h:262:26 */
type Uintmax_t = uint64 /* stdint.h:263:26 */

// C99 7.18.4 Macros for minimum-width integer constants.
//
// The standard requires that integer constant macros be defined for all the
// minimum-width types defined above. As 8-, 16-, 32-, and 64-bit minimum-width
// types are required, the corresponding integer constant macros are defined
// here. This implementation also defines minimum-width types for every other
// integer width that the target implements, so corresponding macros are
// defined below, too.
//
// These macros are defined using the same successive-shrinking approach as
// the type definitions above. It is likewise important that macros are defined
// in order of decending width.
//
// Note that C++ should not check __STDC_CONSTANT_MACROS here, contrary to the
// claims of the C standard (see C++ 18.3.1p2, [cstdint.syn]).

// C99 7.18.2.1 Limits of exact-width integer types.
// C99 7.18.2.2 Limits of minimum-width integer types.
// C99 7.18.2.3 Limits of fastest minimum-width integer types.
//
// The presence of limit macros are completely optional in C99.  This
// implementation defines limits for all of the types (exact- and
// minimum-width) that it defines above, using the limits of the minimum-width
// type for any types that do not have exact-width representations.
//
// As in the type definitions, this section takes an approach of
// successive-shrinking to determine which limits to use for the standard (8,
// 16, 32, 64) bit widths when they don't have exact representations. It is
// therefore important that the definitions be kept in order of decending
// widths.
//
// Note that C++ should not check __STDC_LIMIT_MACROS here, contrary to the
// claims of the C standard (see C++ 18.3.1p2, [cstdint.syn]).

// Some utility macros

// C99 7.18.2.4 Limits of integer types capable of holding object pointers.
// C99 7.18.3 Limits of other integer types.

// ISO9899:2011 7.20 (C11 Annex K): Define RSIZE_MAX if __STDC_WANT_LIB_EXT1__
// is enabled.

// C99 7.18.2.5 Limits of greatest-width integer types.

// C99 7.18.3 Limits of other integer types.

// 7.18.4.2 Macros for greatest-width integer constants.

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// [XSI] The timeval structure shall be defined as described in
// <sys/time.h>
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Timeval = struct {
	Tv_sec      X__darwin_time_t
	Tv_usec     X__darwin_suseconds_t
	__ccgo_pad1 [4]byte
} /* _timeval.h:34:1 */

// The id_t type shall be defined as described in <sys/types.h>
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Resource limit type (low 63 bits, excluding the sign bit)
type Rlim_t = X__uint64_t /* resource.h:89:25 */

// ****
//
// PRIORITY

// Possible values of the first parameter to getpriority()/setpriority(),
// used to indicate the type of the second parameter.

// Range limitations for the value of the third parameter to setpriority().

// use PRIO_DARWIN_BG to set the current thread into "background" state
// which lowers CPU, disk IO, and networking priorites until thread terminates
// or "background" state is revoked

// use PRIO_DARWIN_NONUI to restrict a process's ability to make calls to
// the GPU. (deprecated)

// ****
//
// RESOURCE USAGE

// Possible values of the first parameter to getrusage(), used to indicate
// the scope of the information to be returned.

// A structure representing an accounting of resource utilization.  The
// address of an instance of this structure is the second parameter to
// getrusage().
//
// Note: All values other than ru_utime and ru_stime are implementaiton
//       defined and subject to change in a future release.  Their use
//       is discouraged for standards compliant programs.
type Rusage = struct {
	Ru_utime struct {
		Tv_sec      X__darwin_time_t
		Tv_usec     X__darwin_suseconds_t
		__ccgo_pad1 [4]byte
	}
	Ru_stime struct {
		Tv_sec      X__darwin_time_t
		Tv_usec     X__darwin_suseconds_t
		__ccgo_pad1 [4]byte
	}
	Ru_maxrss   int64
	Ru_ixrss    int64
	Ru_idrss    int64
	Ru_isrss    int64
	Ru_minflt   int64
	Ru_majflt   int64
	Ru_nswap    int64
	Ru_inblock  int64
	Ru_oublock  int64
	Ru_msgsnd   int64
	Ru_msgrcv   int64
	Ru_nsignals int64
	Ru_nvcsw    int64
	Ru_nivcsw   int64
} /* resource.h:152:1 */

// Flavors for proc_pid_rusage().

// Flags for RUSAGE_INFO_V5

type Rusage_info_t = uintptr /* resource.h:199:14 */

type Rusage_info_v0 = struct {
	Ri_uuid               [16]Uint8_t
	Ri_user_time          Uint64_t
	Ri_system_time        Uint64_t
	Ri_pkg_idle_wkups     Uint64_t
	Ri_interrupt_wkups    Uint64_t
	Ri_pageins            Uint64_t
	Ri_wired_size         Uint64_t
	Ri_resident_size      Uint64_t
	Ri_phys_footprint     Uint64_t
	Ri_proc_start_abstime Uint64_t
	Ri_proc_exit_abstime  Uint64_t
} /* resource.h:201:1 */

type Rusage_info_v1 = struct {
	Ri_uuid                  [16]Uint8_t
	Ri_user_time             Uint64_t
	Ri_system_time           Uint64_t
	Ri_pkg_idle_wkups        Uint64_t
	Ri_interrupt_wkups       Uint64_t
	Ri_pageins               Uint64_t
	Ri_wired_size            Uint64_t
	Ri_resident_size         Uint64_t
	Ri_phys_footprint        Uint64_t
	Ri_proc_start_abstime    Uint64_t
	Ri_proc_exit_abstime     Uint64_t
	Ri_child_user_time       Uint64_t
	Ri_child_system_time     Uint64_t
	Ri_child_pkg_idle_wkups  Uint64_t
	Ri_child_interrupt_wkups Uint64_t
	Ri_child_pageins         Uint64_t
	Ri_child_elapsed_abstime Uint64_t
} /* resource.h:215:1 */

type Rusage_info_v2 = struct {
	Ri_uuid                  [16]Uint8_t
	Ri_user_time             Uint64_t
	Ri_system_time           Uint64_t
	Ri_pkg_idle_wkups        Uint64_t
	Ri_interrupt_wkups       Uint64_t
	Ri_pageins               Uint64_t
	Ri_wired_size            Uint64_t
	Ri_resident_size         Uint64_t
	Ri_phys_footprint        Uint64_t
	Ri_proc_start_abstime    Uint64_t
	Ri_proc_exit_abstime     Uint64_t
	Ri_child_user_time       Uint64_t
	Ri_child_system_time     Uint64_t
	Ri_child_pkg_idle_wkups  Uint64_t
	Ri_child_interrupt_wkups Uint64_t
	Ri_child_pageins         Uint64_t
	Ri_child_elapsed_abstime Uint64_t
	Ri_diskio_bytesread      Uint64_t
	Ri_diskio_byteswritten   Uint64_t
} /* resource.h:235:1 */

type Rusage_info_v3 = struct {
	Ri_uuid                          [16]Uint8_t
	Ri_user_time                     Uint64_t
	Ri_system_time                   Uint64_t
	Ri_pkg_idle_wkups                Uint64_t
	Ri_interrupt_wkups               Uint64_t
	Ri_pageins                       Uint64_t
	Ri_wired_size                    Uint64_t
	Ri_resident_size                 Uint64_t
	Ri_phys_footprint                Uint64_t
	Ri_proc_start_abstime            Uint64_t
	Ri_proc_exit_abstime             Uint64_t
	Ri_child_user_time               Uint64_t
	Ri_child_system_time             Uint64_t
	Ri_child_pkg_idle_wkups          Uint64_t
	Ri_child_interrupt_wkups         Uint64_t
	Ri_child_pageins                 Uint64_t
	Ri_child_elapsed_abstime         Uint64_t
	Ri_diskio_bytesread              Uint64_t
	Ri_diskio_byteswritten           Uint64_t
	Ri_cpu_time_qos_default          Uint64_t
	Ri_cpu_time_qos_maintenance      Uint64_t
	Ri_cpu_time_qos_background       Uint64_t
	Ri_cpu_time_qos_utility          Uint64_t
	Ri_cpu_time_qos_legacy           Uint64_t
	Ri_cpu_time_qos_user_initiated   Uint64_t
	Ri_cpu_time_qos_user_interactive Uint64_t
	Ri_billed_system_time            Uint64_t
	Ri_serviced_system_time          Uint64_t
} /* resource.h:257:1 */

type Rusage_info_v4 = struct {
	Ri_uuid                          [16]Uint8_t
	Ri_user_time                     Uint64_t
	Ri_system_time                   Uint64_t
	Ri_pkg_idle_wkups                Uint64_t
	Ri_interrupt_wkups               Uint64_t
	Ri_pageins                       Uint64_t
	Ri_wired_size                    Uint64_t
	Ri_resident_size                 Uint64_t
	Ri_phys_footprint                Uint64_t
	Ri_proc_start_abstime            Uint64_t
	Ri_proc_exit_abstime             Uint64_t
	Ri_child_user_time               Uint64_t
	Ri_child_system_time             Uint64_t
	Ri_child_pkg_idle_wkups          Uint64_t
	Ri_child_interrupt_wkups         Uint64_t
	Ri_child_pageins                 Uint64_t
	Ri_child_elapsed_abstime         Uint64_t
	Ri_diskio_bytesread              Uint64_t
	Ri_diskio_byteswritten           Uint64_t
	Ri_cpu_time_qos_default          Uint64_t
	Ri_cpu_time_qos_maintenance      Uint64_t
	Ri_cpu_time_qos_background       Uint64_t
	Ri_cpu_time_qos_utility          Uint64_t
	Ri_cpu_time_qos_legacy           Uint64_t
	Ri_cpu_time_qos_user_initiated   Uint64_t
	Ri_cpu_time_qos_user_interactive Uint64_t
	Ri_billed_system_time            Uint64_t
	Ri_serviced_system_time          Uint64_t
	Ri_logical_writes                Uint64_t
	Ri_lifetime_max_phys_footprint   Uint64_t
	Ri_instructions                  Uint64_t
	Ri_cycles                        Uint64_t
	Ri_billed_energy                 Uint64_t
	Ri_serviced_energy               Uint64_t
	Ri_interval_max_phys_footprint   Uint64_t
	Ri_runnable_time                 Uint64_t
} /* resource.h:288:1 */

type Rusage_info_v5 = struct {
	Ri_uuid                          [16]Uint8_t
	Ri_user_time                     Uint64_t
	Ri_system_time                   Uint64_t
	Ri_pkg_idle_wkups                Uint64_t
	Ri_interrupt_wkups               Uint64_t
	Ri_pageins                       Uint64_t
	Ri_wired_size                    Uint64_t
	Ri_resident_size                 Uint64_t
	Ri_phys_footprint                Uint64_t
	Ri_proc_start_abstime            Uint64_t
	Ri_proc_exit_abstime             Uint64_t
	Ri_child_user_time               Uint64_t
	Ri_child_system_time             Uint64_t
	Ri_child_pkg_idle_wkups          Uint64_t
	Ri_child_interrupt_wkups         Uint64_t
	Ri_child_pageins                 Uint64_t
	Ri_child_elapsed_abstime         Uint64_t
	Ri_diskio_bytesread              Uint64_t
	Ri_diskio_byteswritten           Uint64_t
	Ri_cpu_time_qos_default          Uint64_t
	Ri_cpu_time_qos_maintenance      Uint64_t
	Ri_cpu_time_qos_background       Uint64_t
	Ri_cpu_time_qos_utility          Uint64_t
	Ri_cpu_time_qos_legacy           Uint64_t
	Ri_cpu_time_qos_user_initiated   Uint64_t
	Ri_cpu_time_qos_user_interactive Uint64_t
	Ri_billed_system_time            Uint64_t
	Ri_serviced_system_time          Uint64_t
	Ri_logical_writes                Uint64_t
	Ri_lifetime_max_phys_footprint   Uint64_t
	Ri_instructions                  Uint64_t
	Ri_cycles                        Uint64_t
	Ri_billed_energy                 Uint64_t
	Ri_serviced_energy               Uint64_t
	Ri_interval_max_phys_footprint   Uint64_t
	Ri_runnable_time                 Uint64_t
	Ri_flags                         Uint64_t
} /* resource.h:327:1 */

type Rusage_info_current = Rusage_info_v5 /* resource.h:367:31 */

// ****
//
// RESOURCE LIMITS

// Symbolic constants for resource limits; since all limits are representable
// as a type rlim_t, we are permitted to define RLIM_SAVED_* in terms of
// RLIM_INFINITY.

// Possible values of the first parameter to getrlimit()/setrlimit(), to
// indicate for which resource the operation is being performed.

// A structure representing a resource limit.  The address of an instance
// of this structure is the second parameter to getrlimit()/setrlimit().
type Rlimit = struct {
	Rlim_cur Rlim_t
	Rlim_max Rlim_t
} /* resource.h:411:1 */

// proc_rlimit_control()
//
// Resource limit flavors

// Flags for wakeups monitor control.

// Flags for CPU usage monitor control.

// Flags for memory footprint interval tracking.

type Proc_rlimit_control_wakeupmon = struct {
	Wm_flags Uint32_t
	Wm_rate  Int32_t
} /* resource.h:446:1 */

// Deprecated:
// Structure of the information in the status word returned by wait4.
// If w_stopval==_WSTOPPED, then the second structure describes
// the information returned, else the first.
type Wait = struct{ W_status int32 } /* wait.h:194:1 */

// built-in for gcc

// built-in for gcc 3

// DO NOT REMOVE THIS COMMENT: fixincludes needs to see:
// _GCC_SIZE_T
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Ct_rune_t = X__darwin_ct_rune_t /* _ct_rune_t.h:32:28 */
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Rune_t = X__darwin_rune_t /* _rune_t.h:31:25 */

type Div_t = struct {
	Quot int32
	Rem  int32
} /* stdlib.h:86:3 */

type Ldiv_t = struct {
	Quot int64
	Rem  int64
} /* stdlib.h:91:3 */

type Lldiv_t = struct {
	Quot int64
	Rem  int64
} /* stdlib.h:97:3 */

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Dev_t = X__darwin_dev_t /* _dev_t.h:31:31 */ // device number
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Mode_t = X__darwin_mode_t /* _mode_t.h:31:33 */

// ISO9899:2011 7.20 (C11 Annex K): Define rsize_t if __STDC_WANT_LIB_EXT1__ is
// enabled.
// Always define rsize_t when modules are available.
type Rsize_t = uint64 /* stddef.h:60:23 */

// Always define wchar_t when modules are available.

// ===---- __stddef_max_align_t.h - Definition of max_align_t for modules ---===
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===-----------------------------------------------------------------------===

type Max_align_t = float64 /* __stddef_max_align_t.h:16:21 */

// C11 Annex K

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Errno_t = int32 /* _errno_t.h:30:32 */

// Darwin extensions

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Ssize_t = X__darwin_ssize_t /* _ssize_t.h:31:33 */

// ==============================================================================
// JSON Types
//============================================================================

//* Type of JSON value (3 bit).
type Yyjson_type = Uint8_t /* yyjson.h:380:17 */

//* Subtype of JSON value (2 bit).
type Yyjson_subtype = Uint8_t /* yyjson.h:390:17 */

//* Mask and bits of JSON value.

//* Padding size for JSON reader.

// ==============================================================================
// Allocator
//============================================================================

//*
//  A memory allocator.
//
//  Typically you don't need to use it, unless you want to customize your own
//  memory allocator.
//
type Yyjson_alc1 = struct {
	Malloc  uintptr
	Realloc uintptr
	Free    uintptr
	Ctx     uintptr
} /* yyjson.h:423:9 */

//* Mask and bits of JSON value.

//* Padding size for JSON reader.

// ==============================================================================
// Allocator
//============================================================================

//*
//  A memory allocator.
//
//  Typically you don't need to use it, unless you want to customize your own
//  memory allocator.
//
type Yyjson_alc = Yyjson_alc1 /* yyjson.h:432:3 */

// ==============================================================================
// JSON Structure
//============================================================================

//* An immutable JSON document.
type Yyjson_doc1 = struct {
	Root     uintptr
	Alc      Yyjson_alc
	Dat_read Size_t
	Val_read Size_t
	Str_pool uintptr
} /* yyjson.h:461:9 */

// ==============================================================================
// JSON Structure
//============================================================================

//* An immutable JSON document.
type Yyjson_doc = Yyjson_doc1 /* yyjson.h:461:27 */

//* An immutable JSON value.
type Yyjson_val1 = struct {
	Tag Uint64_t
	Uni Yyjson_val_uni
} /* yyjson.h:461:9 */

//* An immutable JSON value.
type Yyjson_val = Yyjson_val1 /* yyjson.h:464:27 */

//* A mutable JSON document.
type Yyjson_mut_doc1 = struct {
	Root     uintptr
	Alc      Yyjson_alc
	Str_pool Yyjson_str_pool
	Val_pool Yyjson_val_pool
} /* yyjson.h:467:9 */

//* A mutable JSON document.
type Yyjson_mut_doc = Yyjson_mut_doc1 /* yyjson.h:467:31 */

//* A mutable JSON value.
type Yyjson_mut_val1 = struct {
	Tag  Uint64_t
	Uni  Yyjson_val_uni
	Next uintptr
} /* yyjson.h:467:9 */

//* A mutable JSON value.
type Yyjson_mut_val = Yyjson_mut_val1 /* yyjson.h:470:31 */

// ==============================================================================
// JSON Reader API
//============================================================================

//* Options for JSON reader.
type Yyjson_read_flag = Uint32_t /* yyjson.h:479:18 */

//* Read the input data in-situ.
//     This option allows the reader to modify and use input data to store string
//     values, which can increase reading speed slightly.
//     The caller should hold the input data before free the document.
//     The input data must be padded by at least `YYJSON_PADDING_SIZE` byte.
//     For example: "[1,2]" should be "[1,2]\0\0\0\0", length should be 5.
var sYYJSON_READ_INSITU Yyjson_read_flag = Yyjson_read_flag(int32(1) << 0) /* yyjson.h:497:31 */

//* Stop when done instead of issues an error if there's additional content
//     after a JSON document. This option may used to parse small pieces of JSON
//     in larger data, such as NDJSON.
var sYYJSON_READ_STOP_WHEN_DONE Yyjson_read_flag = Yyjson_read_flag(int32(1) << 1) /* yyjson.h:502:31 */

//* Allow single trailing comma at the end of an object or array,
//     such as [1,2,3,] {"a":1,"b":2,}.
var sYYJSON_READ_ALLOW_TRAILING_COMMAS Yyjson_read_flag = Yyjson_read_flag(int32(1) << 2) /* yyjson.h:506:31 */

//* Allow C-style single line and multiple line comments.
var sYYJSON_READ_ALLOW_COMMENTS Yyjson_read_flag = Yyjson_read_flag(int32(1) << 3) /* yyjson.h:509:31 */

//* Allow inf/nan number and literal, case-insensitive,
//     such as 1e999, NaN, inf, -Infinity.
var sYYJSON_READ_ALLOW_INF_AND_NAN Yyjson_read_flag = Yyjson_read_flag(int32(1) << 4) /* yyjson.h:513:31 */

//* Result code for JSON reader.
type Yyjson_read_code = Uint32_t /* yyjson.h:518:18 */

//* Invalid parameter, such as NULL string or invalid file path.
var sYYJSON_READ_ERROR_INVALID_PARAMETER Yyjson_read_code = Yyjson_read_code(1) /* yyjson.h:524:31 */

//* Memory allocation failure occurs.
var sYYJSON_READ_ERROR_MEMORY_ALLOCATION Yyjson_read_code = Yyjson_read_code(2) /* yyjson.h:527:31 */

//* Input JSON string is empty.
var sYYJSON_READ_ERROR_EMPTY_CONTENT Yyjson_read_code = Yyjson_read_code(3) /* yyjson.h:530:31 */

//* Unexpected content after document, such as "[1]#".
var sYYJSON_READ_ERROR_UNEXPECTED_CONTENT Yyjson_read_code = Yyjson_read_code(4) /* yyjson.h:533:31 */

//* Unexpected ending, such as "[123".
var sYYJSON_READ_ERROR_UNEXPECTED_END Yyjson_read_code = Yyjson_read_code(5) /* yyjson.h:536:31 */

//* Unexpected character inside the document, such as "[#]".
var sYYJSON_READ_ERROR_UNEXPECTED_CHARACTER Yyjson_read_code = Yyjson_read_code(6) /* yyjson.h:539:31 */

//* Invalid JSON structure, such as "[1,]".
var sYYJSON_READ_ERROR_JSON_STRUCTURE Yyjson_read_code = Yyjson_read_code(7) /* yyjson.h:542:31 */

//* Invalid comment, such as unclosed multi-line comment.
var sYYJSON_READ_ERROR_INVALID_COMMENT Yyjson_read_code = Yyjson_read_code(8) /* yyjson.h:545:31 */

//* Invalid number, such as "123.e12", "000".
var sYYJSON_READ_ERROR_INVALID_NUMBER Yyjson_read_code = Yyjson_read_code(9) /* yyjson.h:548:31 */

//* Invalid string, such as invalid escaped character inside a string.
var sYYJSON_READ_ERROR_INVALID_STRING Yyjson_read_code = Yyjson_read_code(10) /* yyjson.h:551:31 */

//* Invalid JSON literal, such as "truu".
var sYYJSON_READ_ERROR_LITERAL Yyjson_read_code = Yyjson_read_code(11) /* yyjson.h:554:31 */

//* Failed to open a file.
var sYYJSON_READ_ERROR_FILE_OPEN Yyjson_read_code = Yyjson_read_code(12) /* yyjson.h:557:31 */

//* Failed to read a file.
var sYYJSON_READ_ERROR_FILE_READ Yyjson_read_code = Yyjson_read_code(13) /* yyjson.h:560:31 */

//* Error information for JSON reader.
type Yyjson_read_err1 = struct {
	Code        Yyjson_read_code
	__ccgo_pad1 [4]byte
	Msg         uintptr
	Pos         Size_t
} /* yyjson.h:563:9 */

//* Error information for JSON reader.
type Yyjson_read_err = Yyjson_read_err1 /* yyjson.h:570:3 */

//*
//  Read a JSON string.
//
//  This function is thread-safe.
//
//  @param dat The JSON string (UTF-8 without BOM).
//             If you pass NULL, you will get NULL result.
//
//  @param len The JSON data's length.
//             If you pass 0, you will get NULL result.
//
//  @param flg The JSON read options.
//             You can combine multiple options using bitwise `|` operator.
//
//  @return    A new JSON document, or NULL if error occurs.
//             You should use yyjson_doc_free() to release it
//             when it's no longer needed.
//
func Yyjson_read(tls *libc.TLS, dat uintptr, len Size_t, flg Yyjson_read_flag) uintptr { /* yyjson.h:655:30: */
	flg = flg & ^sYYJSON_READ_INSITU // const string cannot be modified
	return Yyjson_read_opts(tls, dat, len, flg, uintptr(0), uintptr(0))
}

//*
//  Returns the size of maximum memory usage to read a JSON data.
//  You may use this value to avoid malloc() or calloc() call inside the reader
//  to get better performance, or read multiple JSON.
//
//  Sample code:
//
//      char *dat1, *dat2, *dat3; // JSON data
//      size_t len1, len2, len3; // JSON length
//      size_t max_len = max(len1, len2, len3);
//      yyjson_doc *doc;
//
//      // use one allocator for multiple JSON
//      size_t size = yyjson_read_max_memory_usage(max_len, 0);
//      void *buf = malloc(size);
//      yyjson_alc alc;
//      yyjson_alc_pool_init(&alc, buf, size);
//
//      // no more alloc() or realloc() call during reading
//      doc = yyjson_read_opts(dat1, len1, 0, &alc, NULL);
//      yyjson_doc_free(doc);
//      doc = yyjson_read_opts(dat2, len2, 0, &alc, NULL);
//      yyjson_doc_free(doc);
//      doc = yyjson_read_opts(dat3, len3, 0, &alc, NULL);
//      yyjson_doc_free(doc);
//
//      free(buf);
//
//  @param len The JSON data's length.
//  @param flg The JSON read options.
//  @return The maximum memory size, or 0 if overflow.
//
func Yyjson_read_max_memory_usage(tls *libc.TLS, len Size_t, flg Yyjson_read_flag) Size_t { /* yyjson.h:694:26: */
	//
	//      1. The max value count is (json_size / 2 + 1),
	//         for example: "[1,2,3,4]" size is 9, value count is 5.
	//      2. Some broken JSON may cost more memory during reading, but fail at end,
	//         for example: "[[[[[[[[".
	//      3. yyjson use 16 bytes per value, see struct yyjson_val.
	//      4. yyjson use dynamic memory with a growth factor of 1.5.
	//
	//      The max memory size is (json_size / 2 * 16 * 1.5 + padding).
	//
	var mul Size_t = uint64(12) + libc.BoolUint64(!(flg&sYYJSON_READ_INSITU != 0))
	var pad Size_t = uint64(256)
	var max Size_t = libc.CplUint64(uint64(0))
	if flg&sYYJSON_READ_STOP_WHEN_DONE != 0 {
		if len < uint64(256) {
			len = uint64(256)
		} else {
			len = len
		}
	}
	if len >= (max-pad-mul)/mul {
		return uint64(0)
	}
	return len*mul + pad
}

// ==============================================================================
// JSON Writer API
//============================================================================

//* Options for JSON writer.
type Yyjson_write_flag = Uint32_t /* yyjson.h:721:18 */

//* Write JSON pretty with 4 space indent.
var sYYJSON_WRITE_PRETTY Yyjson_write_flag = Yyjson_write_flag(int32(1) << 0) /* yyjson.h:731:32 */

//* Escape unicode as `uXXXX`, make the output ASCII only.
var sYYJSON_WRITE_ESCAPE_UNICODE Yyjson_write_flag = Yyjson_write_flag(int32(1) << 1) /* yyjson.h:734:32 */

//* Escape '/' as '\/'.
var sYYJSON_WRITE_ESCAPE_SLASHES Yyjson_write_flag = Yyjson_write_flag(int32(1) << 2) /* yyjson.h:737:32 */

//* Write inf and nan number as 'Infinity' and 'NaN' literal (non-standard).
var sYYJSON_WRITE_ALLOW_INF_AND_NAN Yyjson_write_flag = Yyjson_write_flag(int32(1) << 3) /* yyjson.h:740:32 */

//* Write inf and nan number as null literal.
//     This flag will override `YYJSON_WRITE_ALLOW_INF_AND_NAN` flag.
var sYYJSON_WRITE_INF_AND_NAN_AS_NULL Yyjson_write_flag = Yyjson_write_flag(int32(1) << 4) /* yyjson.h:744:32 */

//* Result code for JSON writer
type Yyjson_write_code = Uint32_t /* yyjson.h:749:18 */

//* Success, no error.
var sYYJSON_WRITE_SUCCESS Yyjson_write_code = Yyjson_write_code(0) /* yyjson.h:752:32 */

//* Invalid parameter, such as NULL document.
var sYYJSON_WRITE_ERROR_INVALID_PARAMETER Yyjson_write_code = Yyjson_write_code(1) /* yyjson.h:755:32 */

//* Memory allocation failure occurs.
var sYYJSON_WRITE_ERROR_MEMORY_ALLOCATION Yyjson_write_code = Yyjson_write_code(2) /* yyjson.h:758:32 */

//* Invalid value type in JSON document.
var sYYJSON_WRITE_ERROR_INVALID_VALUE_TYPE Yyjson_write_code = Yyjson_write_code(3) /* yyjson.h:761:32 */

//* NaN or Infinity number occurs.
var sYYJSON_WRITE_ERROR_NAN_OR_INF Yyjson_write_code = Yyjson_write_code(4) /* yyjson.h:764:32 */

//* Failed to open a file.
var sYYJSON_WRITE_ERROR_FILE_OPEN Yyjson_write_code = Yyjson_write_code(5) /* yyjson.h:767:32 */

//* Failed to write a file.
var sYYJSON_WRITE_ERROR_FILE_WRITE Yyjson_write_code = Yyjson_write_code(6) /* yyjson.h:770:32 */

//* Error information for JSON writer.
type Yyjson_write_err1 = struct {
	Code        Yyjson_write_code
	__ccgo_pad1 [4]byte
	Msg         uintptr
} /* yyjson.h:773:9 */

//* Error information for JSON writer.
type Yyjson_write_err = Yyjson_write_err1 /* yyjson.h:778:3 */

//*
//  Write JSON.
//
//  This function is thread-safe.
//
//  @param doc The JSON document.
//             If you pass NULL, you will get NULL result.
//
//  @param flg The JSON write options.
//             You can combine multiple options using bitwise `|` operator.
//
//  @param len A pointer to receive output length in bytes.
//             Pass NULL if you don't need length information.
//
//  @return    A new JSON string, or NULL if error occurs.
//             This string is encoded as UTF-8 with a null-terminator.
//             You should use free() to release it when it's no longer needed.
//
func Yyjson_write(tls *libc.TLS, doc uintptr, flg Yyjson_write_flag, len uintptr) uintptr { /* yyjson.h:863:24: */
	return Yyjson_write_opts(tls, doc, flg, uintptr(0), len, uintptr(0))
}

//*
//  Write JSON.
//
//  This function is thread-safe if you make sure that:
//  1. The `doc` is not is not modified by other threads.
//
//  @param doc The JSON document.
//             If you pass NULL, you will get NULL result.
//
//  @param flg The JSON write options.
//             You can combine multiple options using bitwise `|` operator.
//
//  @param len A pointer to receive output length in bytes.
//             Pass NULL if you don't need length information.
//
//  @return    A new JSON string, or NULL if error occurs.
//             This string is encoded as UTF-8 with a null-terminator.
//             You should use free() or alc->free() to release it
//             when it's no longer needed.
//
func Yyjson_mut_write(tls *libc.TLS, doc uintptr, flg Yyjson_write_flag, len uintptr) uintptr { /* yyjson.h:956:24: */
	return Yyjson_mut_write_opts(tls, doc, flg, uintptr(0), len, uintptr(0))
}

// ==============================================================================
// JSON Array Iterator API
//============================================================================

//*
//  A JSON array iterator.
//
//  Sample code:
//
//      yyjson_val *val;
//      yyjson_arr_iter iter;
//      yyjson_arr_iter_init(arr, &iter);
//      while ((val = yyjson_arr_iter_next(&iter))) {
//          print(val);
//      }
//
type Yyjson_arr_iter1 = struct {
	Idx Size_t
	Max Size_t
	Cur uintptr
} /* yyjson.h:1112:9 */

// ==============================================================================
// JSON Array Iterator API
//============================================================================

//*
//  A JSON array iterator.
//
//  Sample code:
//
//      yyjson_val *val;
//      yyjson_arr_iter iter;
//      yyjson_arr_iter_init(arr, &iter);
//      while ((val = yyjson_arr_iter_next(&iter))) {
//          print(val);
//      }
//
type Yyjson_arr_iter = Yyjson_arr_iter1 /* yyjson.h:1112:32 */

// ==============================================================================
// JSON Object Iterator API
//============================================================================

//*
//  A JSON object iterator.
//
//  Sample code:
//
//      yyjson_val *key, *val;
//      yyjson_obj_iter iter;
//      yyjson_obj_iter_init(obj, &iter);
//      while ((key = yyjson_obj_iter_next(&iter))) {
//          val = yyjson_obj_iter_get_val(key);
//          print(key, val);
//      }
//
type Yyjson_obj_iter1 = struct {
	Idx Size_t
	Max Size_t
	Cur uintptr
	Obj uintptr
} /* yyjson.h:1182:9 */

// ==============================================================================
// JSON Object Iterator API
//============================================================================

//*
//  A JSON object iterator.
//
//  Sample code:
//
//      yyjson_val *key, *val;
//      yyjson_obj_iter iter;
//      yyjson_obj_iter_init(obj, &iter);
//      while ((key = yyjson_obj_iter_next(&iter))) {
//          val = yyjson_obj_iter_get_val(key);
//          print(key, val);
//      }
//
type Yyjson_obj_iter = Yyjson_obj_iter1 /* yyjson.h:1182:32 */

// ==============================================================================
// Mutable JSON Array Iterator API
//============================================================================

//*
//  A mutable JSON array iterator.
//
//  Sample code:
//
//      yyjson_mut_val *val;
//      yyjson_mut_arr_iter iter;
//      yyjson_mut_arr_iter_init(arr, &iter);
//      while ((val = yyjson_mut_arr_iter_next(&iter))) {
//          print(val);
//          if (val_is_unused(val)) {
//              yyjson_mut_arr_iter_remove(&iter);
//          }
//      }
//
//  @warning You should not modify the array while enumerating through it,
//           but you can use yyjson_mut_arr_iter_remove() to remove current value.
//
type Yyjson_mut_arr_iter1 = struct {
	Idx Size_t
	Max Size_t
	Cur uintptr
	Pre uintptr
	Arr uintptr
} /* yyjson.h:1490:9 */

// ==============================================================================
// Mutable JSON Array Iterator API
//============================================================================

//*
//  A mutable JSON array iterator.
//
//  Sample code:
//
//      yyjson_mut_val *val;
//      yyjson_mut_arr_iter iter;
//      yyjson_mut_arr_iter_init(arr, &iter);
//      while ((val = yyjson_mut_arr_iter_next(&iter))) {
//          print(val);
//          if (val_is_unused(val)) {
//              yyjson_mut_arr_iter_remove(&iter);
//          }
//      }
//
//  @warning You should not modify the array while enumerating through it,
//           but you can use yyjson_mut_arr_iter_remove() to remove current value.
//
type Yyjson_mut_arr_iter = Yyjson_mut_arr_iter1 /* yyjson.h:1490:36 */

// ==============================================================================
// Mutable JSON Object Iterator API
//============================================================================

//*
//  A mutable JSON object iterator.
//
//  Sample code:
//
//      yyjson_mut_val *key, *val;
//      yyjson_mut_obj_iter iter;
//      yyjson_mut_obj_iter_init(obj, &iter);
//      while ((key = yyjson_mut_obj_iter_next(&iter))) {
//          val = yyjson_mut_obj_iter_get_val(key);
//          print(key, val);
//          if (key_is_unused(key)) {
//              yyjson_mut_obj_iter_remove(&iter);
//          }
//      }
//
//  @warning You should not modify the object while enumerating through it,
//           but you can use yyjson_mut_obj_iter_remove() to remove current value.
//
type Yyjson_mut_obj_iter1 = struct {
	Idx Size_t
	Max Size_t
	Cur uintptr
	Pre uintptr
	Obj uintptr
} /* yyjson.h:1794:9 */

// ==============================================================================
// Mutable JSON Object Iterator API
//============================================================================

//*
//  A mutable JSON object iterator.
//
//  Sample code:
//
//      yyjson_mut_val *key, *val;
//      yyjson_mut_obj_iter iter;
//      yyjson_mut_obj_iter_init(obj, &iter);
//      while ((key = yyjson_mut_obj_iter_next(&iter))) {
//          val = yyjson_mut_obj_iter_get_val(key);
//          print(key, val);
//          if (key_is_unused(key)) {
//              yyjson_mut_obj_iter_remove(&iter);
//          }
//      }
//
//  @warning You should not modify the object while enumerating through it,
//           but you can use yyjson_mut_obj_iter_remove() to remove current value.
//
type Yyjson_mut_obj_iter = Yyjson_mut_obj_iter1 /* yyjson.h:1794:36 */

// ==============================================================================
// JSON Structure (Implementation)
//============================================================================

// Payload of a JSON value (8 bytes).
type Yyjson_val_uni1 = struct{ U64 Uint64_t } /* yyjson.h:461:9 */

// ==============================================================================
// JSON Structure (Implementation)
//============================================================================

// Payload of a JSON value (8 bytes).
type Yyjson_val_uni = Yyjson_val_uni1 /* yyjson.h:2085:3 */

// ==============================================================================
// Unsafe JSON Value API (Implementation)
//============================================================================

func Unsafe_yyjson_get_type(tls *libc.TLS, val uintptr) Yyjson_type { /* yyjson.h:2113:31: */
	var tag Uint8_t = Uint8_t((*Yyjson_val)(unsafe.Pointer(val)).Tag)
	return Yyjson_type(int32(tag) & int32(Uint8_t(0x07)))
}

func Unsafe_yyjson_get_subtype(tls *libc.TLS, val uintptr) Yyjson_subtype { /* yyjson.h:2118:34: */
	var tag Uint8_t = Uint8_t((*Yyjson_val)(unsafe.Pointer(val)).Tag)
	return Yyjson_subtype(int32(tag) & int32(Uint8_t(0x18)))
}

func Unsafe_yyjson_get_tag(tls *libc.TLS, val uintptr) Uint8_t { /* yyjson.h:2123:27: */
	var tag Uint8_t = Uint8_t((*Yyjson_val)(unsafe.Pointer(val)).Tag)
	return Uint8_t(int32(tag) & int32(Uint8_t(0xFF)))
}

func Unsafe_yyjson_is_null(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2128:24: */
	return uint8(libc.Bool32(int32(Unsafe_yyjson_get_type(tls, val)) == int32(Uint8_t(2))))
}

func Unsafe_yyjson_is_bool(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2132:24: */
	return uint8(libc.Bool32(int32(Unsafe_yyjson_get_type(tls, val)) == int32(Uint8_t(3))))
}

func Unsafe_yyjson_is_num(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2136:24: */
	return uint8(libc.Bool32(int32(Unsafe_yyjson_get_type(tls, val)) == int32(Uint8_t(4))))
}

func Unsafe_yyjson_is_str(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2140:24: */
	return uint8(libc.Bool32(int32(Unsafe_yyjson_get_type(tls, val)) == int32(Uint8_t(5))))
}

func Unsafe_yyjson_is_arr(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2144:24: */
	return uint8(libc.Bool32(int32(Unsafe_yyjson_get_type(tls, val)) == int32(Uint8_t(6))))
}

func Unsafe_yyjson_is_obj(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2148:24: */
	return uint8(libc.Bool32(int32(Unsafe_yyjson_get_type(tls, val)) == int32(Uint8_t(7))))
}

func Unsafe_yyjson_is_ctn(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2152:24: */
	var mask Uint8_t = Uint8_t(int32(Uint8_t(6)) & int32(Uint8_t(7)))
	return uint8(libc.Bool32(int32(Unsafe_yyjson_get_tag(tls, val))&int32(mask) == int32(mask)))
}

func Unsafe_yyjson_is_uint(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2157:24: */
	var patt Uint8_t = Uint8_t(int32(Uint8_t(4)) | int32(Uint8_t(int32(0)<<3)))
	return uint8(libc.Bool32(int32(Unsafe_yyjson_get_tag(tls, val)) == int32(patt)))
}

func Unsafe_yyjson_is_sint(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2162:24: */
	var patt Uint8_t = Uint8_t(int32(Uint8_t(4)) | int32(Uint8_t(int32(1)<<3)))
	return uint8(libc.Bool32(int32(Unsafe_yyjson_get_tag(tls, val)) == int32(patt)))
}

func Unsafe_yyjson_is_int(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2167:24: */
	var mask Uint8_t = Uint8_t(int32(Uint8_t(0xFF)) & libc.CplInt32(int32(Uint8_t(int32(1)<<3))))
	var patt Uint8_t = Uint8_t(int32(Uint8_t(4)) | int32(Uint8_t(int32(0)<<3)))
	return uint8(libc.Bool32(int32(Unsafe_yyjson_get_tag(tls, val))&int32(mask) == int32(patt)))
}

func Unsafe_yyjson_is_real(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2173:24: */
	var patt Uint8_t = Uint8_t(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
	return uint8(libc.Bool32(int32(Unsafe_yyjson_get_tag(tls, val)) == int32(patt)))
}

func Unsafe_yyjson_is_true(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2178:24: */
	var patt Uint8_t = Uint8_t(int32(Uint8_t(3)) | int32(Uint8_t(int32(1)<<3)))
	return uint8(libc.Bool32(int32(Unsafe_yyjson_get_tag(tls, val)) == int32(patt)))
}

func Unsafe_yyjson_is_false(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2183:24: */
	var patt Uint8_t = Uint8_t(int32(Uint8_t(3)) | int32(Uint8_t(int32(0)<<3)))
	return uint8(libc.Bool32(int32(Unsafe_yyjson_get_tag(tls, val)) == int32(patt)))
}

func Unsafe_yyjson_arr_is_flat(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2188:24: */
	var ofs Size_t = *(*Size_t)(unsafe.Pointer(val + 8))
	var len Size_t = Size_t((*Yyjson_val)(unsafe.Pointer(val)).Tag >> int32(Uint8_t(8)))
	return uint8(libc.Bool32(len*Size_t(unsafe.Sizeof(Yyjson_val{}))+Size_t(unsafe.Sizeof(Yyjson_val{})) == ofs))
}

func Unsafe_yyjson_get_bool(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2194:24: */
	var tag Uint8_t = Unsafe_yyjson_get_tag(tls, val)
	return uint8(int32(tag) & int32(Uint8_t(0x18)) >> int32(Uint8_t(3)))
}

func Unsafe_yyjson_get_uint(tls *libc.TLS, val uintptr) Uint64_t { /* yyjson.h:2199:28: */
	return *(*Uint64_t)(unsafe.Pointer(val + 8))
}

func Unsafe_yyjson_get_sint(tls *libc.TLS, val uintptr) Int64_t { /* yyjson.h:2203:27: */
	return *(*Int64_t)(unsafe.Pointer(val + 8))
}

func Unsafe_yyjson_get_int(tls *libc.TLS, val uintptr) int32 { /* yyjson.h:2207:23: */
	return int32(*(*Int64_t)(unsafe.Pointer(val + 8)))
}

func Unsafe_yyjson_get_real(tls *libc.TLS, val uintptr) float64 { /* yyjson.h:2211:26: */
	return *(*float64)(unsafe.Pointer(val + 8))
}

func Unsafe_yyjson_get_str(tls *libc.TLS, val uintptr) uintptr { /* yyjson.h:2215:30: */
	return *(*uintptr)(unsafe.Pointer(val + 8))
}

func Unsafe_yyjson_get_len(tls *libc.TLS, val uintptr) Size_t { /* yyjson.h:2219:26: */
	return Size_t((*Yyjson_val)(unsafe.Pointer(val)).Tag >> int32(Uint8_t(8)))
}

func Unsafe_yyjson_set_len(tls *libc.TLS, val uintptr, len Size_t) { /* yyjson.h:2223:24: */
	var tag Uint64_t = (*Yyjson_val)(unsafe.Pointer(val)).Tag & Uint64_t(Uint8_t(0xFF))
	tag = tag | Uint64_t(len)<<int32(Uint8_t(8))
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = tag
}

func Unsafe_yyjson_get_first(tls *libc.TLS, ctn uintptr) uintptr { /* yyjson.h:2229:30: */
	return ctn + uintptr(1)*16
}

func Unsafe_yyjson_get_next(tls *libc.TLS, val uintptr) uintptr { /* yyjson.h:2233:30: */
	var is_ctn uint8 = Unsafe_yyjson_is_ctn(tls, val)
	var ctn_ofs Size_t = *(*Size_t)(unsafe.Pointer(val + 8))
	var ofs Size_t = func() uint64 {
		if is_ctn != 0 {
			return ctn_ofs
		}
		return uint64(unsafe.Sizeof(Yyjson_val{}))
	}()
	return val + uintptr(ofs)
}

func Unsafe_yyjson_equals_strn(tls *libc.TLS, val uintptr, str uintptr, len Size_t) uint8 { /* yyjson.h:2240:24: */
	var tag Uint64_t = Uint64_t(len)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
	return uint8(libc.Bool32((*Yyjson_val)(unsafe.Pointer(val)).Tag == tag && libc.Xmemcmp(tls, *(*uintptr)(unsafe.Pointer(val + 8)), str, len) == 0))
}

func Unsafe_yyjson_equals_str(tls *libc.TLS, val uintptr, str uintptr) uint8 { /* yyjson.h:2247:24: */
	return Unsafe_yyjson_equals_strn(tls, val, str, libc.Xstrlen(tls, str))
}

// ==============================================================================
// JSON Document API (Implementation)
//============================================================================

func Yyjson_doc_get_root(tls *libc.TLS, doc uintptr) uintptr { /* yyjson.h:2257:30: */
	if doc != 0 {
		return (*Yyjson_doc)(unsafe.Pointer(doc)).Root
	}
	return uintptr(0)
}

func Yyjson_doc_get_read_size(tls *libc.TLS, doc uintptr) Size_t { /* yyjson.h:2261:26: */
	if doc != 0 {
		return (*Yyjson_doc)(unsafe.Pointer(doc)).Dat_read
	}
	return uint64(0)
}

func Yyjson_doc_get_val_count(tls *libc.TLS, doc uintptr) Size_t { /* yyjson.h:2265:26: */
	if doc != 0 {
		return (*Yyjson_doc)(unsafe.Pointer(doc)).Val_read
	}
	return uint64(0)
}

func Yyjson_doc_free(tls *libc.TLS, doc uintptr) { /* yyjson.h:2269:24: */
	if doc != 0 {
		var alc = (*Yyjson_doc)(unsafe.Pointer(doc)).Alc
		if (*Yyjson_doc)(unsafe.Pointer(doc)).Str_pool != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, (*Yyjson_doc)(unsafe.Pointer(doc)).Str_pool)
		}
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, doc)
	}
}

// ==============================================================================
// JSON Value Type API (Implementation)
//============================================================================

func Yyjson_is_null(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2283:24: */
	if val != 0 {
		return Unsafe_yyjson_is_null(tls, val)
	}
	return uint8(False)
}

func Yyjson_is_true(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2287:24: */
	if val != 0 {
		return Unsafe_yyjson_is_true(tls, val)
	}
	return uint8(False)
}

func Yyjson_is_false(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2291:24: */
	if val != 0 {
		return Unsafe_yyjson_is_false(tls, val)
	}
	return uint8(False)
}

func Yyjson_is_bool(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2295:24: */
	if val != 0 {
		return Unsafe_yyjson_is_bool(tls, val)
	}
	return uint8(False)
}

func Yyjson_is_uint(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2299:24: */
	if val != 0 {
		return Unsafe_yyjson_is_uint(tls, val)
	}
	return uint8(False)
}

func Yyjson_is_sint(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2303:24: */
	if val != 0 {
		return Unsafe_yyjson_is_sint(tls, val)
	}
	return uint8(False)
}

func Yyjson_is_int(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2307:24: */
	if val != 0 {
		return Unsafe_yyjson_is_int(tls, val)
	}
	return uint8(False)
}

func Yyjson_is_real(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2311:24: */
	if val != 0 {
		return Unsafe_yyjson_is_real(tls, val)
	}
	return uint8(False)
}

func Yyjson_is_num(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2315:24: */
	if val != 0 {
		return Unsafe_yyjson_is_num(tls, val)
	}
	return uint8(False)
}

func Yyjson_is_str(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2319:24: */
	if val != 0 {
		return Unsafe_yyjson_is_str(tls, val)
	}
	return uint8(False)
}

func Yyjson_is_arr(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2323:24: */
	if val != 0 {
		return Unsafe_yyjson_is_arr(tls, val)
	}
	return uint8(False)
}

func Yyjson_is_obj(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2327:24: */
	if val != 0 {
		return Unsafe_yyjson_is_obj(tls, val)
	}
	return uint8(False)
}

func Yyjson_is_ctn(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2331:24: */
	if val != 0 {
		return Unsafe_yyjson_is_ctn(tls, val)
	}
	return uint8(False)
}

// ==============================================================================
// JSON Value Content API (Implementation)
//============================================================================

func Yyjson_get_type(tls *libc.TLS, val uintptr) Yyjson_type { /* yyjson.h:2341:31: */
	if val != 0 {
		return Unsafe_yyjson_get_type(tls, val)
	}
	return Uint8_t(0)
}

func Yyjson_get_subtype(tls *libc.TLS, val uintptr) Yyjson_subtype { /* yyjson.h:2345:34: */
	if val != 0 {
		return Unsafe_yyjson_get_subtype(tls, val)
	}
	return Uint8_t(int32(0) << 3)
}

func Yyjson_get_tag(tls *libc.TLS, val uintptr) Uint8_t { /* yyjson.h:2349:27: */
	if val != 0 {
		return Unsafe_yyjson_get_tag(tls, val)
	}
	return uint8(0)
}

func Yyjson_get_type_desc(tls *libc.TLS, val uintptr) uintptr { /* yyjson.h:2353:30: */
	switch int32(Yyjson_get_tag(tls, val)) {
	case int32(Uint8_t(2)) | int32(Uint8_t(int32(0)<<3)):
		return ts /* "null" */
	case int32(Uint8_t(5)) | int32(Uint8_t(int32(0)<<3)):
		return ts + 5 /* "string" */
	case int32(Uint8_t(6)) | int32(Uint8_t(int32(0)<<3)):
		return ts + 12 /* "array" */
	case int32(Uint8_t(7)) | int32(Uint8_t(int32(0)<<3)):
		return ts + 18 /* "object" */
	case int32(Uint8_t(3)) | int32(Uint8_t(int32(1)<<3)):
		return ts + 25 /* "true" */
	case int32(Uint8_t(3)) | int32(Uint8_t(int32(0)<<3)):
		return ts + 30 /* "false" */
	case int32(Uint8_t(4)) | int32(Uint8_t(int32(0)<<3)):
		return ts + 36 /* "uint" */
	case int32(Uint8_t(4)) | int32(Uint8_t(int32(1)<<3)):
		return ts + 41 /* "sint" */
	case int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)):
		return ts + 46 /* "real" */
	default:
		return ts + 51 /* "unknown" */
	}
	return uintptr(0)
}

func Yyjson_get_bool(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2368:24: */
	if Yyjson_is_bool(tls, val) != 0 {
		return Unsafe_yyjson_get_bool(tls, val)
	}
	return uint8(False)
}

func Yyjson_get_uint(tls *libc.TLS, val uintptr) Uint64_t { /* yyjson.h:2372:28: */
	if Yyjson_is_int(tls, val) != 0 {
		return Unsafe_yyjson_get_uint(tls, val)
	}
	return uint64(0)
}

func Yyjson_get_sint(tls *libc.TLS, val uintptr) Int64_t { /* yyjson.h:2376:27: */
	if Yyjson_is_int(tls, val) != 0 {
		return Unsafe_yyjson_get_sint(tls, val)
	}
	return int64(0)
}

func Yyjson_get_int(tls *libc.TLS, val uintptr) int32 { /* yyjson.h:2380:23: */
	if Yyjson_is_int(tls, val) != 0 {
		return Unsafe_yyjson_get_int(tls, val)
	}
	return 0
}

func Yyjson_get_real(tls *libc.TLS, val uintptr) float64 { /* yyjson.h:2384:26: */
	if Yyjson_is_real(tls, val) != 0 {
		return Unsafe_yyjson_get_real(tls, val)
	}
	return 0.0
}

func Yyjson_get_str(tls *libc.TLS, val uintptr) uintptr { /* yyjson.h:2388:30: */
	if Yyjson_is_str(tls, val) != 0 {
		return Unsafe_yyjson_get_str(tls, val)
	}
	return uintptr(0)
}

func Yyjson_get_len(tls *libc.TLS, val uintptr) Size_t { /* yyjson.h:2392:26: */
	if Yyjson_is_str(tls, val) != 0 {
		return Unsafe_yyjson_get_len(tls, val)
	}
	return uint64(0)
}

func Yyjson_equals_str(tls *libc.TLS, val uintptr, str uintptr) uint8 { /* yyjson.h:2396:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(val != 0 && str != 0)), int64(1)) != 0 {
		return Unsafe_yyjson_equals_str(tls, val, str)
	}
	return uint8(False)
}

func Yyjson_equals_strn(tls *libc.TLS, val uintptr, str uintptr, len Size_t) uint8 { /* yyjson.h:2403:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(val != 0 && str != 0)), int64(1)) != 0 {
		return Unsafe_yyjson_equals_strn(tls, val, str, len)
	}
	return uint8(False)
}

// ==============================================================================
// JSON Array API (Implementation)
//============================================================================

func Yyjson_arr_size(tls *libc.TLS, arr uintptr) Size_t { /* yyjson.h:2417:26: */
	if Yyjson_is_arr(tls, arr) != 0 {
		return Unsafe_yyjson_get_len(tls, arr)
	}
	return uint64(0)
}

func Yyjson_arr_get(tls *libc.TLS, arr uintptr, idx Size_t) uintptr { /* yyjson.h:2421:30: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Unsafe_yyjson_get_len(tls, arr) > idx)), int64(1)) != 0 {
			var val uintptr = Unsafe_yyjson_get_first(tls, arr)
			if Unsafe_yyjson_arr_is_flat(tls, arr) != 0 {
				return val + uintptr(idx)*16
			} else {
				for libc.PostDecUint64(&idx, 1) > uint64(0) {
					val = Unsafe_yyjson_get_next(tls, val)
				}
				return val
			}
		}
	}
	return uintptr(0)
}

func Yyjson_arr_get_first(tls *libc.TLS, arr uintptr) uintptr { /* yyjson.h:2436:30: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Unsafe_yyjson_get_len(tls, arr) > uint64(0))), int64(1)) != 0 {
			return Unsafe_yyjson_get_first(tls, arr)
		}
	}
	return uintptr(0)
}

func Yyjson_arr_get_last(tls *libc.TLS, arr uintptr) uintptr { /* yyjson.h:2445:30: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var len Size_t = Unsafe_yyjson_get_len(tls, arr)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(len > uint64(0))), int64(1)) != 0 {
			var val uintptr = Unsafe_yyjson_get_first(tls, arr)
			if Unsafe_yyjson_arr_is_flat(tls, arr) != 0 {
				return val + uintptr(len-uint64(1))*16
			} else {
				for libc.PostDecUint64(&len, 1) > uint64(1) {
					val = Unsafe_yyjson_get_next(tls, val)
				}
				return val
			}
		}
	}
	return uintptr(0)
}

func Yyjson_arr_iter_init(tls *libc.TLS, arr uintptr, iter uintptr) uint8 { /* yyjson.h:2473:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_is_arr(tls, arr) != 0 && iter != 0)), int64(1)) != 0 {
		(*Yyjson_arr_iter)(unsafe.Pointer(iter)).Idx = uint64(0)
		(*Yyjson_arr_iter)(unsafe.Pointer(iter)).Max = Unsafe_yyjson_get_len(tls, arr)
		(*Yyjson_arr_iter)(unsafe.Pointer(iter)).Cur = Unsafe_yyjson_get_first(tls, arr)
		return uint8(True)
	}
	if iter != 0 {
		libc.X__builtin___memset_chk(tls, iter, 0, uint64(unsafe.Sizeof(Yyjson_arr_iter{})), libc.X__builtin_object_size(tls, iter, 0))
	}
	return uint8(False)
}

func Yyjson_arr_iter_has_next(tls *libc.TLS, iter uintptr) uint8 { /* yyjson.h:2485:24: */
	if iter != 0 {
		return uint8(libc.Bool32((*Yyjson_arr_iter)(unsafe.Pointer(iter)).Idx < (*Yyjson_arr_iter)(unsafe.Pointer(iter)).Max))
	}
	return uint8(False)
}

func Yyjson_arr_iter_next(tls *libc.TLS, iter uintptr) uintptr { /* yyjson.h:2489:30: */
	var val uintptr
	if iter != 0 && (*Yyjson_arr_iter)(unsafe.Pointer(iter)).Idx < (*Yyjson_arr_iter)(unsafe.Pointer(iter)).Max {
		val = (*Yyjson_arr_iter)(unsafe.Pointer(iter)).Cur
		(*Yyjson_arr_iter)(unsafe.Pointer(iter)).Cur = Unsafe_yyjson_get_next(tls, val)
		(*Yyjson_arr_iter)(unsafe.Pointer(iter)).Idx++
		return val
	}
	return uintptr(0)
}

// ==============================================================================
// JSON Object API (Implementation)
//============================================================================

func Yyjson_obj_size(tls *libc.TLS, obj uintptr) Size_t { /* yyjson.h:2506:26: */
	if Yyjson_is_obj(tls, obj) != 0 {
		return Unsafe_yyjson_get_len(tls, obj)
	}
	return uint64(0)
}

func Yyjson_obj_get(tls *libc.TLS, obj uintptr, key_str uintptr) uintptr { /* yyjson.h:2510:30: */
	return Yyjson_obj_getn(tls, obj, key_str, func() uint64 {
		if key_str != 0 {
			return libc.Xstrlen(tls, key_str)
		}
		return uint64(0)
	}())
}

func Yyjson_obj_getn(tls *libc.TLS, obj uintptr, key_str uintptr, key_len Size_t) uintptr { /* yyjson.h:2515:30: */
	var tag Uint64_t = Uint64_t(key_len)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_is_obj(tls, obj) != 0 && key_str != 0)), int64(1)) != 0 {
		var len Size_t = Unsafe_yyjson_get_len(tls, obj)
		var key uintptr = Unsafe_yyjson_get_first(tls, obj)
		for libc.PostDecUint64(&len, 1) > uint64(0) {
			if (*Yyjson_val)(unsafe.Pointer(key)).Tag == tag && libc.Xmemcmp(tls, *(*uintptr)(unsafe.Pointer(key + 8)), key_str, key_len) == 0 {
				return key + uintptr(1)*16
			}
			key = Unsafe_yyjson_get_next(tls, key+uintptr(1)*16)
		}
	}
	return uintptr(0)
}

func Yyjson_obj_iter_init(tls *libc.TLS, obj uintptr, iter uintptr) uint8 { /* yyjson.h:2546:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_is_obj(tls, obj) != 0 && iter != 0)), int64(1)) != 0 {
		(*Yyjson_obj_iter)(unsafe.Pointer(iter)).Idx = uint64(0)
		(*Yyjson_obj_iter)(unsafe.Pointer(iter)).Max = Unsafe_yyjson_get_len(tls, obj)
		(*Yyjson_obj_iter)(unsafe.Pointer(iter)).Cur = Unsafe_yyjson_get_first(tls, obj)
		(*Yyjson_obj_iter)(unsafe.Pointer(iter)).Obj = obj
		return uint8(True)
	}
	if iter != 0 {
		(*Yyjson_obj_iter)(unsafe.Pointer(iter)).Idx = uint64(0)
		(*Yyjson_obj_iter)(unsafe.Pointer(iter)).Max = uint64(0)
	}
	return uint8(False)
}

func Yyjson_obj_iter_has_next(tls *libc.TLS, iter uintptr) uint8 { /* yyjson.h:2562:24: */
	if iter != 0 {
		return uint8(libc.Bool32((*Yyjson_obj_iter)(unsafe.Pointer(iter)).Idx < (*Yyjson_obj_iter)(unsafe.Pointer(iter)).Max))
	}
	return uint8(False)
}

func Yyjson_obj_iter_next(tls *libc.TLS, iter uintptr) uintptr { /* yyjson.h:2566:30: */
	if iter != 0 && (*Yyjson_obj_iter)(unsafe.Pointer(iter)).Idx < (*Yyjson_obj_iter)(unsafe.Pointer(iter)).Max {
		var key uintptr = (*Yyjson_obj_iter)(unsafe.Pointer(iter)).Cur
		(*Yyjson_obj_iter)(unsafe.Pointer(iter)).Idx++
		(*Yyjson_obj_iter)(unsafe.Pointer(iter)).Cur = Unsafe_yyjson_get_next(tls, key+uintptr(1)*16)
		return key
	}
	return uintptr(0)
}

func Yyjson_obj_iter_get_val(tls *libc.TLS, key uintptr) uintptr { /* yyjson.h:2576:30: */
	return key + uintptr(1)*16
}

func Yyjson_obj_iter_get(tls *libc.TLS, iter uintptr, key uintptr) uintptr { /* yyjson.h:2580:30: */
	return Yyjson_obj_iter_getn(tls, iter, key, func() uint64 {
		if key != 0 {
			return libc.Xstrlen(tls, key)
		}
		return uint64(0)
	}())
}

func Yyjson_obj_iter_getn(tls *libc.TLS, iter uintptr, key uintptr, key_len Size_t) uintptr { /* yyjson.h:2585:30: */
	if iter != 0 && key != 0 {
		var idx Size_t = (*Yyjson_obj_iter)(unsafe.Pointer(iter)).Idx
		var max Size_t = (*Yyjson_obj_iter)(unsafe.Pointer(iter)).Max
		var cur uintptr = (*Yyjson_obj_iter)(unsafe.Pointer(iter)).Cur
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(idx == max)), int64(0)) != 0 {
			idx = uint64(0)
			cur = Unsafe_yyjson_get_first(tls, (*Yyjson_obj_iter)(unsafe.Pointer(iter)).Obj)
		}
		for libc.PostIncUint64(&idx, 1) < max {
			var next uintptr = Unsafe_yyjson_get_next(tls, cur+uintptr(1)*16)
			if Unsafe_yyjson_get_len(tls, cur) == key_len && libc.Xmemcmp(tls, *(*uintptr)(unsafe.Pointer(cur + 8)), key, key_len) == 0 {
				(*Yyjson_obj_iter)(unsafe.Pointer(iter)).Idx = idx
				(*Yyjson_obj_iter)(unsafe.Pointer(iter)).Cur = next
				return cur + uintptr(1)*16
			}
			cur = next
			if idx == (*Yyjson_obj_iter)(unsafe.Pointer(iter)).Max && (*Yyjson_obj_iter)(unsafe.Pointer(iter)).Idx < (*Yyjson_obj_iter)(unsafe.Pointer(iter)).Max {
				idx = uint64(0)
				max = (*Yyjson_obj_iter)(unsafe.Pointer(iter)).Idx
				cur = Unsafe_yyjson_get_first(tls, (*Yyjson_obj_iter)(unsafe.Pointer(iter)).Obj)
			}
		}
	}
	return uintptr(0)
}

type Yyjson_str_chunk1 = struct{ Next uintptr } /* yyjson.h:467:9 */

type Yyjson_str_chunk = Yyjson_str_chunk1 /* yyjson.h:2635:3 */

type Yyjson_str_pool1 = struct {
	Cur            uintptr
	End            uintptr
	Chunk_size     Size_t
	Chunk_size_max Size_t
	Chunks         uintptr
} /* yyjson.h:467:9 */

type Yyjson_str_pool = Yyjson_str_pool1 /* yyjson.h:2643:3 */

type Yyjson_val_chunk1 = struct{ Next uintptr } /* yyjson.h:467:9 */

type Yyjson_val_chunk = Yyjson_val_chunk1 /* yyjson.h:2648:3 */

type Yyjson_val_pool1 = struct {
	Cur            uintptr
	End            uintptr
	Chunk_size     Size_t
	Chunk_size_max Size_t
	Chunks         uintptr
} /* yyjson.h:467:9 */

type Yyjson_val_pool = Yyjson_val_pool1 /* yyjson.h:2656:3 */

func Unsafe_yyjson_mut_strncpy(tls *libc.TLS, doc uintptr, str uintptr, len Size_t) uintptr { /* yyjson.h:2673:24: */
	var mem uintptr
	var alc uintptr = doc + 8
	var pool uintptr = doc + 40

	if !(str != 0) {
		return uintptr(0)
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Size_t((int64((*Yyjson_str_pool)(unsafe.Pointer(pool)).End)-int64((*Yyjson_str_pool)(unsafe.Pointer(pool)).Cur))/1) <= len)), int64(0)) != 0 {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Unsafe_yyjson_str_pool_grow(tls, pool, alc, len+uint64(1)) != 0)), int64(0)) != 0 {
			return uintptr(0)
		}
	}

	mem = (*Yyjson_str_pool)(unsafe.Pointer(pool)).Cur
	(*Yyjson_str_pool)(unsafe.Pointer(pool)).Cur = mem + uintptr(len) + uintptr(1)
	libc.X__builtin___memcpy_chk(tls, mem, str, len, libc.X__builtin_object_size(tls, mem, 0))
	*(*int8)(unsafe.Pointer(mem + uintptr(len))) = int8(0)
	return mem
}

func Unsafe_yyjson_mut_val(tls *libc.TLS, doc uintptr, count Size_t) uintptr { /* yyjson.h:2693:34: */
	var val uintptr
	var alc uintptr = doc + 8
	var pool uintptr = doc + 80
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Size_t((int64((*Yyjson_val_pool)(unsafe.Pointer(pool)).End)-int64((*Yyjson_val_pool)(unsafe.Pointer(pool)).Cur))/24) < count)), int64(0)) != 0 {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Unsafe_yyjson_val_pool_grow(tls, pool, alc, count) != 0)), int64(0)) != 0 {
			return uintptr(0)
		}
	}

	val = (*Yyjson_val_pool)(unsafe.Pointer(pool)).Cur
	*(*uintptr)(unsafe.Pointer(pool)) += uintptr(count) * 24
	return val
}

// ==============================================================================
// Mutable JSON Document API (Implementation)
//============================================================================

func Yyjson_mut_doc_get_root(tls *libc.TLS, doc uintptr) uintptr { /* yyjson.h:2715:34: */
	if doc != 0 {
		return (*Yyjson_mut_doc)(unsafe.Pointer(doc)).Root
	}
	return uintptr(0)
}

func Yyjson_mut_doc_set_root(tls *libc.TLS, doc uintptr, root uintptr) { /* yyjson.h:2719:24: */
	if doc != 0 {
		(*Yyjson_mut_doc)(unsafe.Pointer(doc)).Root = root
	}
}

// ==============================================================================
// Mutable JSON Value Type API (Implementation)
//============================================================================

func Yyjson_mut_is_null(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2730:24: */
	if val != 0 {
		return Unsafe_yyjson_is_null(tls, val)
	}
	return uint8(False)
}

func Yyjson_mut_is_true(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2734:24: */
	if val != 0 {
		return Unsafe_yyjson_is_true(tls, val)
	}
	return uint8(False)
}

func Yyjson_mut_is_false(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2738:24: */
	if val != 0 {
		return Unsafe_yyjson_is_false(tls, val)
	}
	return uint8(False)
}

func Yyjson_mut_is_bool(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2742:24: */
	if val != 0 {
		return Unsafe_yyjson_is_bool(tls, val)
	}
	return uint8(False)
}

func Yyjson_mut_is_uint(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2746:24: */
	if val != 0 {
		return Unsafe_yyjson_is_uint(tls, val)
	}
	return uint8(False)
}

func Yyjson_mut_is_sint(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2750:24: */
	if val != 0 {
		return Unsafe_yyjson_is_sint(tls, val)
	}
	return uint8(False)
}

func Yyjson_mut_is_int(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2754:24: */
	if val != 0 {
		return Unsafe_yyjson_is_int(tls, val)
	}
	return uint8(False)
}

func Yyjson_mut_is_real(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2758:24: */
	if val != 0 {
		return Unsafe_yyjson_is_real(tls, val)
	}
	return uint8(False)
}

func Yyjson_mut_is_num(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2762:24: */
	if val != 0 {
		return Unsafe_yyjson_is_num(tls, val)
	}
	return uint8(False)
}

func Yyjson_mut_is_str(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2766:24: */
	if val != 0 {
		return Unsafe_yyjson_is_str(tls, val)
	}
	return uint8(False)
}

func Yyjson_mut_is_arr(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2770:24: */
	if val != 0 {
		return Unsafe_yyjson_is_arr(tls, val)
	}
	return uint8(False)
}

func Yyjson_mut_is_obj(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2774:24: */
	if val != 0 {
		return Unsafe_yyjson_is_obj(tls, val)
	}
	return uint8(False)
}

func Yyjson_mut_is_ctn(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2778:24: */
	if val != 0 {
		return Unsafe_yyjson_is_ctn(tls, val)
	}
	return uint8(False)
}

// ==============================================================================
// Mutable JSON Value Content API (Implementation)
//============================================================================

func Yyjson_mut_get_type(tls *libc.TLS, val uintptr) Yyjson_type { /* yyjson.h:2788:31: */
	return Yyjson_get_type(tls, val)
}

func Yyjson_mut_get_subtype(tls *libc.TLS, val uintptr) Yyjson_subtype { /* yyjson.h:2792:34: */
	return Yyjson_get_subtype(tls, val)
}

func Yyjson_mut_get_tag(tls *libc.TLS, val uintptr) Uint8_t { /* yyjson.h:2796:27: */
	return Yyjson_get_tag(tls, val)
}

func Yyjson_mut_get_type_desc(tls *libc.TLS, val uintptr) uintptr { /* yyjson.h:2800:30: */
	return Yyjson_get_type_desc(tls, val)
}

func Yyjson_mut_get_bool(tls *libc.TLS, val uintptr) uint8 { /* yyjson.h:2804:24: */
	return Yyjson_get_bool(tls, val)
}

func Yyjson_mut_get_uint(tls *libc.TLS, val uintptr) Uint64_t { /* yyjson.h:2808:28: */
	return Yyjson_get_uint(tls, val)
}

func Yyjson_mut_get_sint(tls *libc.TLS, val uintptr) Int64_t { /* yyjson.h:2812:27: */
	return Yyjson_get_sint(tls, val)
}

func Yyjson_mut_get_int(tls *libc.TLS, val uintptr) int32 { /* yyjson.h:2816:23: */
	return Yyjson_get_int(tls, val)
}

func Yyjson_mut_get_real(tls *libc.TLS, val uintptr) float64 { /* yyjson.h:2820:26: */
	return Yyjson_get_real(tls, val)
}

func Yyjson_mut_get_str(tls *libc.TLS, val uintptr) uintptr { /* yyjson.h:2824:30: */
	return Yyjson_get_str(tls, val)
}

func Yyjson_mut_get_len(tls *libc.TLS, val uintptr) Size_t { /* yyjson.h:2828:26: */
	return Yyjson_get_len(tls, val)
}

func Yyjson_mut_equals_str(tls *libc.TLS, val uintptr, str uintptr) uint8 { /* yyjson.h:2832:24: */
	return Yyjson_equals_str(tls, val, str)
}

func Yyjson_mut_equals_strn(tls *libc.TLS, val uintptr, str uintptr, len Size_t) uint8 { /* yyjson.h:2837:24: */
	return Yyjson_equals_strn(tls, val, str, len)
}

// ==============================================================================
// Mutable JSON Value Creation API (Implementation)
//============================================================================

func Yyjson_mut_null(tls *libc.TLS, doc uintptr) uintptr { /* yyjson.h:2848:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0)), int64(1)) != 0 {
		var val uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(val != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(2)) | int32(Uint8_t(int32(0)<<3)))
			return val
		}
	}
	return uintptr(0)
}

func Yyjson_mut_true(tls *libc.TLS, doc uintptr) uintptr { /* yyjson.h:2859:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0)), int64(1)) != 0 {
		var val uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(val != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(3)) | int32(Uint8_t(int32(1)<<3)))
			return val
		}
	}
	return uintptr(0)
}

func Yyjson_mut_false(tls *libc.TLS, doc uintptr) uintptr { /* yyjson.h:2870:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0)), int64(1)) != 0 {
		var val uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(val != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(3)) | int32(Uint8_t(int32(0)<<3)))
			return val
		}
	}
	return uintptr(0)
}

func Yyjson_mut_bool(tls *libc.TLS, doc uintptr, _val uint8) uintptr { /* yyjson.h:2881:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0)), int64(1)) != 0 {
		var val uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(val != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(3)) | int32(Uint8_t(int32(Uint8_t(_val))<<3)))
			return val
		}
	}
	return uintptr(0)
}

func Yyjson_mut_uint(tls *libc.TLS, doc uintptr, num Uint64_t) uintptr { /* yyjson.h:2893:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0)), int64(1)) != 0 {
		var val uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(val != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(0)<<3)))
			*(*Uint64_t)(unsafe.Pointer(val + 8)) = num
			return val
		}
	}
	return uintptr(0)
}

func Yyjson_mut_sint(tls *libc.TLS, doc uintptr, num Int64_t) uintptr { /* yyjson.h:2906:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0)), int64(1)) != 0 {
		var val uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(val != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(1)<<3)))
			*(*Int64_t)(unsafe.Pointer(val + 8)) = num
			return val
		}
	}
	return uintptr(0)
}

func Yyjson_mut_int(tls *libc.TLS, doc uintptr, num Int64_t) uintptr { /* yyjson.h:2919:34: */
	return Yyjson_mut_sint(tls, doc, num)
}

func Yyjson_mut_real(tls *libc.TLS, doc uintptr, num float64) uintptr { /* yyjson.h:2924:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0)), int64(1)) != 0 {
		var val uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(val != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
			*(*float64)(unsafe.Pointer(val + 8)) = num
			return val
		}
	}
	return uintptr(0)
}

func Yyjson_mut_str(tls *libc.TLS, doc uintptr, str uintptr) uintptr { /* yyjson.h:2937:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(str != 0)), int64(1)) != 0 {
		return Yyjson_mut_strn(tls, doc, str, libc.Xstrlen(tls, str))
	}
	return uintptr(0)
}

func Yyjson_mut_strn(tls *libc.TLS, doc uintptr, str uintptr, len Size_t) uintptr { /* yyjson.h:2943:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && str != 0)), int64(1)) != 0 {
		var val uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(val != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = Uint64_t(len)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
			*(*uintptr)(unsafe.Pointer(val + 8)) = str
			return val
		}
	}
	return uintptr(0)
}

func Yyjson_mut_strcpy(tls *libc.TLS, doc uintptr, str uintptr) uintptr { /* yyjson.h:2957:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(str != 0)), int64(1)) != 0 {
		return Yyjson_mut_strncpy(tls, doc, str, libc.Xstrlen(tls, str))
	}
	return uintptr(0)
}

func Yyjson_mut_strncpy(tls *libc.TLS, doc uintptr, str uintptr, len Size_t) uintptr { /* yyjson.h:2963:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && str != 0)), int64(1)) != 0 {
		var val uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1))
		var new_str uintptr = Unsafe_yyjson_mut_strncpy(tls, doc, str, len)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(val != 0 && new_str != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = Uint64_t(len)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
			*(*uintptr)(unsafe.Pointer(val + 8)) = new_str
			return val
		}
	}
	return uintptr(0)
}

// ==============================================================================
// Mutable JSON Array API (Implementation)
//============================================================================

func Yyjson_mut_arr_size(tls *libc.TLS, arr uintptr) Size_t { /* yyjson.h:2984:26: */
	if Yyjson_mut_is_arr(tls, arr) != 0 {
		return Unsafe_yyjson_get_len(tls, arr)
	}
	return uint64(0)
}

func Yyjson_mut_arr_get(tls *libc.TLS, arr uintptr, idx Size_t) uintptr { /* yyjson.h:2988:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(idx < Yyjson_mut_arr_size(tls, arr))), int64(1)) != 0 {
		var val uintptr = *(*uintptr)(unsafe.Pointer(arr + 8))
		for libc.PostDecUint64(&idx, 1) > uint64(0) {
			val = (*Yyjson_mut_val)(unsafe.Pointer(val)).Next
		}
		return (*Yyjson_mut_val)(unsafe.Pointer(val)).Next
	}
	return uintptr(0)
}

func Yyjson_mut_arr_get_first(tls *libc.TLS, arr uintptr) uintptr { /* yyjson.h:2998:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_arr_size(tls, arr) > uint64(0))), int64(1)) != 0 {
		return (*Yyjson_mut_val)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(arr + 8)))).Next
	}
	return uintptr(0)
}

func Yyjson_mut_arr_get_last(tls *libc.TLS, arr uintptr) uintptr { /* yyjson.h:3006:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_arr_size(tls, arr) > uint64(0))), int64(1)) != 0 {
		return *(*uintptr)(unsafe.Pointer(arr + 8))
	}
	return uintptr(0)
}

func Yyjson_mut_arr_iter_init(tls *libc.TLS, arr uintptr, iter uintptr) uint8 { /* yyjson.h:3027:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_arr(tls, arr) != 0 && iter != 0)), int64(1)) != 0 {
		(*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Idx = uint64(0)
		(*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Max = Unsafe_yyjson_get_len(tls, arr)
		(*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Cur = func() uintptr {
			if (*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Max != 0 {
				return *(*uintptr)(unsafe.Pointer(arr + 8))
			}
			return uintptr(0)
		}()
		(*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Pre = uintptr(0)
		(*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Arr = arr
		return uint8(True)
	}
	if iter != 0 {
		libc.X__builtin___memset_chk(tls, iter, 0, uint64(unsafe.Sizeof(Yyjson_mut_arr_iter{})), libc.X__builtin_object_size(tls, iter, 0))
	}
	return uint8(False)
}

func Yyjson_mut_arr_iter_has_next(tls *libc.TLS, iter uintptr) uint8 { /* yyjson.h:3041:24: */
	if iter != 0 {
		return uint8(libc.Bool32((*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Idx < (*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Max))
	}
	return uint8(False)
}

func Yyjson_mut_arr_iter_next(tls *libc.TLS, iter uintptr) uintptr { /* yyjson.h:3045:34: */
	if iter != 0 && (*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Idx < (*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Max {
		var val uintptr = (*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Cur
		(*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Pre = val
		(*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Cur = (*Yyjson_mut_val)(unsafe.Pointer(val)).Next
		(*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Idx++
		return (*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Cur
	}
	return uintptr(0)
}

func Yyjson_mut_arr_iter_remove(tls *libc.TLS, iter uintptr) uintptr { /* yyjson.h:3057:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(iter != 0 && uint64(0) < (*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Idx && (*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Idx <= (*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Max)), int64(1)) != 0 {
		var prev uintptr = (*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Pre
		var cur uintptr = (*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Cur
		var next uintptr = (*Yyjson_mut_val)(unsafe.Pointer(cur)).Next
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!((*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Idx == (*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Max)), int64(0)) != 0 {
			*(*uintptr)(unsafe.Pointer((*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Arr + 8)) = prev
		}
		(*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Idx--
		(*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Max--
		Unsafe_yyjson_set_len(tls, (*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Arr, (*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Max)
		(*Yyjson_mut_val)(unsafe.Pointer(prev)).Next = next
		(*Yyjson_mut_arr_iter)(unsafe.Pointer(iter)).Cur = next
		return cur
	}
	return uintptr(0)
}

// ==============================================================================
// Mutable JSON Array Creation API (Implementation)
//============================================================================

func Yyjson_mut_arr(tls *libc.TLS, doc uintptr) uintptr { /* yyjson.h:3080:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0)), int64(1)) != 0 {
		var val uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(val != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(6)) | int32(Uint8_t(int32(0)<<3)))
			return val
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_with_bool(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3112:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (uint64(0) < count && count < libc.CplUint64(uint64(0))/Size_t(unsafe.Sizeof(Yyjson_mut_val{})) && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var arr uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(arr != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(arr)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(6))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var val uintptr = arr + uintptr(i)*24 + uintptr(1)*24
					{
						(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(3)) | int32(Uint8_t(int32(Uint8_t(*(*uint8)(unsafe.Pointer(vals + uintptr(i)))))<<3)))
					}
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(arr + uintptr(count)*24)).Next = arr + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(arr + 8)) = arr + uintptr(count)*24
			}
			return arr
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_with_sint(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3119:34: */
	return Yyjson_mut_arr_with_sint64(tls, doc, vals, count)
}

func Yyjson_mut_arr_with_uint(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3124:34: */
	return Yyjson_mut_arr_with_uint64(tls, doc, vals, count)
}

func Yyjson_mut_arr_with_real(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3129:34: */
	return Yyjson_mut_arr_with_double(tls, doc, vals, count)
}

func Yyjson_mut_arr_with_sint8(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3134:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (uint64(0) < count && count < libc.CplUint64(uint64(0))/Size_t(unsafe.Sizeof(Yyjson_mut_val{})) && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var arr uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(arr != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(arr)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(6))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var val uintptr = arr + uintptr(i)*24 + uintptr(1)*24
					{
						(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(1)<<3)))
						*(*Int64_t)(unsafe.Pointer(val + 8)) = Int64_t(*(*Int8_t)(unsafe.Pointer(vals + uintptr(i))))
					}
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(arr + uintptr(count)*24)).Next = arr + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(arr + 8)) = arr + uintptr(count)*24
			}
			return arr
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_with_sint16(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3142:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (uint64(0) < count && count < libc.CplUint64(uint64(0))/Size_t(unsafe.Sizeof(Yyjson_mut_val{})) && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var arr uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(arr != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(arr)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(6))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var val uintptr = arr + uintptr(i)*24 + uintptr(1)*24
					{
						(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(1)<<3)))
						*(*Int64_t)(unsafe.Pointer(val + 8)) = Int64_t(*(*Int16_t)(unsafe.Pointer(vals + uintptr(i)*2)))
					}
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(arr + uintptr(count)*24)).Next = arr + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(arr + 8)) = arr + uintptr(count)*24
			}
			return arr
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_with_sint32(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3150:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (uint64(0) < count && count < libc.CplUint64(uint64(0))/Size_t(unsafe.Sizeof(Yyjson_mut_val{})) && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var arr uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(arr != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(arr)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(6))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var val uintptr = arr + uintptr(i)*24 + uintptr(1)*24
					{
						(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(1)<<3)))
						*(*Int64_t)(unsafe.Pointer(val + 8)) = Int64_t(*(*Int32_t)(unsafe.Pointer(vals + uintptr(i)*4)))
					}
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(arr + uintptr(count)*24)).Next = arr + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(arr + 8)) = arr + uintptr(count)*24
			}
			return arr
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_with_sint64(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3158:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (uint64(0) < count && count < libc.CplUint64(uint64(0))/Size_t(unsafe.Sizeof(Yyjson_mut_val{})) && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var arr uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(arr != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(arr)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(6))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var val uintptr = arr + uintptr(i)*24 + uintptr(1)*24
					{
						(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(1)<<3)))
						*(*Int64_t)(unsafe.Pointer(val + 8)) = *(*Int64_t)(unsafe.Pointer(vals + uintptr(i)*8))
					}
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(arr + uintptr(count)*24)).Next = arr + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(arr + 8)) = arr + uintptr(count)*24
			}
			return arr
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_with_uint8(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3166:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (uint64(0) < count && count < libc.CplUint64(uint64(0))/Size_t(unsafe.Sizeof(Yyjson_mut_val{})) && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var arr uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(arr != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(arr)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(6))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var val uintptr = arr + uintptr(i)*24 + uintptr(1)*24
					{
						(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(0)<<3)))
						*(*Uint64_t)(unsafe.Pointer(val + 8)) = Uint64_t(*(*Uint8_t)(unsafe.Pointer(vals + uintptr(i))))
					}
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(arr + uintptr(count)*24)).Next = arr + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(arr + 8)) = arr + uintptr(count)*24
			}
			return arr
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_with_uint16(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3174:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (uint64(0) < count && count < libc.CplUint64(uint64(0))/Size_t(unsafe.Sizeof(Yyjson_mut_val{})) && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var arr uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(arr != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(arr)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(6))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var val uintptr = arr + uintptr(i)*24 + uintptr(1)*24
					{
						(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(0)<<3)))
						*(*Uint64_t)(unsafe.Pointer(val + 8)) = Uint64_t(*(*Uint16_t)(unsafe.Pointer(vals + uintptr(i)*2)))
					}
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(arr + uintptr(count)*24)).Next = arr + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(arr + 8)) = arr + uintptr(count)*24
			}
			return arr
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_with_uint32(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3182:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (uint64(0) < count && count < libc.CplUint64(uint64(0))/Size_t(unsafe.Sizeof(Yyjson_mut_val{})) && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var arr uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(arr != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(arr)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(6))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var val uintptr = arr + uintptr(i)*24 + uintptr(1)*24
					{
						(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(0)<<3)))
						*(*Uint64_t)(unsafe.Pointer(val + 8)) = Uint64_t(*(*Uint32_t)(unsafe.Pointer(vals + uintptr(i)*4)))
					}
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(arr + uintptr(count)*24)).Next = arr + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(arr + 8)) = arr + uintptr(count)*24
			}
			return arr
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_with_uint64(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3190:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (uint64(0) < count && count < libc.CplUint64(uint64(0))/Size_t(unsafe.Sizeof(Yyjson_mut_val{})) && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var arr uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(arr != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(arr)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(6))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var val uintptr = arr + uintptr(i)*24 + uintptr(1)*24
					{
						(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(0)<<3)))
						*(*Uint64_t)(unsafe.Pointer(val + 8)) = *(*Uint64_t)(unsafe.Pointer(vals + uintptr(i)*8))
					}
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(arr + uintptr(count)*24)).Next = arr + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(arr + 8)) = arr + uintptr(count)*24
			}
			return arr
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_with_float(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3198:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (uint64(0) < count && count < libc.CplUint64(uint64(0))/Size_t(unsafe.Sizeof(Yyjson_mut_val{})) && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var arr uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(arr != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(arr)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(6))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var val uintptr = arr + uintptr(i)*24 + uintptr(1)*24
					{
						(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
						*(*float64)(unsafe.Pointer(val + 8)) = float64(*(*float32)(unsafe.Pointer(vals + uintptr(i)*4)))
					}
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(arr + uintptr(count)*24)).Next = arr + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(arr + 8)) = arr + uintptr(count)*24
			}
			return arr
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_with_double(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3206:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (uint64(0) < count && count < libc.CplUint64(uint64(0))/Size_t(unsafe.Sizeof(Yyjson_mut_val{})) && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var arr uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(arr != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(arr)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(6))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var val uintptr = arr + uintptr(i)*24 + uintptr(1)*24
					{
						(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
						*(*float64)(unsafe.Pointer(val + 8)) = *(*float64)(unsafe.Pointer(vals + uintptr(i)*8))
					}
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(arr + uintptr(count)*24)).Next = arr + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(arr + 8)) = arr + uintptr(count)*24
			}
			return arr
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_with_str(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3214:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (uint64(0) < count && count < libc.CplUint64(uint64(0))/Size_t(unsafe.Sizeof(Yyjson_mut_val{})) && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var arr uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(arr != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(arr)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(6))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var val uintptr = arr + uintptr(i)*24 + uintptr(1)*24
					{
						var len Uint64_t = Uint64_t(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(vals + uintptr(i)*8))))
						(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = len<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
						*(*uintptr)(unsafe.Pointer(val + 8)) = *(*uintptr)(unsafe.Pointer(vals + uintptr(i)*8))
					}
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(arr + uintptr(count)*24)).Next = arr + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(arr + 8)) = arr + uintptr(count)*24
			}
			return arr
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_with_strn(tls *libc.TLS, doc uintptr, vals uintptr, lens uintptr, count Size_t) uintptr { /* yyjson.h:3223:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(count > uint64(0) && !(lens != 0))), int64(0)) != 0 {
		return uintptr(0)
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (uint64(0) < count && count < libc.CplUint64(uint64(0))/Size_t(unsafe.Sizeof(Yyjson_mut_val{})) && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var arr uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(arr != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(arr)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(6))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var val uintptr = arr + uintptr(i)*24 + uintptr(1)*24
					{
						(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = Uint64_t(*(*Size_t)(unsafe.Pointer(lens + uintptr(i)*8)))<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
						*(*uintptr)(unsafe.Pointer(val + 8)) = *(*uintptr)(unsafe.Pointer(vals + uintptr(i)*8))
					}
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(arr + uintptr(count)*24)).Next = arr + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(arr + 8)) = arr + uintptr(count)*24
			}
			return arr
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_with_strcpy(tls *libc.TLS, doc uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3232:34: */
	var len Size_t
	var str uintptr
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (uint64(0) < count && count < libc.CplUint64(uint64(0))/Size_t(unsafe.Sizeof(Yyjson_mut_val{})) && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var arr uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(arr != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(arr)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(6))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var val uintptr = arr + uintptr(i)*24 + uintptr(1)*24
					{
						str = *(*uintptr)(unsafe.Pointer(vals + uintptr(i)*8))
						if !(str != 0) {
							return uintptr(0)
						}
						len = libc.Xstrlen(tls, str)
						(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = Uint64_t(len)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
						*(*uintptr)(unsafe.Pointer(val + 8)) = Unsafe_yyjson_mut_strncpy(tls, doc, str, len)
						if !(int32(*(*uintptr)(unsafe.Pointer(val + 8))) != 0) {
							return uintptr(0)
						}
					}
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(arr + uintptr(count)*24)).Next = arr + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(arr + 8)) = arr + uintptr(count)*24
			}
			return arr
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_with_strncpy(tls *libc.TLS, doc uintptr, vals uintptr, lens uintptr, count Size_t) uintptr { /* yyjson.h:3246:34: */
	var len Size_t
	var str uintptr
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(count > uint64(0) && !(lens != 0))), int64(0)) != 0 {
		return uintptr(0)
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (uint64(0) < count && count < libc.CplUint64(uint64(0))/Size_t(unsafe.Sizeof(Yyjson_mut_val{})) && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var arr uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(arr != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(arr)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(6))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var val uintptr = arr + uintptr(i)*24 + uintptr(1)*24
					{
						str = *(*uintptr)(unsafe.Pointer(vals + uintptr(i)*8))
						len = *(*Size_t)(unsafe.Pointer(lens + uintptr(i)*8))
						(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = Uint64_t(len)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
						*(*uintptr)(unsafe.Pointer(val + 8)) = Unsafe_yyjson_mut_strncpy(tls, doc, str, len)
						if !(int32(*(*uintptr)(unsafe.Pointer(val + 8))) != 0) {
							return uintptr(0)
						}
					}
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(arr + uintptr(count)*24)).Next = arr + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(arr + 8)) = arr + uintptr(count)*24
			}
			return arr
		}
	}
	return uintptr(0)
}

// ==============================================================================
// Mutable JSON Array Modification API (Implementation)
//============================================================================

func Yyjson_mut_arr_insert(tls *libc.TLS, arr uintptr, val uintptr, idx Size_t) uint8 { /* yyjson.h:3268:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_arr(tls, arr) != 0 && val != 0)), int64(1)) != 0 {
		var len Size_t = Unsafe_yyjson_get_len(tls, arr)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(idx <= len)), int64(1)) != 0 {
			Unsafe_yyjson_set_len(tls, arr, len+uint64(1))
			if len == uint64(0) {
				(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val
				*(*uintptr)(unsafe.Pointer(arr + 8)) = val
			} else {
				var prev uintptr = *(*uintptr)(unsafe.Pointer(arr + 8))
				var next uintptr = (*Yyjson_mut_val)(unsafe.Pointer(prev)).Next
				if idx == len {
					(*Yyjson_mut_val)(unsafe.Pointer(prev)).Next = val
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = next
					*(*uintptr)(unsafe.Pointer(arr + 8)) = val
				} else {
					for libc.PostDecUint64(&idx, 1) > uint64(0) {
						prev = next
						next = (*Yyjson_mut_val)(unsafe.Pointer(next)).Next
					}
					(*Yyjson_mut_val)(unsafe.Pointer(prev)).Next = val
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = next
				}
			}
			return uint8(True)
		}
	}
	return uint8(False)
}

func Yyjson_mut_arr_append(tls *libc.TLS, arr uintptr, val uintptr) uint8 { /* yyjson.h:3299:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_arr(tls, arr) != 0 && val != 0)), int64(1)) != 0 {
		var len Size_t = Unsafe_yyjson_get_len(tls, arr)
		Unsafe_yyjson_set_len(tls, arr, len+uint64(1))
		if len == uint64(0) {
			(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val
		} else {
			var prev uintptr = *(*uintptr)(unsafe.Pointer(arr + 8))
			var next uintptr = (*Yyjson_mut_val)(unsafe.Pointer(prev)).Next
			(*Yyjson_mut_val)(unsafe.Pointer(prev)).Next = val
			(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = next
		}
		*(*uintptr)(unsafe.Pointer(arr + 8)) = val
		return uint8(True)
	}
	return uint8(False)
}

func Yyjson_mut_arr_prepend(tls *libc.TLS, arr uintptr, val uintptr) uint8 { /* yyjson.h:3318:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_arr(tls, arr) != 0 && val != 0)), int64(1)) != 0 {
		var len Size_t = Unsafe_yyjson_get_len(tls, arr)
		Unsafe_yyjson_set_len(tls, arr, len+uint64(1))
		if len == uint64(0) {
			(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val
			*(*uintptr)(unsafe.Pointer(arr + 8)) = val
		} else {
			var prev uintptr = *(*uintptr)(unsafe.Pointer(arr + 8))
			var next uintptr = (*Yyjson_mut_val)(unsafe.Pointer(prev)).Next
			(*Yyjson_mut_val)(unsafe.Pointer(prev)).Next = val
			(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = next
		}
		return uint8(True)
	}
	return uint8(False)
}

func Yyjson_mut_arr_replace(tls *libc.TLS, arr uintptr, idx Size_t, val uintptr) uintptr { /* yyjson.h:3337:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_arr(tls, arr) != 0 && val != 0)), int64(1)) != 0 {
		var len Size_t = Unsafe_yyjson_get_len(tls, arr)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(idx < len)), int64(1)) != 0 {
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!(len > uint64(1))), int64(1)) != 0 {
				var prev uintptr = *(*uintptr)(unsafe.Pointer(arr + 8))
				var next uintptr = (*Yyjson_mut_val)(unsafe.Pointer(prev)).Next
				for libc.PostDecUint64(&idx, 1) > uint64(0) {
					prev = next
					next = (*Yyjson_mut_val)(unsafe.Pointer(next)).Next
				}
				(*Yyjson_mut_val)(unsafe.Pointer(prev)).Next = val
				(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = (*Yyjson_mut_val)(unsafe.Pointer(next)).Next
				if next == *(*uintptr)(unsafe.Pointer(arr + 8)) {
					*(*uintptr)(unsafe.Pointer(arr + 8)) = val
				}
				return next
			} else {
				var prev uintptr = *(*uintptr)(unsafe.Pointer(arr + 8))
				(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val
				*(*uintptr)(unsafe.Pointer(arr + 8)) = val
				return prev
			}

		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_remove(tls *libc.TLS, arr uintptr, idx Size_t) uintptr { /* yyjson.h:3365:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var len Size_t = Unsafe_yyjson_get_len(tls, arr)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(idx < len)), int64(1)) != 0 {
			Unsafe_yyjson_set_len(tls, arr, len-uint64(1))
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!(len > uint64(1))), int64(1)) != 0 {
				var prev uintptr = *(*uintptr)(unsafe.Pointer(arr + 8))
				var next uintptr = (*Yyjson_mut_val)(unsafe.Pointer(prev)).Next
				for libc.PostDecUint64(&idx, 1) > uint64(0) {
					prev = next
					next = (*Yyjson_mut_val)(unsafe.Pointer(next)).Next
				}
				(*Yyjson_mut_val)(unsafe.Pointer(prev)).Next = (*Yyjson_mut_val)(unsafe.Pointer(next)).Next
				if next == *(*uintptr)(unsafe.Pointer(arr + 8)) {
					*(*uintptr)(unsafe.Pointer(arr + 8)) = prev
				}
				return next
			} else {
				return *(*uintptr)(unsafe.Pointer(arr + 8))
			}
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_remove_first(tls *libc.TLS, arr uintptr) uintptr { /* yyjson.h:3389:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var len Size_t = Unsafe_yyjson_get_len(tls, arr)
		if len > uint64(1) {
			var prev uintptr = *(*uintptr)(unsafe.Pointer(arr + 8))
			var next uintptr = (*Yyjson_mut_val)(unsafe.Pointer(prev)).Next
			(*Yyjson_mut_val)(unsafe.Pointer(prev)).Next = (*Yyjson_mut_val)(unsafe.Pointer(next)).Next
			Unsafe_yyjson_set_len(tls, arr, len-uint64(1))
			return next
		} else if len == uint64(1) {
			var prev uintptr = *(*uintptr)(unsafe.Pointer(arr + 8))
			Unsafe_yyjson_set_len(tls, arr, uint64(0))
			return prev
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_remove_last(tls *libc.TLS, arr uintptr) uintptr { /* yyjson.h:3408:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var len Size_t = Unsafe_yyjson_get_len(tls, arr)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(len > uint64(1))), int64(1)) != 0 {
			var prev uintptr = *(*uintptr)(unsafe.Pointer(arr + 8))
			var next uintptr = (*Yyjson_mut_val)(unsafe.Pointer(prev)).Next
			Unsafe_yyjson_set_len(tls, arr, len-uint64(1))
			for libc.PreDecUint64(&len, 1) > uint64(0) {
				prev = (*Yyjson_mut_val)(unsafe.Pointer(prev)).Next
			}
			(*Yyjson_mut_val)(unsafe.Pointer(prev)).Next = next
			next = *(*uintptr)(unsafe.Pointer(arr + 8))
			*(*uintptr)(unsafe.Pointer(arr + 8)) = prev
			return next
		} else if len == uint64(1) {
			var prev uintptr = *(*uintptr)(unsafe.Pointer(arr + 8))
			Unsafe_yyjson_set_len(tls, arr, uint64(0))
			return prev
		}
	}
	return uintptr(0)
}

func Yyjson_mut_arr_remove_range(tls *libc.TLS, arr uintptr, _idx Size_t, _len Size_t) uint8 { /* yyjson.h:3430:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var prev uintptr
		var next uintptr
		var tail_removed uint8
		var len Size_t = Unsafe_yyjson_get_len(tls, arr)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(_idx+_len > len)), int64(0)) != 0 {
			return uint8(False)
		}
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(_len == uint64(0))), int64(0)) != 0 {
			return uint8(True)
		}
		Unsafe_yyjson_set_len(tls, arr, len-_len)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(len == _len)), int64(0)) != 0 {
			return uint8(True)
		}
		tail_removed = uint8(libc.Bool32(_idx+_len == len))
		prev = *(*uintptr)(unsafe.Pointer(arr + 8))
		for libc.PostDecUint64(&_idx, 1) > uint64(0) {
			prev = (*Yyjson_mut_val)(unsafe.Pointer(prev)).Next
		}
		next = (*Yyjson_mut_val)(unsafe.Pointer(prev)).Next
		for libc.PostDecUint64(&_len, 1) > uint64(0) {
			next = (*Yyjson_mut_val)(unsafe.Pointer(next)).Next
		}
		(*Yyjson_mut_val)(unsafe.Pointer(prev)).Next = next
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(tail_removed != 0)), int64(0)) != 0 {
			*(*uintptr)(unsafe.Pointer(arr + 8)) = prev
		}
		return uint8(True)
	}
	return uint8(False)
}

func Yyjson_mut_arr_clear(tls *libc.TLS, arr uintptr) uint8 { /* yyjson.h:3452:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		Unsafe_yyjson_set_len(tls, arr, uint64(0))
		return uint8(True)
	}
	return uint8(False)
}

func Yyjson_mut_arr_rotate(tls *libc.TLS, arr uintptr, idx Size_t) uint8 { /* yyjson.h:3460:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_arr(tls, arr) != 0 && Unsafe_yyjson_get_len(tls, arr) > idx)), int64(1)) != 0 {
		var val uintptr = *(*uintptr)(unsafe.Pointer(arr + 8))
		for libc.PostDecUint64(&idx, 1) > uint64(0) {
			val = (*Yyjson_mut_val)(unsafe.Pointer(val)).Next
		}
		*(*uintptr)(unsafe.Pointer(arr + 8)) = val
		return uint8(True)
	}
	return uint8(False)
}

// ==============================================================================
// Mutable JSON Array Modification Convenience API (Implementation)
//============================================================================

func Yyjson_mut_arr_add_val(tls *libc.TLS, arr uintptr, val uintptr) uint8 { /* yyjson.h:3478:24: */
	return Yyjson_mut_arr_append(tls, arr, val)
}

func Yyjson_mut_arr_add_null(tls *libc.TLS, doc uintptr, arr uintptr) uint8 { /* yyjson.h:3483:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var val uintptr = Yyjson_mut_null(tls, doc)
		return Yyjson_mut_arr_append(tls, arr, val)
	}
	return uint8(False)
}

func Yyjson_mut_arr_add_true(tls *libc.TLS, doc uintptr, arr uintptr) uint8 { /* yyjson.h:3492:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var val uintptr = Yyjson_mut_true(tls, doc)
		return Yyjson_mut_arr_append(tls, arr, val)
	}
	return uint8(False)
}

func Yyjson_mut_arr_add_false(tls *libc.TLS, doc uintptr, arr uintptr) uint8 { /* yyjson.h:3501:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var val uintptr = Yyjson_mut_false(tls, doc)
		return Yyjson_mut_arr_append(tls, arr, val)
	}
	return uint8(False)
}

func Yyjson_mut_arr_add_bool(tls *libc.TLS, doc uintptr, arr uintptr, _val uint8) uint8 { /* yyjson.h:3510:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var val uintptr = Yyjson_mut_bool(tls, doc, _val)
		return Yyjson_mut_arr_append(tls, arr, val)
	}
	return uint8(False)
}

func Yyjson_mut_arr_add_uint(tls *libc.TLS, doc uintptr, arr uintptr, num Uint64_t) uint8 { /* yyjson.h:3520:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var val uintptr = Yyjson_mut_uint(tls, doc, num)
		return Yyjson_mut_arr_append(tls, arr, val)
	}
	return uint8(False)
}

func Yyjson_mut_arr_add_sint(tls *libc.TLS, doc uintptr, arr uintptr, num Int64_t) uint8 { /* yyjson.h:3530:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var val uintptr = Yyjson_mut_sint(tls, doc, num)
		return Yyjson_mut_arr_append(tls, arr, val)
	}
	return uint8(False)
}

func Yyjson_mut_arr_add_int(tls *libc.TLS, doc uintptr, arr uintptr, num Int64_t) uint8 { /* yyjson.h:3540:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var val uintptr = Yyjson_mut_sint(tls, doc, num)
		return Yyjson_mut_arr_append(tls, arr, val)
	}
	return uint8(False)
}

func Yyjson_mut_arr_add_real(tls *libc.TLS, doc uintptr, arr uintptr, num float64) uint8 { /* yyjson.h:3550:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var val uintptr = Yyjson_mut_real(tls, doc, num)
		return Yyjson_mut_arr_append(tls, arr, val)
	}
	return uint8(False)
}

func Yyjson_mut_arr_add_str(tls *libc.TLS, doc uintptr, arr uintptr, str uintptr) uint8 { /* yyjson.h:3560:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var val uintptr = Yyjson_mut_str(tls, doc, str)
		return Yyjson_mut_arr_append(tls, arr, val)
	}
	return uint8(False)
}

func Yyjson_mut_arr_add_strn(tls *libc.TLS, doc uintptr, arr uintptr, str uintptr, len Size_t) uint8 { /* yyjson.h:3570:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var val uintptr = Yyjson_mut_strn(tls, doc, str, len)
		return Yyjson_mut_arr_append(tls, arr, val)
	}
	return uint8(False)
}

func Yyjson_mut_arr_add_strcpy(tls *libc.TLS, doc uintptr, arr uintptr, str uintptr) uint8 { /* yyjson.h:3580:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var val uintptr = Yyjson_mut_strcpy(tls, doc, str)
		return Yyjson_mut_arr_append(tls, arr, val)
	}
	return uint8(False)
}

func Yyjson_mut_arr_add_strncpy(tls *libc.TLS, doc uintptr, arr uintptr, str uintptr, len Size_t) uint8 { /* yyjson.h:3590:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var val uintptr = Yyjson_mut_strncpy(tls, doc, str, len)
		return Yyjson_mut_arr_append(tls, arr, val)
	}
	return uint8(False)
}

func Yyjson_mut_arr_add_arr(tls *libc.TLS, doc uintptr, arr uintptr) uintptr { /* yyjson.h:3600:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var val uintptr = Yyjson_mut_arr(tls, doc)
		if Yyjson_mut_arr_append(tls, arr, val) != 0 {
			return val
		}
		return uintptr(0)
	}
	return uintptr(0)
}

func Yyjson_mut_arr_add_obj(tls *libc.TLS, doc uintptr, arr uintptr) uintptr { /* yyjson.h:3609:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_arr(tls, arr) != 0)), int64(1)) != 0 {
		var val uintptr = Yyjson_mut_obj(tls, doc)
		if Yyjson_mut_arr_append(tls, arr, val) != 0 {
			return val
		}
		return uintptr(0)
	}
	return uintptr(0)
}

// ==============================================================================
// Mutable JSON Object API (Implementation)
//============================================================================

func Yyjson_mut_obj_size(tls *libc.TLS, obj uintptr) Size_t { /* yyjson.h:3624:26: */
	if Yyjson_mut_is_obj(tls, obj) != 0 {
		return Unsafe_yyjson_get_len(tls, obj)
	}
	return uint64(0)
}

func Yyjson_mut_obj_get(tls *libc.TLS, obj uintptr, key_str uintptr) uintptr { /* yyjson.h:3628:34: */
	return Yyjson_mut_obj_getn(tls, obj, key_str, func() uint64 {
		if key_str != 0 {
			return libc.Xstrlen(tls, key_str)
		}
		return uint64(0)
	}())
}

func Yyjson_mut_obj_getn(tls *libc.TLS, obj uintptr, key_str uintptr, key_len Size_t) uintptr { /* yyjson.h:3633:34: */
	var tag Uint64_t = Uint64_t(key_len)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
	var len Size_t = Yyjson_mut_obj_size(tls, obj)
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(len != 0 && key_str != 0)), int64(1)) != 0 {
		var key uintptr = (*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(obj + 8)))).Next)).Next
		for libc.PostDecUint64(&len, 1) > uint64(0) {
			if (*Yyjson_mut_val)(unsafe.Pointer(key)).Tag == tag && libc.Xmemcmp(tls, *(*uintptr)(unsafe.Pointer(key + 8)), key_str, key_len) == 0 {
				return (*Yyjson_mut_val)(unsafe.Pointer(key)).Next
			}
			key = (*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(key)).Next)).Next
		}
	}
	return uintptr(0)
}

func Yyjson_mut_obj_iter_init(tls *libc.TLS, obj uintptr, iter uintptr) uint8 { /* yyjson.h:3665:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_obj(tls, obj) != 0 && iter != 0)), int64(1)) != 0 {
		(*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Idx = uint64(0)
		(*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Max = Unsafe_yyjson_get_len(tls, obj)
		(*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Cur = func() uintptr {
			if (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Max != 0 {
				return *(*uintptr)(unsafe.Pointer(obj + 8))
			}
			return uintptr(0)
		}()
		(*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Pre = uintptr(0)
		(*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Obj = obj
		return uint8(True)
	}
	if iter != 0 {
		libc.X__builtin___memset_chk(tls, iter, 0, uint64(unsafe.Sizeof(Yyjson_mut_obj_iter{})), libc.X__builtin_object_size(tls, iter, 0))
	}
	return uint8(False)
}

func Yyjson_mut_obj_iter_has_next(tls *libc.TLS, iter uintptr) uint8 { /* yyjson.h:3679:24: */
	if iter != 0 {
		return uint8(libc.Bool32((*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Idx < (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Max))
	}
	return uint8(False)
}

func Yyjson_mut_obj_iter_next(tls *libc.TLS, iter uintptr) uintptr { /* yyjson.h:3683:34: */
	if iter != 0 && (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Idx < (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Max {
		var key uintptr = (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Cur
		(*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Pre = key
		(*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Cur = (*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(key)).Next)).Next
		(*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Idx++
		return (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Cur
	}
	return uintptr(0)
}

func Yyjson_mut_obj_iter_get_val(tls *libc.TLS, key uintptr) uintptr { /* yyjson.h:3695:34: */
	return (*Yyjson_mut_val)(unsafe.Pointer(key)).Next
}

func Yyjson_mut_obj_iter_remove(tls *libc.TLS, iter uintptr) uintptr { /* yyjson.h:3700:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(iter != 0 && uint64(0) < (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Idx && (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Idx <= (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Max)), int64(1)) != 0 {
		var prev uintptr = (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Pre
		var cur uintptr = (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Cur
		var next uintptr = (*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(cur)).Next)).Next
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!((*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Idx == (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Max)), int64(0)) != 0 {
			*(*uintptr)(unsafe.Pointer((*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Obj + 8)) = prev
		}
		(*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Idx--
		(*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Max--
		Unsafe_yyjson_set_len(tls, (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Obj, (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Max)
		(*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(prev)).Next)).Next = next
		(*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Cur = next
		return cur
	}
	return uintptr(0)
}

func Yyjson_mut_obj_iter_get(tls *libc.TLS, iter uintptr, key uintptr) uintptr { /* yyjson.h:3717:34: */
	return Yyjson_mut_obj_iter_getn(tls, iter, key, func() uint64 {
		if key != 0 {
			return libc.Xstrlen(tls, key)
		}
		return uint64(0)
	}())
}

func Yyjson_mut_obj_iter_getn(tls *libc.TLS, iter uintptr, key uintptr, key_len Size_t) uintptr { /* yyjson.h:3722:34: */
	if iter != 0 && key != 0 {
		var idx Size_t = uint64(0)
		var max Size_t = (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Max
		var pre uintptr
		var cur uintptr = (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Cur
		for libc.PostIncUint64(&idx, 1) < max {
			pre = cur
			cur = (*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(cur)).Next)).Next
			if Unsafe_yyjson_get_len(tls, cur) == key_len && libc.Xmemcmp(tls, *(*uintptr)(unsafe.Pointer(cur + 8)), key, key_len) == 0 {
				*(*Size_t)(unsafe.Pointer(iter)) += idx
				if (*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Idx > max {
					*(*Size_t)(unsafe.Pointer(iter)) -= max + uint64(1)
				}
				(*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Pre = pre
				(*Yyjson_mut_obj_iter)(unsafe.Pointer(iter)).Cur = cur
				return (*Yyjson_mut_val)(unsafe.Pointer(cur)).Next
			}
		}
	}
	return uintptr(0)
}

// ==============================================================================
// Mutable JSON Object Creation API (Implementation)
//============================================================================

func Yyjson_mut_obj(tls *libc.TLS, doc uintptr) uintptr { /* yyjson.h:3750:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0)), int64(1)) != 0 {
		var val uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(val != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(7)) | int32(Uint8_t(int32(0)<<3)))
			return val
		}
	}
	return uintptr(0)
}

func Yyjson_mut_obj_with_str(tls *libc.TLS, doc uintptr, keys uintptr, vals uintptr, count Size_t) uintptr { /* yyjson.h:3761:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (count > uint64(0) && keys != 0 && vals != 0 || count == uint64(0)))), int64(1)) != 0 {
		var obj uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count*uint64(2))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(obj != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(obj)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(7))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var key uintptr = obj + uintptr(i*uint64(2)+uint64(1))*24
					var val uintptr = obj + uintptr(i*uint64(2)+uint64(2))*24
					var key_len Uint64_t = Uint64_t(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(keys + uintptr(i)*8))))
					var val_len Uint64_t = Uint64_t(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(vals + uintptr(i)*8))))
					(*Yyjson_mut_val)(unsafe.Pointer(key)).Tag = key_len<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = val_len<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
					*(*uintptr)(unsafe.Pointer(key + 8)) = *(*uintptr)(unsafe.Pointer(keys + uintptr(i)*8))
					*(*uintptr)(unsafe.Pointer(val + 8)) = *(*uintptr)(unsafe.Pointer(vals + uintptr(i)*8))
					(*Yyjson_mut_val)(unsafe.Pointer(key)).Next = val
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(obj + uintptr(count*uint64(2))*24)).Next = obj + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(obj + 8)) = obj + uintptr(count*uint64(2)-uint64(1))*24
			}
			return obj
		}
	}
	return uintptr(0)
}

func Yyjson_mut_obj_with_kv(tls *libc.TLS, doc uintptr, pairs uintptr, count Size_t) uintptr { /* yyjson.h:3792:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && (count > uint64(0) && pairs != 0 || count == uint64(0)))), int64(1)) != 0 {
		var obj uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(1)+count*uint64(2))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(obj != 0)), int64(1)) != 0 {
			(*Yyjson_mut_val)(unsafe.Pointer(obj)).Tag = Uint64_t(count)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(7))
			if count > uint64(0) {
				var i Size_t
				for i = uint64(0); i < count; i++ {
					var key uintptr = obj + uintptr(i*uint64(2)+uint64(1))*24
					var val uintptr = obj + uintptr(i*uint64(2)+uint64(2))*24
					var key_str uintptr = *(*uintptr)(unsafe.Pointer(pairs + uintptr(i*uint64(2)+uint64(0))*8))
					var val_str uintptr = *(*uintptr)(unsafe.Pointer(pairs + uintptr(i*uint64(2)+uint64(1))*8))
					var key_len Uint64_t = Uint64_t(libc.Xstrlen(tls, key_str))
					var val_len Uint64_t = Uint64_t(libc.Xstrlen(tls, val_str))
					(*Yyjson_mut_val)(unsafe.Pointer(key)).Tag = key_len<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = val_len<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
					*(*uintptr)(unsafe.Pointer(key + 8)) = key_str
					*(*uintptr)(unsafe.Pointer(val + 8)) = val_str
					(*Yyjson_mut_val)(unsafe.Pointer(key)).Next = val
					(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = val + uintptr(1)*24
				}
				(*Yyjson_mut_val)(unsafe.Pointer(obj + uintptr(count*uint64(2))*24)).Next = obj + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(obj + 8)) = obj + uintptr(count*uint64(2)-uint64(1))*24
			}
			return obj
		}
	}
	return uintptr(0)
}

// ==============================================================================
// Mutable JSON Object Modification API (Implementation)
//============================================================================

func Unsafe_yyjson_mut_obj_add(tls *libc.TLS, obj uintptr, key uintptr, val uintptr, len Size_t) { /* yyjson.h:3830:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(len != 0)), int64(1)) != 0 {
		var prev_val uintptr = (*Yyjson_mut_val)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(obj + 8)))).Next
		var next_key uintptr = (*Yyjson_mut_val)(unsafe.Pointer(prev_val)).Next
		(*Yyjson_mut_val)(unsafe.Pointer(prev_val)).Next = key
		(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = next_key
	} else {
		(*Yyjson_mut_val)(unsafe.Pointer(val)).Next = key
	}
	(*Yyjson_mut_val)(unsafe.Pointer(key)).Next = val
	*(*uintptr)(unsafe.Pointer(obj + 8)) = key
	Unsafe_yyjson_set_len(tls, obj, len+uint64(1))
}

func Unsafe_yyjson_mut_obj_remove(tls *libc.TLS, obj uintptr, key uintptr, key_len Size_t, key_tag Uint64_t) uintptr { /* yyjson.h:3847:34: */
	var obj_len Size_t = Unsafe_yyjson_get_len(tls, obj)
	if obj_len != 0 {
		var pre_key uintptr = *(*uintptr)(unsafe.Pointer(obj + 8))
		var cur_key uintptr = (*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(pre_key)).Next)).Next
		var removed_item uintptr = uintptr(0)
		var i Size_t
		for i = uint64(0); i < obj_len; i++ {
			if key_tag == (*Yyjson_mut_val)(unsafe.Pointer(cur_key)).Tag && libc.Xmemcmp(tls, key, *(*uintptr)(unsafe.Pointer(cur_key + 8)), key_len) == 0 {
				if !(removed_item != 0) {
					removed_item = (*Yyjson_mut_val)(unsafe.Pointer(cur_key)).Next
				}
				cur_key = (*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(cur_key)).Next)).Next
				(*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(pre_key)).Next)).Next = cur_key
				if i+uint64(1) == obj_len {
					*(*uintptr)(unsafe.Pointer(obj + 8)) = pre_key
				}
				i--
				obj_len--
			} else {
				pre_key = cur_key
				cur_key = (*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(cur_key)).Next)).Next
			}
		}
		Unsafe_yyjson_set_len(tls, obj, obj_len)
		return removed_item
	} else {
		return uintptr(0)
	}
	return uintptr(0)
}

func Unsafe_yyjson_mut_obj_replace(tls *libc.TLS, obj uintptr, key uintptr, val uintptr) uint8 { /* yyjson.h:3879:24: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var key_len Size_t = Unsafe_yyjson_get_len(tls, key)
	var obj_len Size_t = Unsafe_yyjson_get_len(tls, obj)
	if obj_len != 0 {
		var pre_key uintptr = *(*uintptr)(unsafe.Pointer(obj + 8))
		var cur_key uintptr = (*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(pre_key)).Next)).Next
		var i Size_t
		for i = uint64(0); i < obj_len; i++ {
			if (*Yyjson_mut_val)(unsafe.Pointer(key)).Tag == (*Yyjson_mut_val)(unsafe.Pointer(cur_key)).Tag && libc.Xmemcmp(tls, *(*uintptr)(unsafe.Pointer(key + 8)), *(*uintptr)(unsafe.Pointer(cur_key + 8)), key_len) == 0 {
				var cpy_len Size_t = uint64(unsafe.Sizeof(Yyjson_mut_val{})) - uint64(unsafe.Sizeof(uintptr(0)))
				// var tmp Yyjson_mut_val at bp, 24

				libc.X__builtin___memcpy_chk(tls, bp, cur_key, cpy_len, libc.X__builtin_object_size(tls, bp, 0))
				libc.X__builtin___memcpy_chk(tls, cur_key, key, cpy_len, libc.X__builtin_object_size(tls, cur_key, 0))
				libc.X__builtin___memcpy_chk(tls, key, bp, cpy_len, libc.X__builtin_object_size(tls, key, 0))

				libc.X__builtin___memcpy_chk(tls, bp, (*Yyjson_mut_val)(unsafe.Pointer(cur_key)).Next, cpy_len, libc.X__builtin_object_size(tls, bp, 0))
				libc.X__builtin___memcpy_chk(tls, (*Yyjson_mut_val)(unsafe.Pointer(cur_key)).Next, val, cpy_len, libc.X__builtin_object_size(tls, (*Yyjson_mut_val)(unsafe.Pointer(cur_key)).Next, 0))
				libc.X__builtin___memcpy_chk(tls, val, bp, cpy_len, libc.X__builtin_object_size(tls, val, 0))
				return uint8(True)
			} else {
				pre_key = cur_key
				cur_key = (*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(cur_key)).Next)).Next
			}
		}
	}
	return uint8(False)
}

func Unsafe_yyjson_mut_obj_rotate(tls *libc.TLS, obj uintptr, idx Size_t) { /* yyjson.h:3910:24: */
	var key uintptr = *(*uintptr)(unsafe.Pointer(obj + 8))
	for libc.PostDecUint64(&idx, 1) > uint64(0) {
		key = (*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(key)).Next)).Next
	}
	*(*uintptr)(unsafe.Pointer(obj + 8)) = key
}

func Yyjson_mut_obj_add(tls *libc.TLS, obj uintptr, key uintptr, val uintptr) uint8 { /* yyjson.h:3917:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_obj(tls, obj) != 0 && Yyjson_mut_is_str(tls, key) != 0 && val != 0)), int64(1)) != 0 {
		Unsafe_yyjson_mut_obj_add(tls, obj, key, val, Unsafe_yyjson_get_len(tls, obj))
		return uint8(True)
	}
	return uint8(False)
}

func Yyjson_mut_obj_put(tls *libc.TLS, obj uintptr, key uintptr, val uintptr) uint8 { /* yyjson.h:3928:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_obj(tls, obj) != 0 && Yyjson_mut_is_str(tls, key) != 0)), int64(1)) != 0 {
		Unsafe_yyjson_mut_obj_remove(tls, obj, *(*uintptr)(unsafe.Pointer(key + 8)),
			Unsafe_yyjson_get_len(tls, key), (*Yyjson_mut_val)(unsafe.Pointer(key)).Tag)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(val != 0)), int64(1)) != 0 {
			Unsafe_yyjson_mut_obj_add(tls, obj, key, val,
				Unsafe_yyjson_get_len(tls, obj))
		}
		return uint8(True)
	}
	return uint8(False)
}

func Yyjson_mut_obj_insert(tls *libc.TLS, obj uintptr, key uintptr, val uintptr, idx Size_t) uint8 { /* yyjson.h:3944:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_obj(tls, obj) != 0 && Yyjson_mut_is_str(tls, key) != 0 && val != 0)), int64(1)) != 0 {
		var len Size_t = Unsafe_yyjson_get_len(tls, obj)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(len >= idx)), int64(1)) != 0 {
			if len > idx {
				var ptr uintptr = *(*uintptr)(unsafe.Pointer(obj + 8))
				Unsafe_yyjson_mut_obj_rotate(tls, obj, idx)
				Unsafe_yyjson_mut_obj_add(tls, obj, key, val, len)
				*(*uintptr)(unsafe.Pointer(obj + 8)) = ptr
			} else {
				Unsafe_yyjson_mut_obj_add(tls, obj, key, val, len)
			}
			return uint8(True)
		}
	}
	return uint8(False)
}

func Yyjson_mut_obj_remove(tls *libc.TLS, obj uintptr, key uintptr) uintptr { /* yyjson.h:3966:34: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_obj(tls, obj) != 0 && Yyjson_mut_is_str(tls, key) != 0)), int64(1)) != 0 {
		return Unsafe_yyjson_mut_obj_remove(tls, obj, *(*uintptr)(unsafe.Pointer(key + 8)),
			Unsafe_yyjson_get_len(tls, key), (*Yyjson_mut_val)(unsafe.Pointer(key)).Tag)
	}
	return uintptr(0)
}

func Yyjson_mut_obj_clear(tls *libc.TLS, obj uintptr) uint8 { /* yyjson.h:3975:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_obj(tls, obj) != 0)), int64(1)) != 0 {
		Unsafe_yyjson_set_len(tls, obj, uint64(0))
		return uint8(True)
	}
	return uint8(False)
}

func Yyjson_mut_obj_replace(tls *libc.TLS, obj uintptr, key uintptr, val uintptr) uint8 { /* yyjson.h:3983:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_obj(tls, obj) != 0 && Yyjson_mut_is_str(tls, key) != 0 && val != 0)), int64(1)) != 0 {
		return Unsafe_yyjson_mut_obj_replace(tls, obj, key, val)
	}
	return uint8(False)
}

func Yyjson_mut_obj_rotate(tls *libc.TLS, obj uintptr, idx Size_t) uint8 { /* yyjson.h:3993:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_obj(tls, obj) != 0 && Unsafe_yyjson_get_len(tls, obj) > idx)), int64(1)) != 0 {
		Unsafe_yyjson_mut_obj_rotate(tls, obj, idx)
		return uint8(True)
	}
	return uint8(False)
}

// ==============================================================================
// Mutable JSON Object Modification Convenience API (Implementation)
//============================================================================

func Yyjson_mut_obj_add_null(tls *libc.TLS, doc uintptr, obj uintptr, _key uintptr) uint8 { /* yyjson.h:4025:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_obj(tls, obj) != 0 && _key != 0)), int64(1)) != 0 {
		var key uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(2))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(key != 0)), int64(1)) != 0 {
			var len Size_t = Unsafe_yyjson_get_len(tls, obj)
			var val uintptr = key + uintptr(1)*24
			(*Yyjson_mut_val)(unsafe.Pointer(key)).Tag = uint64(int32(Uint8_t(5)) | int32(Uint8_t(int32(0)<<3)))
			*(*Uint64_t)(unsafe.Pointer(key)) |= Uint64_t(libc.Xstrlen(tls, _key)) << int32(Uint8_t(8))
			*(*uintptr)(unsafe.Pointer(key + 8)) = _key
			{
				(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(2)) | int32(Uint8_t(int32(0)<<3)))
			}
			Unsafe_yyjson_mut_obj_add(tls, obj, key, val, len)
			return uint8(True)
		}
	}
	return uint8(False)
}

func Yyjson_mut_obj_add_true(tls *libc.TLS, doc uintptr, obj uintptr, _key uintptr) uint8 { /* yyjson.h:4033:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_obj(tls, obj) != 0 && _key != 0)), int64(1)) != 0 {
		var key uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(2))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(key != 0)), int64(1)) != 0 {
			var len Size_t = Unsafe_yyjson_get_len(tls, obj)
			var val uintptr = key + uintptr(1)*24
			(*Yyjson_mut_val)(unsafe.Pointer(key)).Tag = uint64(int32(Uint8_t(5)) | int32(Uint8_t(int32(0)<<3)))
			*(*Uint64_t)(unsafe.Pointer(key)) |= Uint64_t(libc.Xstrlen(tls, _key)) << int32(Uint8_t(8))
			*(*uintptr)(unsafe.Pointer(key + 8)) = _key
			{
				(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(3)) | int32(Uint8_t(int32(1)<<3)))
			}
			Unsafe_yyjson_mut_obj_add(tls, obj, key, val, len)
			return uint8(True)
		}
	}
	return uint8(False)
}

func Yyjson_mut_obj_add_false(tls *libc.TLS, doc uintptr, obj uintptr, _key uintptr) uint8 { /* yyjson.h:4041:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_obj(tls, obj) != 0 && _key != 0)), int64(1)) != 0 {
		var key uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(2))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(key != 0)), int64(1)) != 0 {
			var len Size_t = Unsafe_yyjson_get_len(tls, obj)
			var val uintptr = key + uintptr(1)*24
			(*Yyjson_mut_val)(unsafe.Pointer(key)).Tag = uint64(int32(Uint8_t(5)) | int32(Uint8_t(int32(0)<<3)))
			*(*Uint64_t)(unsafe.Pointer(key)) |= Uint64_t(libc.Xstrlen(tls, _key)) << int32(Uint8_t(8))
			*(*uintptr)(unsafe.Pointer(key + 8)) = _key
			{
				(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(3)) | int32(Uint8_t(int32(0)<<3)))
			}
			Unsafe_yyjson_mut_obj_add(tls, obj, key, val, len)
			return uint8(True)
		}
	}
	return uint8(False)
}

func Yyjson_mut_obj_add_bool(tls *libc.TLS, doc uintptr, obj uintptr, _key uintptr, _val uint8) uint8 { /* yyjson.h:4049:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_obj(tls, obj) != 0 && _key != 0)), int64(1)) != 0 {
		var key uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(2))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(key != 0)), int64(1)) != 0 {
			var len Size_t = Unsafe_yyjson_get_len(tls, obj)
			var val uintptr = key + uintptr(1)*24
			(*Yyjson_mut_val)(unsafe.Pointer(key)).Tag = uint64(int32(Uint8_t(5)) | int32(Uint8_t(int32(0)<<3)))
			*(*Uint64_t)(unsafe.Pointer(key)) |= Uint64_t(libc.Xstrlen(tls, _key)) << int32(Uint8_t(8))
			*(*uintptr)(unsafe.Pointer(key + 8)) = _key
			{
				(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(3)) | int32(Uint8_t(int32(Uint8_t(_val))<<3)))
			}
			Unsafe_yyjson_mut_obj_add(tls, obj, key, val, len)
			return uint8(True)
		}
	}
	return uint8(False)
}

func Yyjson_mut_obj_add_uint(tls *libc.TLS, doc uintptr, obj uintptr, _key uintptr, _val Uint64_t) uint8 { /* yyjson.h:4058:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_obj(tls, obj) != 0 && _key != 0)), int64(1)) != 0 {
		var key uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(2))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(key != 0)), int64(1)) != 0 {
			var len Size_t = Unsafe_yyjson_get_len(tls, obj)
			var val uintptr = key + uintptr(1)*24
			(*Yyjson_mut_val)(unsafe.Pointer(key)).Tag = uint64(int32(Uint8_t(5)) | int32(Uint8_t(int32(0)<<3)))
			*(*Uint64_t)(unsafe.Pointer(key)) |= Uint64_t(libc.Xstrlen(tls, _key)) << int32(Uint8_t(8))
			*(*uintptr)(unsafe.Pointer(key + 8)) = _key
			{
				(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(0)<<3)))
				*(*Uint64_t)(unsafe.Pointer(val + 8)) = _val
			}
			Unsafe_yyjson_mut_obj_add(tls, obj, key, val, len)
			return uint8(True)
		}
	}
	return uint8(False)
}

func Yyjson_mut_obj_add_sint(tls *libc.TLS, doc uintptr, obj uintptr, _key uintptr, _val Int64_t) uint8 { /* yyjson.h:4068:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_obj(tls, obj) != 0 && _key != 0)), int64(1)) != 0 {
		var key uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(2))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(key != 0)), int64(1)) != 0 {
			var len Size_t = Unsafe_yyjson_get_len(tls, obj)
			var val uintptr = key + uintptr(1)*24
			(*Yyjson_mut_val)(unsafe.Pointer(key)).Tag = uint64(int32(Uint8_t(5)) | int32(Uint8_t(int32(0)<<3)))
			*(*Uint64_t)(unsafe.Pointer(key)) |= Uint64_t(libc.Xstrlen(tls, _key)) << int32(Uint8_t(8))
			*(*uintptr)(unsafe.Pointer(key + 8)) = _key
			{
				(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(1)<<3)))
				*(*Int64_t)(unsafe.Pointer(val + 8)) = _val
			}
			Unsafe_yyjson_mut_obj_add(tls, obj, key, val, len)
			return uint8(True)
		}
	}
	return uint8(False)
}

func Yyjson_mut_obj_add_int(tls *libc.TLS, doc uintptr, obj uintptr, _key uintptr, _val Int64_t) uint8 { /* yyjson.h:4078:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_obj(tls, obj) != 0 && _key != 0)), int64(1)) != 0 {
		var key uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(2))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(key != 0)), int64(1)) != 0 {
			var len Size_t = Unsafe_yyjson_get_len(tls, obj)
			var val uintptr = key + uintptr(1)*24
			(*Yyjson_mut_val)(unsafe.Pointer(key)).Tag = uint64(int32(Uint8_t(5)) | int32(Uint8_t(int32(0)<<3)))
			*(*Uint64_t)(unsafe.Pointer(key)) |= Uint64_t(libc.Xstrlen(tls, _key)) << int32(Uint8_t(8))
			*(*uintptr)(unsafe.Pointer(key + 8)) = _key
			{
				(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(1)<<3)))
				*(*Int64_t)(unsafe.Pointer(val + 8)) = _val
			}
			Unsafe_yyjson_mut_obj_add(tls, obj, key, val, len)
			return uint8(True)
		}
	}
	return uint8(False)
}

func Yyjson_mut_obj_add_real(tls *libc.TLS, doc uintptr, obj uintptr, _key uintptr, _val float64) uint8 { /* yyjson.h:4088:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_obj(tls, obj) != 0 && _key != 0)), int64(1)) != 0 {
		var key uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(2))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(key != 0)), int64(1)) != 0 {
			var len Size_t = Unsafe_yyjson_get_len(tls, obj)
			var val uintptr = key + uintptr(1)*24
			(*Yyjson_mut_val)(unsafe.Pointer(key)).Tag = uint64(int32(Uint8_t(5)) | int32(Uint8_t(int32(0)<<3)))
			*(*Uint64_t)(unsafe.Pointer(key)) |= Uint64_t(libc.Xstrlen(tls, _key)) << int32(Uint8_t(8))
			*(*uintptr)(unsafe.Pointer(key + 8)) = _key
			{
				(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
				*(*float64)(unsafe.Pointer(val + 8)) = _val
			}
			Unsafe_yyjson_mut_obj_add(tls, obj, key, val, len)
			return uint8(True)
		}
	}
	return uint8(False)
}

func Yyjson_mut_obj_add_str(tls *libc.TLS, doc uintptr, obj uintptr, _key uintptr, _val uintptr) uint8 { /* yyjson.h:4098:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(_val != 0)), int64(0)) != 0 {
		return uint8(False)
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_obj(tls, obj) != 0 && _key != 0)), int64(1)) != 0 {
		var key uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(2))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(key != 0)), int64(1)) != 0 {
			var len Size_t = Unsafe_yyjson_get_len(tls, obj)
			var val uintptr = key + uintptr(1)*24
			(*Yyjson_mut_val)(unsafe.Pointer(key)).Tag = uint64(int32(Uint8_t(5)) | int32(Uint8_t(int32(0)<<3)))
			*(*Uint64_t)(unsafe.Pointer(key)) |= Uint64_t(libc.Xstrlen(tls, _key)) << int32(Uint8_t(8))
			*(*uintptr)(unsafe.Pointer(key + 8)) = _key
			{
				(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = Uint64_t(libc.Xstrlen(tls, _val))<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
				*(*uintptr)(unsafe.Pointer(val + 8)) = _val
			}
			Unsafe_yyjson_mut_obj_add(tls, obj, key, val, len)
			return uint8(True)
		}
	}
	return uint8(False)
}

func Yyjson_mut_obj_add_strn(tls *libc.TLS, doc uintptr, obj uintptr, _key uintptr, _val uintptr, _len Size_t) uint8 { /* yyjson.h:4109:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(_val != 0)), int64(0)) != 0 {
		return uint8(False)
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_obj(tls, obj) != 0 && _key != 0)), int64(1)) != 0 {
		var key uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(2))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(key != 0)), int64(1)) != 0 {
			var len Size_t = Unsafe_yyjson_get_len(tls, obj)
			var val uintptr = key + uintptr(1)*24
			(*Yyjson_mut_val)(unsafe.Pointer(key)).Tag = uint64(int32(Uint8_t(5)) | int32(Uint8_t(int32(0)<<3)))
			*(*Uint64_t)(unsafe.Pointer(key)) |= Uint64_t(libc.Xstrlen(tls, _key)) << int32(Uint8_t(8))
			*(*uintptr)(unsafe.Pointer(key + 8)) = _key
			{
				(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = Uint64_t(_len)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
				*(*uintptr)(unsafe.Pointer(val + 8)) = _val
			}
			Unsafe_yyjson_mut_obj_add(tls, obj, key, val, len)
			return uint8(True)
		}
	}
	return uint8(False)
}

func Yyjson_mut_obj_add_strcpy(tls *libc.TLS, doc uintptr, obj uintptr, _key uintptr, _val uintptr) uint8 { /* yyjson.h:4121:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(_val != 0)), int64(0)) != 0 {
		return uint8(False)
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_obj(tls, obj) != 0 && _key != 0)), int64(1)) != 0 {
		var key uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(2))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(key != 0)), int64(1)) != 0 {
			var len Size_t = Unsafe_yyjson_get_len(tls, obj)
			var val uintptr = key + uintptr(1)*24
			(*Yyjson_mut_val)(unsafe.Pointer(key)).Tag = uint64(int32(Uint8_t(5)) | int32(Uint8_t(int32(0)<<3)))
			*(*Uint64_t)(unsafe.Pointer(key)) |= Uint64_t(libc.Xstrlen(tls, _key)) << int32(Uint8_t(8))
			*(*uintptr)(unsafe.Pointer(key + 8)) = _key
			{
				var _len Size_t = libc.Xstrlen(tls, _val)
				*(*uintptr)(unsafe.Pointer(val + 8)) = Unsafe_yyjson_mut_strncpy(tls, doc, _val, _len)
				if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(*(*uintptr)(unsafe.Pointer(val + 8))) != 0)), int64(0)) != 0 {
					return uint8(False)
				}
				(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = Uint64_t(_len)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
			}
			Unsafe_yyjson_mut_obj_add(tls, obj, key, val, len)
			return uint8(True)
		}
	}
	return uint8(False)
}

func Yyjson_mut_obj_add_strncpy(tls *libc.TLS, doc uintptr, obj uintptr, _key uintptr, _val uintptr, _len Size_t) uint8 { /* yyjson.h:4134:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(_val != 0)), int64(0)) != 0 {
		return uint8(False)
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_obj(tls, obj) != 0 && _key != 0)), int64(1)) != 0 {
		var key uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(2))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(key != 0)), int64(1)) != 0 {
			var len Size_t = Unsafe_yyjson_get_len(tls, obj)
			var val uintptr = key + uintptr(1)*24
			(*Yyjson_mut_val)(unsafe.Pointer(key)).Tag = uint64(int32(Uint8_t(5)) | int32(Uint8_t(int32(0)<<3)))
			*(*Uint64_t)(unsafe.Pointer(key)) |= Uint64_t(libc.Xstrlen(tls, _key)) << int32(Uint8_t(8))
			*(*uintptr)(unsafe.Pointer(key + 8)) = _key
			{
				*(*uintptr)(unsafe.Pointer(val + 8)) = Unsafe_yyjson_mut_strncpy(tls, doc, _val, _len)
				if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(int32(*(*uintptr)(unsafe.Pointer(val + 8))) != 0)), int64(0)) != 0 {
					return uint8(False)
				}
				(*Yyjson_mut_val)(unsafe.Pointer(val)).Tag = Uint64_t(_len)<<int32(Uint8_t(8)) | Uint64_t(Uint8_t(5))
			}
			Unsafe_yyjson_mut_obj_add(tls, obj, key, val, len)
			return uint8(True)
		}
	}
	return uint8(False)
}

func Yyjson_mut_obj_add_val(tls *libc.TLS, doc uintptr, obj uintptr, _key uintptr, _val uintptr) uint8 { /* yyjson.h:4147:24: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(_val != 0)), int64(0)) != 0 {
		return uint8(False)
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0 && Yyjson_mut_is_obj(tls, obj) != 0 && _key != 0)), int64(1)) != 0 {
		var key uintptr = Unsafe_yyjson_mut_val(tls, doc, uint64(2))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(key != 0)), int64(1)) != 0 {
			var len Size_t = Unsafe_yyjson_get_len(tls, obj)
			var val uintptr = key + uintptr(1)*24
			(*Yyjson_mut_val)(unsafe.Pointer(key)).Tag = uint64(int32(Uint8_t(5)) | int32(Uint8_t(int32(0)<<3)))
			*(*Uint64_t)(unsafe.Pointer(key)) |= Uint64_t(libc.Xstrlen(tls, _key)) << int32(Uint8_t(8))
			*(*uintptr)(unsafe.Pointer(key + 8)) = _key
			{
				val = _val
			}
			Unsafe_yyjson_mut_obj_add(tls, obj, key, val, len)
			return uint8(True)
		}
	}
	return uint8(False)
}

func Yyjson_mut_obj_remove_str(tls *libc.TLS, obj uintptr, key uintptr) uintptr { /* yyjson.h:4157:34: */
	return Yyjson_mut_obj_remove_strn(tls, obj, key, func() uint64 {
		if key != 0 {
			return libc.Xstrlen(tls, key)
		}
		return uint64(0)
	}())
}

func Yyjson_mut_obj_remove_strn(tls *libc.TLS, obj uintptr, _key uintptr, _len Size_t) uintptr { /* yyjson.h:4162:34: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Yyjson_mut_is_obj(tls, obj) != 0 && _key != 0)), int64(1)) != 0 {
		var key uintptr
		// var iter Yyjson_mut_obj_iter at bp, 40

		var val_removed uintptr = uintptr(0)
		Yyjson_mut_obj_iter_init(tls, obj, bp)
		for libc.AssignUintptr(&key, Yyjson_mut_obj_iter_next(tls, bp)) != uintptr(0) {
			if Unsafe_yyjson_get_len(tls, key) == _len && libc.Xmemcmp(tls, *(*uintptr)(unsafe.Pointer(key + 8)), _key, _len) == 0 {
				if !(val_removed != 0) {
					val_removed = (*Yyjson_mut_val)(unsafe.Pointer(key)).Next
				}
				Yyjson_mut_obj_iter_remove(tls, bp)
			}
		}
		return val_removed
	}
	return uintptr(0)
}

func Yyjson_get_pointer(tls *libc.TLS, val uintptr, ptr uintptr) uintptr { /* yyjson.h:4197:30: */
	if val != 0 && ptr != 0 {
		if int32(*(*int8)(unsafe.Pointer(ptr))) == 0 {
			return val
		}
		if int32(*(*int8)(unsafe.Pointer(ptr))) != '/' {
			return uintptr(0)
		}
		return Unsafe_yyjson_get_pointer(tls, val, ptr, libc.Xstrlen(tls, ptr))
	}
	return uintptr(0)
}

func Yyjson_doc_get_pointer(tls *libc.TLS, doc uintptr, ptr uintptr) uintptr { /* yyjson.h:4207:30: */
	if doc != 0 {
		return Yyjson_get_pointer(tls, (*Yyjson_doc)(unsafe.Pointer(doc)).Root, ptr)
	}
	return uintptr(0)
}

func Yyjson_mut_get_pointer(tls *libc.TLS, val uintptr, ptr uintptr) uintptr { /* yyjson.h:4213:34: */
	if val != 0 && ptr != 0 {
		if int32(*(*int8)(unsafe.Pointer(ptr))) == 0 {
			return val
		}
		if int32(*(*int8)(unsafe.Pointer(ptr))) != '/' {
			return uintptr(0)
		}
		return Unsafe_yyjson_mut_get_pointer(tls, val, ptr, libc.Xstrlen(tls, ptr))
	}
	return uintptr(0)
}

func Yyjson_mut_doc_get_pointer(tls *libc.TLS, doc uintptr, ptr uintptr) uintptr { /* yyjson.h:4223:34: */
	if doc != 0 {
		return Yyjson_mut_get_pointer(tls, (*Yyjson_mut_doc)(unsafe.Pointer(doc)).Root, ptr)
	}
	return uintptr(0)
}

// ==============================================================================
// Compiler Hint End
//============================================================================

// Copyright (c) 2000, 2005, 2007, 2009, 2010 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Chris Torek.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdio.h	8.5 (Berkeley) 4/29/95

// Copyright (c) 2000, 2005, 2007, 2009, 2010 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@
// -
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Chris Torek.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdio.h	8.5 (Berkeley) 4/29/95

// Common header for stdio.h and xlocale/_stdio.h

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Copyright (c) 2004, 2008, 2009 Apple Inc. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// DO NOT REMOVE THIS COMMENT: fixincludes needs to see:
// __gnuc_va_list and include <stdarg.h>
// Copyright (c) 2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Va_list = X__darwin_va_list /* _va_list.h:32:26 */

type Fpos_t = X__darwin_off_t /* _stdio.h:81:25 */

// NB: to fit things in six character monocase externals, the stdio
// code uses the prefix `__s' for stdio objects, typically followed
// by a three-character attempt at a mnemonic.

// stdio buffers
type X__sbuf = struct {
	X_base      uintptr
	X_size      int32
	__ccgo_pad1 [4]byte
} /* _stdio.h:92:1 */

// stdio state variables.
//
// The following always hold:
//
//	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
//		_lbfsize is -_bf._size, else _lbfsize is 0
//	if _flags&__SRD, _w is 0
//	if _flags&__SWR, _r is 0
//
// This ensures that the getc and putc macros (or inline functions) never
// try to write or read from a file that is in `read' or `write' mode.
// (Moreover, they can, and do, automatically switch from read mode to
// write mode, and back, on "r+" and "w+" files.)
//
// _lbfsize is used only to make the inline line-buffered output stream
// code as compact as possible.
//
// _ub, _up, and _ur are used when ungetc() pushes back more characters
// than fit in the current _bf, or when ungetc() pushes back a character
// that does not match the previous one in _bf.  When this happens,
// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
//
// NB: see WARNING above before changing the layout of this structure!
type X__sFILE = struct {
	X_p         uintptr
	X_r         int32
	X_w         int32
	X_flags     int16
	X_file      int16
	__ccgo_pad1 [4]byte
	X_bf        struct {
		X_base      uintptr
		X_size      int32
		__ccgo_pad1 [4]byte
	}
	X_lbfsize   int32
	__ccgo_pad2 [4]byte
	X_cookie    uintptr
	X_close     uintptr
	X_read      uintptr
	X_seek      uintptr
	X_write     uintptr
	X_ub        struct {
		X_base      uintptr
		X_size      int32
		__ccgo_pad1 [4]byte
	}
	X_extra uintptr
	X_ur    int32
	X_ubuf  [3]uint8
	X_nbuf  [1]uint8
	X_lb    struct {
		X_base      uintptr
		X_size      int32
		__ccgo_pad1 [4]byte
	}
	X_blksize   int32
	__ccgo_pad3 [4]byte
	X_offset    Fpos_t
} /* _stdio.h:126:9 */

// stdio state variables.
//
// The following always hold:
//
//	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
//		_lbfsize is -_bf._size, else _lbfsize is 0
//	if _flags&__SRD, _w is 0
//	if _flags&__SWR, _r is 0
//
// This ensures that the getc and putc macros (or inline functions) never
// try to write or read from a file that is in `read' or `write' mode.
// (Moreover, they can, and do, automatically switch from read mode to
// write mode, and back, on "r+" and "w+" files.)
//
// _lbfsize is used only to make the inline line-buffered output stream
// code as compact as possible.
//
// _ub, _up, and _ur are used when ungetc() pushes back more characters
// than fit in the current _bf, or when ungetc() pushes back a character
// that does not match the previous one in _bf.  When this happens,
// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
//
// NB: see WARNING above before changing the layout of this structure!
type FILE = X__sFILE /* _stdio.h:157:3 */

// Additional functionality provided by:
// POSIX.1-2001
// ISO C99

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Off_t = X__darwin_off_t /* _off_t.h:31:33 */

// ==============================================================================
// Compile Hint Begin
//============================================================================

// warning suppress begin

// version, same as YYJSON_VERSION_HEX
func Yyjson_version(tls *libc.TLS) Uint32_t { /* yyjson.c:43:21: */
	return Uint32_t(YYJSON_VERSION_HEX)
}

// ==============================================================================
// Flags
//============================================================================

// gcc version check

// real gcc check

// msvc intrinsic

// gcc builtin

// int128 type

// IEEE 754 floating-point binary representation

//
//  Correct rounding in double number computations.
//
//  On the x86 architecture, some compilers may use x87 FPU instructions for
//  floating-point arithmetic. The x87 FPU loads all floating point number as
//  80-bit double-extended precision internally, then rounds the result to original
//  precision, which may produce inaccurate results. For a more detailed
//  explanation, see the paper: https://arxiv.org/abs/cs/0701192
//
//  Here are some examples of double precision calculation error:
//
//      2877.0 / 1e6   == 0.002877,  but x87 returns 0.0028770000000000002
//      43683.0 * 1e21 == 4.3683e25, but x87 returns 4.3683000000000004e25
//
//  Here are some examples of compiler flags to generate x87 instructions on x86:
//
//      clang -m32 -mno-sse
//      gcc/icc -m32 -mfpmath=387
//      msvc /arch:SSE or /arch:IA32
//
//  If we are sure that there's no similar error described above, we can define the
//  YYJSON_DOUBLE_MATH_CORRECT as 1 to enable the fast path calculation. This is
//  not an accurate detection, it's just try to avoid the error at compiler time.
//  An accurate detection can be done at runtime:
//
//      bool is_double_math_correct(void) {
//          volatile double r = 43683.0;
//          r *= 1e21;
//          return r == 4.3683e25;
//      }
//
//

//
//  Microsoft Visual C++ 6.0 doesn't support converting number from u64 to f64:
//  error C2520: conversion from unsigned __int64 to double not implemented.
//

// endian
// Copyright (c) 2000-2008 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 1995 NeXT Computer, Inc. All Rights Reserved
// Copyright (c) 1982, 1986, 1991, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)types.h	8.4 (Berkeley) 1/21/94

// Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2018 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//	This product includes software developed by the University of
//	California, Berkeley and its contributors.
// 4. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

// Machine type dependent parameters.
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

// Copyright (c) 2017 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_char = uint8 /* _u_char.h:30:25 */
// Copyright (c) 2017 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_short = uint16 /* _u_short.h:30:25 */
// Copyright (c) 2017 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type U_int = uint32  /* _u_int.h:30:25 */
type U_long = uint64 /* types.h:88:33 */
type Ushort = uint16 /* types.h:91:33 */ // Sys V compatibility
type Uint = uint32   /* types.h:92:33 */ // Sys V compatibility

type U_quad_t = U_int64_t /* types.h:95:33 */ // quads
type Quad_t = Int64_t     /* types.h:96:33 */
type Qaddr_t = uintptr    /* types.h:97:16 */

// Copyright (c) 2017 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
type Caddr_t = uintptr /* _caddr_t.h:30:14 */

type Daddr_t = Int32_t /* types.h:101:33 */ // disk address

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Fixpt_t = U_int32_t /* types.h:105:33 */ // fixed point number

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Blkcnt_t = X__darwin_blkcnt_t /* _blkcnt_t.h:31:34 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Blksize_t = X__darwin_blksize_t /* _blksize_t.h:31:35 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Gid_t = X__darwin_gid_t /* _gid_t.h:31:25 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type In_addr_t = X__uint32_t /* _in_addr_t.h:31:25 */ // base type for internet address
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type In_port_t = X__uint16_t /* _in_port_t.h:31:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Ino_t = X__darwin_ino_t /* _ino_t.h:31:33 */ // inode number

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Ino64_t = X__darwin_ino64_t /* _ino64_t.h:31:33 */ // 64bit inode number

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Key_t = X__int32_t /* _key_t.h:31:26 */ // IPC key (for Sys V IPC)
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Nlink_t = X__uint16_t /* _nlink_t.h:31:27 */ // link count
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Segsz_t = Int32_t /* types.h:125:33 */ // segment size
type Swblk_t = Int32_t /* types.h:126:33 */ // swap offset

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Major, minor numbers, dev_t's.

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Clock_t = X__darwin_clock_t /* _clock_t.h:31:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
type Time_t = X__darwin_time_t /* _time_t.h:31:33 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Useconds_t = X__darwin_useconds_t /* _useconds_t.h:31:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Suseconds_t = X__darwin_suseconds_t /* _suseconds_t.h:31:33 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// This code is present here in order to maintain historical backward
// compatability, and is intended to be removed at some point in the
// future; please include <sys/select.h> instead.
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Select uses bit masks of file descriptors in longs.  These macros
// manipulate such bit fields (the filesystem macros use chars).  The
// extra protection here is to permit application redefinition above
// the default size.

type Fd_set1 = struct{ Fds_bits [32]X__int32_t } /* _fd_def.h:50:9 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// This code is present here in order to maintain historical backward
// compatability, and is intended to be removed at some point in the
// future; please include <sys/select.h> instead.
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.
// Copyright (c) 2007-2016 by Apple Inc.. All rights reserved.
//
// @APPLE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this
// file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_LICENSE_HEADER_END@

// Select uses bit masks of file descriptors in longs.  These macros
// manipulate such bit fields (the filesystem macros use chars).  The
// extra protection here is to permit application redefinition above
// the default size.

type Fd_set = Fd_set1 /* _fd_def.h:52:3 */

func X__darwin_check_fd_set(tls *libc.TLS, _a int32, _b uintptr) int32 { /* _fd_def.h:58:1: */
	if Uintptr_t(uintptr(unsafe.Pointer(&X__darwin_check_fd_set_overflow))) != uint64(0) {
		return (*struct {
			f func(*libc.TLS, int32, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{X__darwin_check_fd_set_overflow})).f(tls, _a, _b, 0)
	} else {
		return 1
	}
	return int32(0)
}

// This inline avoids argument side-effect issues with FD_ISSET()
func X__darwin_fd_isset(tls *libc.TLS, _fd int32, _p uintptr) int32 { /* _fd_def.h:80:1: */
	if X__darwin_check_fd_set(tls, _fd, _p) != 0 {
		return *(*X__int32_t)(unsafe.Pointer(_p + uintptr(uint64(_fd)/(uint64(unsafe.Sizeof(X__int32_t(0)))*uint64(8)))*4)) & X__int32_t(uint64(uint64(1))<<(uint64(_fd)%(uint64(unsafe.Sizeof(X__int32_t(0)))*uint64(8))))
	}

	return 0
}

func X__darwin_fd_set(tls *libc.TLS, _fd int32, _p uintptr) { /* _fd_def.h:90:1: */
	if X__darwin_check_fd_set(tls, _fd, _p) != 0 {
		*(*X__int32_t)(unsafe.Pointer(_p + uintptr(uint64(_fd)/(uint64(unsafe.Sizeof(X__int32_t(0)))*uint64(8)))*4)) |= X__int32_t(uint64(uint64(1)) << (uint64(_fd) % (uint64(unsafe.Sizeof(X__int32_t(0))) * uint64(8))))
	}
}

func X__darwin_fd_clr(tls *libc.TLS, _fd int32, _p uintptr) { /* _fd_def.h:98:1: */
	if X__darwin_check_fd_set(tls, _fd, _p) != 0 {
		*(*X__int32_t)(unsafe.Pointer(_p + uintptr(uint64(_fd)/(uint64(unsafe.Sizeof(X__int32_t(0)))*uint64(8)))*4)) &= ^X__int32_t(uint64(uint64(1)) << (uint64(_fd) % (uint64(unsafe.Sizeof(X__int32_t(0))) * uint64(8))))
	}
}

// Use the built-in bzero function instead of the library version so that
// we do not pollute the namespace or introduce prototype warnings.

type Fd_mask = X__int32_t /* types.h:189:25 */

// Select uses bit masks of file descriptors in longs.  These macros
// manipulate such bit fields (the filesystem macros use chars).  The
// extra protection here is to permit application redefinition above
// the default size.
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_cond_t = X__darwin_pthread_cond_t /* _pthread_cond_t.h:31:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_condattr_t = X__darwin_pthread_condattr_t /* _pthread_condattr_t.h:31:37 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_mutex_t = X__darwin_pthread_mutex_t /* _pthread_mutex_t.h:31:34 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_mutexattr_t = X__darwin_pthread_mutexattr_t /* _pthread_mutexattr_t.h:31:38 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_once_t = X__darwin_pthread_once_t /* _pthread_once_t.h:31:33 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_rwlock_t = X__darwin_pthread_rwlock_t /* _pthread_rwlock_t.h:31:35 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_rwlockattr_t = X__darwin_pthread_rwlockattr_t /* _pthread_rwlockattr_t.h:31:39 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_t = X__darwin_pthread_t /* _pthread_t.h:31:28 */

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2013 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Pthread_key_t = X__darwin_pthread_key_t /* _pthread_key_t.h:31:32 */

// statvfs and fstatvfs

// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Fsblkcnt_t = X__darwin_fsblkcnt_t /* _fsblkcnt_t.h:31:41 */
// Copyright (c) 2003-2012 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright (c) 2003-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@

type Fsfilcnt_t = X__darwin_fsfilcnt_t /* _fsfilcnt_t.h:31:41 */

// Copyright (c) 2000-2007 Apple Inc. All rights reserved.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_START@
//
// This file contains Original Code and/or Modifications of Original Code
// as defined in and that are subject to the Apple Public Source License
// Version 2.0 (the 'License'). You may not use this file except in
// compliance with the License. The rights granted to you under the License
// may not be used to create, or enable the creation or redistribution of,
// unlawful or unlicensed copies of an Apple operating system, or to
// circumvent, violate, or enable the circumvention or violation of, any
// terms of an Apple operating system software license agreement.
//
// Please obtain a copy of the License at
// http://www.opensource.apple.com/apsl/ and read it before using this file.
//
// The Original Code and all software distributed under the License are
// distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
// EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
// INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
// Please see the License for the specific language governing rights and
// limitations under the License.
//
// @APPLE_OSREFERENCE_LICENSE_HEADER_END@
// Copyright 1995 NeXT Computer, Inc. All rights reserved.

//
//  Unaligned memory access detection.
//
//  Some architectures are unable to perform unaligned memory accesses, and the
//  unaligned access may cause processor exceptions.
//
//  Modern compilers can make some optimizations for unaligned access.
//  For example: https://godbolt.org/z/Ejo3Pa
//
//     typedef struct { char c[2] } vec2;
//     void copy_vec2(vec2 *dst, vec2 *src) {
//         *dst = *src;
//     }
//
//  Compiler may generate `load/store` or `move` instruction if target architecture
//  supports unaligned access, otherwise it may generate `call memcpy` instruction.
//
//  We want to avoid `memcpy` calls, so we should disable unaligned access by
//  define `YYJSON_DISABLE_UNALIGNED_MEMORY_ACCESS` as 1 on these architectures.
//

// Some estimated initial ratio of the JSON data (data_size / value_count).
//    These values are used to avoid frequent memory allocation calls.

// Default value for public flags.

// ==============================================================================
// Macros
//============================================================================

// Macros used for loop unrolling and other purpose.

// Macros used to provide branch prediction information for compiler.

// Macros used to provide inline information for compiler.

// Macros for min and max.

// Used to write u64 literal for C89 which doesn't support "ULL" suffix.

// ==============================================================================
// Integer Constants
//============================================================================

// U64 constant values

// Maximum number of digits for reading u64 safety.

// ==============================================================================
// IEEE-754 Double Number Constants
//============================================================================

// Inf raw value (positive)

// NaN raw value (positive, without payload)

// double number bits

// double number exponent part bits

// double number significand part bits

// double number significand part bits (with 1 hidden bit)

// double number significand bit mask

// double number exponent bit mask

// double number exponent bias

// double number significant digits count in decimal

// max significant digits count in decimal when reading double number

// maximum decimal power of double number (1.7976931348623157e308)

// minimum decimal power of double number (4.9406564584124654e-324)

// maximum binary power of double number

// minimum binary power of double number

// ==============================================================================
// Types
//============================================================================

//* Type define for primitive types.
type F32 = float32  /* yyjson.c:498:21 */
type F64 = float64  /* yyjson.c:499:21 */
type I8 = Int8_t    /* yyjson.c:500:21 */
type U8 = Uint8_t   /* yyjson.c:501:21 */
type I16 = Int16_t  /* yyjson.c:502:21 */
type U16 = Uint16_t /* yyjson.c:503:21 */
type I32 = Int32_t  /* yyjson.c:504:21 */
type U32 = Uint32_t /* yyjson.c:505:21 */
type I64 = Int64_t  /* yyjson.c:506:21 */
type U64 = Uint64_t /* yyjson.c:507:21 */
type Usize = Size_t /* yyjson.c:508:21 */

//* 128-bit integer, used by floating-point number reader and writer.
type I128 = libc.Int128  /* yyjson.c:512:41 */
type U128 = libc.Uint128 /* yyjson.c:513:41 */

//* 16/32/64-bit vector
type V161 = struct {
	C1 int8
	C2 int8
} /* yyjson.c:517:9 */

//* 16/32/64-bit vector
type V16 = V161 /* yyjson.c:517:37 */
type V321 = struct {
	C1 int8
	C2 int8
	C3 int8
	C4 int8
} /* yyjson.c:518:9 */

type V32 = V321 /* yyjson.c:518:45 */
type V641 = struct {
	C1 int8
	C2 int8
	C3 int8
	C4 int8
	C5 int8
	C6 int8
	C7 int8
	C8 int8
} /* yyjson.c:519:9 */

type V64 = V641 /* yyjson.c:519:61 */

//* 16/32/64-bit vector union, used for unaligned memory access on modern CPU
type V16_uni1 = struct {
	__ccgo_pad1 [0]uint16
	V           V16
} /* yyjson.c:522:9 */

//* 16/32/64-bit vector union, used for unaligned memory access on modern CPU
type V16_uni = V16_uni1 /* yyjson.c:522:41 */
type V32_uni1 = struct {
	__ccgo_pad1 [0]uint32
	V           V32
} /* yyjson.c:523:9 */

type V32_uni = V32_uni1 /* yyjson.c:523:41 */
type V64_uni1 = struct {
	__ccgo_pad1 [0]uint64
	V           V64
} /* yyjson.c:524:9 */

type V64_uni = V64_uni1 /* yyjson.c:524:41 */

// ==============================================================================
// Character Utils
//============================================================================

func Byte_move_2(tls *libc.TLS, dst uintptr, src uintptr) { /* yyjson.c:532:6: */
	libc.X__builtin___memmove_chk(tls, dst, src, uint64(2), libc.X__builtin_object_size(tls, dst, 0))
}

func Byte_move_4(tls *libc.TLS, dst uintptr, src uintptr) { /* yyjson.c:541:6: */
	libc.X__builtin___memmove_chk(tls, dst, src, uint64(4), libc.X__builtin_object_size(tls, dst, 0))
}

func Byte_move_8(tls *libc.TLS, dst uintptr, src uintptr) { /* yyjson.c:552:6: */
	libc.X__builtin___memmove_chk(tls, dst, src, uint64(8), libc.X__builtin_object_size(tls, dst, 0))
}

func Byte_move_16(tls *libc.TLS, dst uintptr, src uintptr) { /* yyjson.c:567:6: */
	libc.X__builtin___memmove_chk(tls, dst, src, uint64(16), libc.X__builtin_object_size(tls, dst, 0))
}

func Byte_match_1(tls *libc.TLS, buf uintptr, pat uintptr) uint8 { /* yyjson.c:590:6: */
	return uint8(libc.Bool32(int32(*(*U8)(unsafe.Pointer(buf))) == int32(U8(*(*int8)(unsafe.Pointer(pat))))))
}

func Byte_match_2(tls *libc.TLS, buf uintptr, pat uintptr) uint8 { /* yyjson.c:594:6: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var u1 V16_uni at bp, 2

	// var u2 V16_uni at bp+2, 2

	*(*V16)(unsafe.Pointer(bp)) = *(*V16)(unsafe.Pointer(pat))
	*(*V16)(unsafe.Pointer(bp + 2)) = *(*V16)(unsafe.Pointer(buf))
	return uint8(libc.Bool32(int32(*(*U16)(unsafe.Pointer(bp))) == int32(*(*U16)(unsafe.Pointer(bp + 2)))))
}

func Byte_match_4(tls *libc.TLS, buf uintptr, pat uintptr) uint8 { /* yyjson.c:607:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var u1 V32_uni at bp, 4

	// var u2 V32_uni at bp+4, 4

	*(*V32)(unsafe.Pointer(bp)) = *(*V32)(unsafe.Pointer(pat))
	*(*V32)(unsafe.Pointer(bp + 4)) = *(*V32)(unsafe.Pointer(buf))
	return uint8(libc.Bool32(*(*U32)(unsafe.Pointer(bp)) == *(*U32)(unsafe.Pointer(bp + 4))))
}

func Byte_load_4(tls *libc.TLS, src uintptr) U32 { /* yyjson.c:622:5: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var uni V32_uni at bp, 4

	*(*V32)(unsafe.Pointer(bp)) = *(*V32)(unsafe.Pointer(src))
	return *(*U32)(unsafe.Pointer(bp))
}

//* Compound Literals, C99 only.

func V16_make(tls *libc.TLS, c1 int8, c2 int8) V16 { /* yyjson.c:642:5: */
	var v V16
	v.C1 = c1
	v.C2 = c2
	return v
}

func V32_make(tls *libc.TLS, c1 int8, c2 int8, c3 int8, c4 int8) V32 { /* yyjson.c:649:5: */
	var v V32
	v.C1 = c1
	v.C2 = c2
	v.C3 = c3
	v.C4 = c4
	return v
}

func V64_make(tls *libc.TLS, c1 int8, c2 int8, c3 int8, c4 int8, c5 int8, c6 int8, c7 int8, c8 int8) V64 { /* yyjson.c:658:5: */
	var v V64
	v.C1 = c1
	v.C2 = c2
	v.C3 = c3
	v.C4 = c4
	v.C5 = c5
	v.C6 = c6
	v.C7 = c7
	v.C8 = c8
	return v
}

// ==============================================================================
// Number Utils
// These functions are used to detect and convert NaN and Inf numbers.
//============================================================================

//*
//  This union is used to avoid violating the strict aliasing rule in C.
//  `memcpy` can be used in both C and C++, but it may reduce performance without
//  compiler optimization.
//
type F64_uni = struct{ U U64 } /* yyjson.c:686:33 */

//* Convert raw binary to double.
func F64_from_raw(tls *libc.TLS, u U64) F64 { /* yyjson.c:689:5: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var uni F64_uni at bp, 8

	*(*U64)(unsafe.Pointer(bp)) = u
	return *(*F64)(unsafe.Pointer(bp))
}

//* Convert double to raw binary.
func F64_to_raw(tls *libc.TLS, f F64) U64 { /* yyjson.c:702:5: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var uni F64_uni at bp, 8

	*(*F64)(unsafe.Pointer(bp)) = f
	return *(*U64)(unsafe.Pointer(bp))
}

//* Get raw 'infinity' with sign.
func F64_raw_get_inf(tls *libc.TLS, sign uint8) U64 { /* yyjson.c:715:5: */
	return U64(0x7FF00000)<<32 + 0x00000000 | U64(sign)<<63
}

//* Get raw 'nan' with sign.
func F64_raw_get_nan(tls *libc.TLS, sign uint8) U64 { /* yyjson.c:726:5: */
	return U64(0x7FF80000)<<32 + 0x00000000 | U64(sign)<<63
}

//*
//  Convert normalized u64 (highest bit is 1) to f64.
//
//  Some compiler (such as Microsoft Visual C++ 6.0) do not support converting
//  number from u64 to f64. This function will first convert u64 to i64 and then
//  to f64, with `to nearest` rounding mode.
//
func Normalized_u64_to_f64(tls *libc.TLS, val U64) F64 { /* yyjson.c:743:5: */
	return F64(val)
}

// ==============================================================================
// Size Utils
// These functions are used for memory allocation.
//============================================================================

//* Returns whether the size is overflow after increment.
func Size_add_is_overflow(tls *libc.TLS, size Usize, add Usize) uint8 { /* yyjson.c:760:6: */
	var val Usize = size + add
	return uint8(libc.Bool32(val < size) | libc.Bool32(val < add))
}

//* Returns whether the size is power of 2 (size should not be 0).
func Size_is_pow2(tls *libc.TLS, size Usize) uint8 { /* yyjson.c:766:6: */
	return uint8(libc.Bool32(size&(size-uint64(1)) == uint64(0)))
}

//* Align size upwards (may overflow).
func Size_align_up(tls *libc.TLS, size Usize, align Usize) Usize { /* yyjson.c:771:7: */
	if Size_is_pow2(tls, align) != 0 {
		return (size + (align - uint64(1))) & ^(align - uint64(1))
	} else {
		return size + align - (size+align-uint64(1))%align - uint64(1)
	}
	return Usize(0)
}

//* Align size downwards.
func Size_align_down(tls *libc.TLS, size Usize, align Usize) Usize { /* yyjson.c:780:7: */
	if Size_is_pow2(tls, align) != 0 {
		return size & ^(align - uint64(1))
	} else {
		return size - size%align
	}
	return Usize(0)
}

//* Align address upwards (may overflow).
func Mem_align_up(tls *libc.TLS, mem uintptr, align Usize) uintptr { /* yyjson.c:789:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = mem

	// var size Usize at bp, 8

	libc.X__builtin___memcpy_chk(tls, bp, bp+8, uint64(unsafe.Sizeof(Usize(0))), libc.X__builtin_object_size(tls, bp, 0))
	*(*Usize)(unsafe.Pointer(bp /* size */)) = Size_align_up(tls, *(*Usize)(unsafe.Pointer(bp /* size */)), align)
	libc.X__builtin___memcpy_chk(tls, bp+8, bp, uint64(unsafe.Sizeof(Usize(0))), libc.X__builtin_object_size(tls, bp+8, 0))
	return *(*uintptr)(unsafe.Pointer(bp + 8 /* mem */))
}

//* Align address downwards.
func Mem_align_down(tls *libc.TLS, mem uintptr, align Usize) uintptr { /* yyjson.c:798:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = mem

	// var size Usize at bp, 8

	libc.X__builtin___memcpy_chk(tls, bp, bp+8, uint64(unsafe.Sizeof(Usize(0))), libc.X__builtin_object_size(tls, bp, 0))
	*(*Usize)(unsafe.Pointer(bp /* size */)) = Size_align_down(tls, *(*Usize)(unsafe.Pointer(bp /* size */)), align)
	libc.X__builtin___memcpy_chk(tls, bp+8, bp, uint64(unsafe.Sizeof(Usize(0))), libc.X__builtin_object_size(tls, bp+8, 0))
	return *(*uintptr)(unsafe.Pointer(bp + 8 /* mem */))
}

// ==============================================================================
// Bits Utils
// These functions are used by the floating-point number reader and writer.
//============================================================================

//* Returns the number of leading 0-bits in value (input should not be 0).
func U64_lz_bits(tls *libc.TLS, v U64) U32 { /* yyjson.c:814:5: */
	return U32(libc.X__builtin_clzll(tls, v))
}

//* Returns the number of trailing 0-bits in value (input should not be 0).
func U64_tz_bits(tls *libc.TLS, v U64) U32 { /* yyjson.c:846:5: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	// branchless, use de Bruijn sequences
	*(*[64]U8)(unsafe.Pointer(bp /* table */)) = [64]U8{
		U8(0), U8(1), U8(2), U8(53), U8(3), U8(7), U8(54), U8(27), U8(4), U8(38), U8(41), U8(8), U8(34), U8(55), U8(48), U8(28),
		U8(62), U8(5), U8(39), U8(46), U8(44), U8(42), U8(22), U8(9), U8(24), U8(35), U8(59), U8(56), U8(49), U8(18), U8(29), U8(11),
		U8(63), U8(52), U8(6), U8(26), U8(37), U8(40), U8(33), U8(47), U8(61), U8(45), U8(43), U8(21), U8(23), U8(58), U8(17), U8(10),
		U8(51), U8(25), U8(36), U8(32), U8(60), U8(20), U8(57), U8(16), U8(50), U8(31), U8(19), U8(15), U8(30), U8(14), U8(13), U8(12),
	}
	return U32(*(*U8)(unsafe.Pointer(bp + uintptr(v&(^v+uint64(1))*(U64(0x022FDD63)<<32+0xCC95386D)>>58))))
}

// ==============================================================================
// 128-bit Integer Utils
// These functions are used by the floating-point number reader and writer.
//============================================================================

//* Multiplies two 64-bit unsigned integers (a * b),
//     returns the 128-bit result as 'hi' and 'lo'.
func U128_mul(tls *libc.TLS, a U64, b U64, hi uintptr, lo uintptr) { /* yyjson.c:880:6: */
	var m U128 = libc.Uint128FromUint64(a).Mul(libc.Uint128FromUint64(b))
	*(*U64)(unsafe.Pointer(hi)) = m.Shr(64).Uint64()
	*(*U64)(unsafe.Pointer(lo)) = uint64(m.Lo)
}

//* Multiplies two 64-bit unsigned integers and add a value (a * b + c),
//     returns the 128-bit result as 'hi' and 'lo'.
func U128_mul_add(tls *libc.TLS, a U64, b U64, c U64, hi uintptr, lo uintptr) { /* yyjson.c:903:6: */
	var m U128 = libc.Uint128FromUint64(a).Mul(libc.Uint128FromUint64(b)).Add(libc.Uint128FromUint64(c))
	*(*U64)(unsafe.Pointer(hi)) = m.Shr(64).Uint64()
	*(*U64)(unsafe.Pointer(lo)) = uint64(m.Lo)
}

// ==============================================================================
// File Utils
// These functions are used to read and write JSON files.
//============================================================================

func Fopen_safe(tls *libc.TLS, path uintptr, mode uintptr) uintptr { /* yyjson.c:933:6: */
	return libc.Xfopen(tls, path, mode)
}

func Fopen_readonly(tls *libc.TLS, path uintptr) uintptr { /* yyjson.c:943:6: */
	return Fopen_safe(tls, path, ts+59)
}

func Fopen_writeonly(tls *libc.TLS, path uintptr) uintptr { /* yyjson.c:947:6: */
	return Fopen_safe(tls, path, ts+62)
}

func Fread_safe(tls *libc.TLS, buf uintptr, size Usize, file uintptr) Usize { /* yyjson.c:951:7: */
	return libc.Xfread(tls, buf, uint64(1), size, file)
}

// ==============================================================================
// Default Memory Allocator
// This is a simple libc memory allocator wrapper.
//============================================================================

func default_malloc(tls *libc.TLS, ctx uintptr, size Usize) uintptr { /* yyjson.c:966:13: */
	return libc.Xmalloc(tls, size)
}

func default_realloc(tls *libc.TLS, ctx uintptr, ptr uintptr, size Usize) uintptr { /* yyjson.c:970:13: */
	return libc.Xrealloc(tls, ptr, size)
}

func default_free(tls *libc.TLS, ctx uintptr, ptr uintptr) { /* yyjson.c:974:13: */
	libc.Xfree(tls, ptr)
}

var sYYJSON_DEFAULT_ALC = Yyjson_alc{
	Malloc:  0,
	Realloc: 0,
	Free:    0,
} /* yyjson.c:978:25 */

// ==============================================================================
// Pool Memory Allocator
// This is a simple memory allocator that uses linked list memory chunk.
// The following code will be executed only when the library user creates
// this allocator manually.
//============================================================================

//* chunk header
type Pool_chunk1 = struct {
	Size Usize
	Next uintptr
} /* yyjson.c:995:9 */

// ==============================================================================
// Pool Memory Allocator
// This is a simple memory allocator that uses linked list memory chunk.
// The following code will be executed only when the library user creates
// this allocator manually.
//============================================================================

//* chunk header
type Pool_chunk = Pool_chunk1 /* yyjson.c:998:3 */

//* ctx header
type Pool_ctx1 = struct {
	Size      Usize
	Free_list uintptr
} /* yyjson.c:1001:9 */

//* ctx header
type Pool_ctx = Pool_ctx1 /* yyjson.c:1004:3 */

func pool_malloc(tls *libc.TLS, ctx_ptr uintptr, size Usize) uintptr { /* yyjson.c:1006:13: */
	var ctx uintptr = ctx_ptr
	var next uintptr
	var prev uintptr = uintptr(0)
	var cur uintptr = (*Pool_ctx)(unsafe.Pointer(ctx)).Free_list

	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(size == uint64(0) || size >= (*Pool_ctx)(unsafe.Pointer(ctx)).Size)), int64(0)) != 0 {
		return uintptr(0)
	}
	size = Size_align_up(tls, size, uint64(unsafe.Sizeof(Pool_chunk{}))) + Usize(unsafe.Sizeof(Pool_chunk{}))

	for cur != 0 {
		if (*Pool_chunk)(unsafe.Pointer(cur)).Size < size {
			// not enough space, try next chunk
			prev = cur
			cur = (*Pool_chunk)(unsafe.Pointer(cur)).Next
			continue
		}
		if (*Pool_chunk)(unsafe.Pointer(cur)).Size >= size+uint64(unsafe.Sizeof(Pool_chunk{}))*uint64(2) {
			// too much space, split this chunk
			next = cur + uintptr(size)
			(*Pool_chunk)(unsafe.Pointer(next)).Size = (*Pool_chunk)(unsafe.Pointer(cur)).Size - size
			(*Pool_chunk)(unsafe.Pointer(next)).Next = (*Pool_chunk)(unsafe.Pointer(cur)).Next
			(*Pool_chunk)(unsafe.Pointer(cur)).Size = size
		} else {
			// just enough space, use whole chunk
			next = (*Pool_chunk)(unsafe.Pointer(cur)).Next
		}
		if prev != 0 {
			(*Pool_chunk)(unsafe.Pointer(prev)).Next = next
		} else {
			(*Pool_ctx)(unsafe.Pointer(ctx)).Free_list = next
		}
		return cur + uintptr(1)*16
	}
	return uintptr(0)
}

func pool_free(tls *libc.TLS, ctx_ptr uintptr, ptr uintptr) { /* yyjson.c:1037:13: */
	var ctx uintptr = ctx_ptr
	var cur uintptr = ptr - uintptr(1)*16
	var prev uintptr = uintptr(0)
	var next uintptr = (*Pool_ctx)(unsafe.Pointer(ctx)).Free_list

	for next != 0 && next < cur {
		prev = next
		next = (*Pool_chunk)(unsafe.Pointer(next)).Next
	}
	if prev != 0 {
		(*Pool_chunk)(unsafe.Pointer(prev)).Next = cur
	} else {
		(*Pool_ctx)(unsafe.Pointer(ctx)).Free_list = cur
	}
	(*Pool_chunk)(unsafe.Pointer(cur)).Next = next

	if next != 0 && cur+uintptr((*Pool_chunk)(unsafe.Pointer(cur)).Size) == next {
		// merge cur to higher chunk
		*(*Usize)(unsafe.Pointer(cur)) += (*Pool_chunk)(unsafe.Pointer(next)).Size
		(*Pool_chunk)(unsafe.Pointer(cur)).Next = (*Pool_chunk)(unsafe.Pointer(next)).Next
	}
	if prev != 0 && prev+uintptr((*Pool_chunk)(unsafe.Pointer(prev)).Size) == cur {
		// merge cur to lower chunk
		*(*Usize)(unsafe.Pointer(prev)) += (*Pool_chunk)(unsafe.Pointer(cur)).Size
		(*Pool_chunk)(unsafe.Pointer(prev)).Next = (*Pool_chunk)(unsafe.Pointer(cur)).Next
	}
}

func pool_realloc(tls *libc.TLS, ctx_ptr uintptr, ptr uintptr, size Usize) uintptr { /* yyjson.c:1062:13: */
	var ctx uintptr = ctx_ptr
	var cur uintptr = ptr - uintptr(1)*16
	var prev uintptr
	var next uintptr
	var tmp uintptr
	var free_size Usize
	var new_ptr uintptr

	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(size == uint64(0) || size >= (*Pool_ctx)(unsafe.Pointer(ctx)).Size)), int64(0)) != 0 {
		return uintptr(0)
	}
	size = Size_align_up(tls, size, uint64(unsafe.Sizeof(Pool_chunk{}))) + Usize(unsafe.Sizeof(Pool_chunk{}))

	// reduce size
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(size <= (*Pool_chunk)(unsafe.Pointer(cur)).Size)), int64(0)) != 0 {
		free_size = (*Pool_chunk)(unsafe.Pointer(cur)).Size - size
		if free_size >= uint64(unsafe.Sizeof(Pool_chunk{}))*uint64(2) {
			tmp = cur + uintptr((*Pool_chunk)(unsafe.Pointer(cur)).Size) - uintptr(free_size)
			(*Pool_chunk)(unsafe.Pointer(tmp)).Size = free_size
			pool_free(tls, ctx_ptr, tmp+uintptr(1)*16)
			*(*Usize)(unsafe.Pointer(cur)) -= free_size
		}
		return ptr
	}

	// find next and prev chunk
	prev = uintptr(0)
	next = (*Pool_ctx)(unsafe.Pointer(ctx)).Free_list
	for next != 0 && next < cur {
		prev = next
		next = (*Pool_chunk)(unsafe.Pointer(next)).Next
	}

	// merge to higher chunk if they are contiguous
	if cur+uintptr((*Pool_chunk)(unsafe.Pointer(cur)).Size) == next && (*Pool_chunk)(unsafe.Pointer(cur)).Size+(*Pool_chunk)(unsafe.Pointer(next)).Size >= size {
		free_size = (*Pool_chunk)(unsafe.Pointer(cur)).Size + (*Pool_chunk)(unsafe.Pointer(next)).Size - size
		if free_size > uint64(unsafe.Sizeof(Pool_chunk{}))*uint64(2) {
			tmp = cur + uintptr(size)
			if prev != 0 {
				(*Pool_chunk)(unsafe.Pointer(prev)).Next = tmp
			} else {
				(*Pool_ctx)(unsafe.Pointer(ctx)).Free_list = tmp
			}
			(*Pool_chunk)(unsafe.Pointer(tmp)).Next = (*Pool_chunk)(unsafe.Pointer(next)).Next
			(*Pool_chunk)(unsafe.Pointer(tmp)).Size = free_size
			(*Pool_chunk)(unsafe.Pointer(cur)).Size = size
		} else {
			if prev != 0 {
				(*Pool_chunk)(unsafe.Pointer(prev)).Next = (*Pool_chunk)(unsafe.Pointer(next)).Next
			} else {
				(*Pool_ctx)(unsafe.Pointer(ctx)).Free_list = (*Pool_chunk)(unsafe.Pointer(next)).Next
			}
			*(*Usize)(unsafe.Pointer(cur)) += (*Pool_chunk)(unsafe.Pointer(next)).Size
		}
		return ptr
	}

	// fallback to malloc and memcpy
	new_ptr = pool_malloc(tls, ctx_ptr, size-Usize(unsafe.Sizeof(Pool_chunk{})))
	if new_ptr != 0 {
		libc.X__builtin___memcpy_chk(tls, new_ptr, ptr, (*Pool_chunk)(unsafe.Pointer(cur)).Size-Usize(unsafe.Sizeof(Pool_chunk{})), libc.X__builtin_object_size(tls, new_ptr, 0))
		pool_free(tls, ctx_ptr, ptr)
	}
	return new_ptr
}

func Yyjson_alc_pool_init(tls *libc.TLS, alc uintptr, buf uintptr, size Usize) uint8 { /* yyjson.c:1119:6: */
	var chunk uintptr
	var ctx uintptr

	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(!(alc != 0) || size < uint64(unsafe.Sizeof(Pool_ctx{}))*uint64(4))), int64(0)) != 0 {
		return uint8(False)
	}
	ctx = Mem_align_up(tls, buf, uint64(unsafe.Sizeof(Pool_ctx{})))
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(ctx != 0)), int64(0)) != 0 {
		return uint8(False)
	}
	size = size - Usize((int64(ctx)-int64(buf))/1)
	size = Size_align_down(tls, size, uint64(unsafe.Sizeof(Pool_ctx{})))

	chunk = ctx + uintptr(1)*16
	(*Pool_chunk)(unsafe.Pointer(chunk)).Size = size - Usize(unsafe.Sizeof(Pool_ctx{}))
	(*Pool_chunk)(unsafe.Pointer(chunk)).Next = uintptr(0)
	(*Pool_ctx)(unsafe.Pointer(ctx)).Size = size
	(*Pool_ctx)(unsafe.Pointer(ctx)).Free_list = chunk

	(*Yyjson_alc)(unsafe.Pointer(alc)).Malloc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, Usize) uintptr
	}{pool_malloc}))
	(*Yyjson_alc)(unsafe.Pointer(alc)).Realloc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, Usize) uintptr
	}{pool_realloc}))
	(*Yyjson_alc)(unsafe.Pointer(alc)).Free = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr)
	}{pool_free}))
	(*Yyjson_alc)(unsafe.Pointer(alc)).Ctx = ctx
	return uint8(True)
}

// ==============================================================================
// JSON document and value
//============================================================================

func Unsafe_yyjson_str_pool_release(tls *libc.TLS, pool uintptr, alc uintptr) { /* yyjson.c:1148:6: */
	var chunk uintptr = (*Yyjson_str_pool)(unsafe.Pointer(pool)).Chunks
	var next uintptr
	for chunk != 0 {
		next = (*Yyjson_str_chunk)(unsafe.Pointer(chunk)).Next
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(alc)).Free})).f(tls, (*Yyjson_alc)(unsafe.Pointer(alc)).Ctx, chunk)
		chunk = next
	}
}

func Unsafe_yyjson_val_pool_release(tls *libc.TLS, pool uintptr, alc uintptr) { /* yyjson.c:1158:6: */
	var chunk uintptr = (*Yyjson_val_pool)(unsafe.Pointer(pool)).Chunks
	var next uintptr
	for chunk != 0 {
		next = (*Yyjson_val_chunk)(unsafe.Pointer(chunk)).Next
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(alc)).Free})).f(tls, (*Yyjson_alc)(unsafe.Pointer(alc)).Ctx, chunk)
		chunk = next
	}
}

func Unsafe_yyjson_str_pool_grow(tls *libc.TLS, pool uintptr, alc uintptr, len Usize) uint8 { /* yyjson.c:1168:6: */
	var chunk uintptr
	var size Usize = len + Usize(unsafe.Sizeof(Yyjson_str_chunk{}))
	size = func() uint64 {
		if (*Yyjson_str_pool)(unsafe.Pointer(pool)).Chunk_size > size {
			return (*Yyjson_str_pool)(unsafe.Pointer(pool)).Chunk_size
		}
		return size
	}()
	chunk = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(alc)).Malloc})).f(tls, (*Yyjson_alc)(unsafe.Pointer(alc)).Ctx, size)
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(chunk != 0)), int64(0)) != 0 {
		return uint8(False)
	}

	(*Yyjson_str_chunk)(unsafe.Pointer(chunk)).Next = (*Yyjson_str_pool)(unsafe.Pointer(pool)).Chunks
	(*Yyjson_str_pool)(unsafe.Pointer(pool)).Chunks = chunk
	(*Yyjson_str_pool)(unsafe.Pointer(pool)).Cur = chunk + uintptr(uint64(unsafe.Sizeof(Yyjson_str_chunk{})))
	(*Yyjson_str_pool)(unsafe.Pointer(pool)).End = chunk + uintptr(size)

	size = func() uint64 {
		if (*Yyjson_str_pool)(unsafe.Pointer(pool)).Chunk_size*uint64(2) < (*Yyjson_str_pool)(unsafe.Pointer(pool)).Chunk_size_max {
			return (*Yyjson_str_pool)(unsafe.Pointer(pool)).Chunk_size * uint64(2)
		}
		return (*Yyjson_str_pool)(unsafe.Pointer(pool)).Chunk_size_max
	}()
	(*Yyjson_str_pool)(unsafe.Pointer(pool)).Chunk_size = size
	return uint8(True)
}

func Unsafe_yyjson_val_pool_grow(tls *libc.TLS, pool uintptr, alc uintptr, count Usize) uint8 { /* yyjson.c:1186:6: */
	var chunk uintptr
	var size Usize

	if count >= libc.CplUint64(uint64(0))/Usize(unsafe.Sizeof(Yyjson_mut_val{}))-uint64(16) {
		return uint8(False)
	}
	size = (count + uint64(1)) * Usize(unsafe.Sizeof(Yyjson_mut_val{}))
	size = func() uint64 {
		if (*Yyjson_val_pool)(unsafe.Pointer(pool)).Chunk_size > size {
			return (*Yyjson_val_pool)(unsafe.Pointer(pool)).Chunk_size
		}
		return size
	}()
	chunk = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(alc)).Malloc})).f(tls, (*Yyjson_alc)(unsafe.Pointer(alc)).Ctx, size)
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(chunk != 0)), int64(0)) != 0 {
		return uint8(False)
	}

	(*Yyjson_val_chunk)(unsafe.Pointer(chunk)).Next = (*Yyjson_val_pool)(unsafe.Pointer(pool)).Chunks
	(*Yyjson_val_pool)(unsafe.Pointer(pool)).Chunks = chunk
	(*Yyjson_val_pool)(unsafe.Pointer(pool)).Cur = chunk +
		uintptr(uint64(unsafe.Sizeof(Yyjson_mut_val{})))
	(*Yyjson_val_pool)(unsafe.Pointer(pool)).End = chunk + uintptr(size)

	size = func() uint64 {
		if (*Yyjson_val_pool)(unsafe.Pointer(pool)).Chunk_size*uint64(2) < (*Yyjson_val_pool)(unsafe.Pointer(pool)).Chunk_size_max {
			return (*Yyjson_val_pool)(unsafe.Pointer(pool)).Chunk_size * uint64(2)
		}
		return (*Yyjson_val_pool)(unsafe.Pointer(pool)).Chunk_size_max
	}()
	(*Yyjson_val_pool)(unsafe.Pointer(pool)).Chunk_size = size
	return uint8(True)
}

func Yyjson_mut_doc_free(tls *libc.TLS, doc uintptr) { /* yyjson.c:1208:6: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if doc != 0 {
		*(*Yyjson_alc)(unsafe.Pointer(bp /* alc */)) = (*Yyjson_mut_doc)(unsafe.Pointer(doc)).Alc
		Unsafe_yyjson_str_pool_release(tls, doc+40, bp)
		Unsafe_yyjson_val_pool_release(tls, doc+80, bp)
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(bp /* &alc */)).Free})).f(tls, (*Yyjson_alc)(unsafe.Pointer(bp /* &alc */)).Ctx, doc)
	}
}

func Yyjson_mut_doc_new(tls *libc.TLS, alc uintptr) uintptr { /* yyjson.c:1217:16: */
	var doc uintptr
	if !(alc != 0) {
		alc = uintptr(unsafe.Pointer(&sYYJSON_DEFAULT_ALC))
	}
	doc = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(alc)).Malloc})).f(tls, (*Yyjson_alc)(unsafe.Pointer(alc)).Ctx, uint64(unsafe.Sizeof(Yyjson_mut_doc{})))
	if !(doc != 0) {
		return uintptr(0)
	}
	libc.X__builtin___memset_chk(tls, doc, 0, uint64(unsafe.Sizeof(Yyjson_mut_doc{})), libc.X__builtin_object_size(tls, doc, 0))

	(*Yyjson_mut_doc)(unsafe.Pointer(doc)).Alc = *(*Yyjson_alc)(unsafe.Pointer(alc))
	(*Yyjson_mut_doc)(unsafe.Pointer(doc)).Str_pool.Chunk_size = uint64(0x100)
	(*Yyjson_mut_doc)(unsafe.Pointer(doc)).Str_pool.Chunk_size_max = uint64(0x10000000)
	(*Yyjson_mut_doc)(unsafe.Pointer(doc)).Val_pool.Chunk_size = uint64(0x10) * uint64(unsafe.Sizeof(Yyjson_mut_val{}))
	(*Yyjson_mut_doc)(unsafe.Pointer(doc)).Val_pool.Chunk_size_max = uint64(0x1000000) * uint64(unsafe.Sizeof(Yyjson_mut_val{}))
	return doc
}

func Yyjson_doc_mut_copy(tls *libc.TLS, i_doc uintptr, alc uintptr) uintptr { /* yyjson.c:1232:27: */
	var m_doc uintptr
	var m_val uintptr

	if !(i_doc != 0) {
		return uintptr(0)
	}
	m_doc = Yyjson_mut_doc_new(tls, alc)
	if !(m_doc != 0) {
		return uintptr(0)
	}
	m_val = Yyjson_val_mut_copy(tls, m_doc, (*Yyjson_doc)(unsafe.Pointer(i_doc)).Root)
	if !(m_val != 0) {
		Yyjson_mut_doc_free(tls, m_doc)
		return uintptr(0)
	}
	Yyjson_mut_doc_set_root(tls, m_doc, m_val)
	return m_doc
}

func Yyjson_mut_doc_mut_copy(tls *libc.TLS, i_doc uintptr, alc uintptr) uintptr { /* yyjson.c:1249:27: */
	var m_doc uintptr
	var m_val uintptr

	if !(i_doc != 0) {
		return uintptr(0)
	}
	m_doc = Yyjson_mut_doc_new(tls, alc)
	if !(m_doc != 0) {
		return uintptr(0)
	}
	m_val = Yyjson_mut_val_mut_copy(tls, m_doc, (*Yyjson_mut_doc)(unsafe.Pointer(i_doc)).Root)
	if !(m_val != 0) {
		Yyjson_mut_doc_free(tls, m_doc)
		return uintptr(0)
	}
	Yyjson_mut_doc_set_root(tls, m_doc, m_val)
	return m_doc
}

func Yyjson_val_mut_copy(tls *libc.TLS, m_doc uintptr, i_vals uintptr) uintptr { /* yyjson.c:1266:27: */
	//
	//      The immutable object or array stores all sub-value in a contiguous memory,
	//      We copy them to another contiguous memory as mutable values,
	//      then reconnect the mutable values with the original relationship.
	//

	var i_vals_len Usize
	var m_vals uintptr
	var m_val uintptr
	var i_val uintptr
	var i_end uintptr

	if !(m_doc != 0) || !(i_vals != 0) {
		return uintptr(0)
	}
	i_end = Unsafe_yyjson_get_next(tls, i_vals)
	i_vals_len = Usize((int64(Unsafe_yyjson_get_next(tls, i_vals)) - int64(i_vals)) / 16)
	m_vals = Unsafe_yyjson_mut_val(tls, m_doc, i_vals_len)
	if !(m_vals != 0) {
		return uintptr(0)
	}
	i_val = i_vals
	m_val = m_vals

__1:
	if !(i_val < i_end) {
		goto __3
	}
	{
		var type1 Yyjson_type = Unsafe_yyjson_get_type(tls, i_val)
		(*Yyjson_mut_val)(unsafe.Pointer(m_val)).Tag = (*Yyjson_val)(unsafe.Pointer(i_val)).Tag
		*(*Uint64_t)(unsafe.Pointer(m_val + 8)) = *(*Uint64_t)(unsafe.Pointer(i_val + 8))
		if int32(type1) == int32(Uint8_t(5)) {
			var str uintptr = *(*uintptr)(unsafe.Pointer(i_val + 8))
			var str_len Usize = Unsafe_yyjson_get_len(tls, i_val)
			*(*uintptr)(unsafe.Pointer(m_val + 8)) = Unsafe_yyjson_mut_strncpy(tls, m_doc, str, str_len)
			if !(int32(*(*uintptr)(unsafe.Pointer(m_val + 8))) != 0) {
				return uintptr(0)
			}

		} else if int32(type1) == int32(Uint8_t(6)) {
			var len Usize = Unsafe_yyjson_get_len(tls, i_val)
			if len > uint64(0) {
				var ii_val uintptr = i_val + uintptr(1)*16
				var ii_next uintptr
				var mm_val uintptr = m_val + uintptr(1)*24
				var mm_ctn uintptr = m_val
				var mm_next uintptr
				for libc.PostDecUint64(&len, 1) > uint64(1) {
					ii_next = Unsafe_yyjson_get_next(tls, ii_val)
					mm_next = mm_val + uintptr((int64(ii_next)-int64(ii_val))/16)*24
					(*Yyjson_mut_val)(unsafe.Pointer(mm_val)).Next = mm_next
					ii_val = ii_next
					mm_val = mm_next
				}
				(*Yyjson_mut_val)(unsafe.Pointer(mm_val)).Next = mm_ctn + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(mm_ctn + 8)) = mm_val
			}
		} else if int32(type1) == int32(Uint8_t(7)) {
			var len Usize = Unsafe_yyjson_get_len(tls, i_val)
			if len > uint64(0) {
				var ii_key uintptr = i_val + uintptr(1)*16
				var ii_nextkey uintptr
				var mm_key uintptr = m_val + uintptr(1)*24
				var mm_ctn uintptr = m_val
				var mm_nextkey uintptr
				for libc.PostDecUint64(&len, 1) > uint64(1) {
					ii_nextkey = Unsafe_yyjson_get_next(tls, ii_key+uintptr(1)*16)
					mm_nextkey = mm_key + uintptr((int64(ii_nextkey)-int64(ii_key))/16)*24
					(*Yyjson_mut_val)(unsafe.Pointer(mm_key)).Next = mm_key + uintptr(1)*24
					(*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(mm_key)).Next)).Next = mm_nextkey
					ii_key = ii_nextkey
					mm_key = mm_nextkey
				}
				(*Yyjson_mut_val)(unsafe.Pointer(mm_key)).Next = mm_key + uintptr(1)*24
				(*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(mm_key)).Next)).Next = mm_ctn + uintptr(1)*24
				*(*uintptr)(unsafe.Pointer(mm_ctn + 8)) = mm_key
			}
		}

	}
	goto __2
__2:
	i_val += 16
	m_val += 24
	goto __1
	goto __3
__3:
	;

	return m_vals
}

func unsafe_yyjson_mut_ctn_mut_copy(tls *libc.TLS, m_doc uintptr, i_val uintptr) uintptr { /* yyjson.c:1335:23: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var type1 Yyjson_type = Unsafe_yyjson_get_type(tls, i_val)
	var m_val uintptr = Unsafe_yyjson_mut_val(tls, m_doc, uint64(1))
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(m_val != 0)), int64(0)) != 0 {
		return uintptr(0)
	}

	if int32(type1) == int32(Uint8_t(6)) {
		var val uintptr
		var new_val uintptr
		// var iter Yyjson_mut_arr_iter at bp, 40

		Yyjson_mut_arr_iter_init(tls, i_val, bp)
		(*Yyjson_mut_val)(unsafe.Pointer(m_val)).Tag = Uint64_t(Uint8_t(6))
		for libc.AssignUintptr(&val, Yyjson_mut_arr_iter_next(tls, bp)) != 0 {
			new_val = unsafe_yyjson_mut_ctn_mut_copy(tls, m_doc, val)
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Yyjson_mut_arr_append(tls, m_val, new_val) != 0)), int64(0)) != 0 {
				return uintptr(0)
			}
		}
		return m_val

	} else if int32(type1) == int32(Uint8_t(7)) {
		var key uintptr
		var val uintptr
		var new_key uintptr
		var new_val uintptr
		// var iter Yyjson_mut_obj_iter at bp+40, 40

		Yyjson_mut_obj_iter_init(tls, i_val, bp+40)
		(*Yyjson_mut_val)(unsafe.Pointer(m_val)).Tag = Uint64_t(Uint8_t(7))
		for libc.AssignUintptr(&key, Yyjson_mut_obj_iter_next(tls, bp+40)) != 0 {
			val = (*Yyjson_mut_val)(unsafe.Pointer(key)).Next
			new_key = unsafe_yyjson_mut_ctn_mut_copy(tls, m_doc, key)
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(new_key != 0)), int64(0)) != 0 {
				return uintptr(0)
			}
			new_val = unsafe_yyjson_mut_ctn_mut_copy(tls, m_doc, val)
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(new_val != 0)), int64(0)) != 0 {
				return uintptr(0)
			}
			Unsafe_yyjson_mut_obj_add(tls, m_val, new_key, new_val,
				Unsafe_yyjson_get_len(tls, m_val))
		}
		return m_val

	} else if int32(type1) == int32(Uint8_t(5)) {
		var len Usize = Unsafe_yyjson_get_len(tls, i_val)
		var str uintptr = Unsafe_yyjson_mut_strncpy(tls, m_doc, *(*uintptr)(unsafe.Pointer(i_val + 8)), len)
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(str != 0)), int64(0)) != 0 {
			return uintptr(0)
		}
		(*Yyjson_mut_val)(unsafe.Pointer(m_val)).Tag = (*Yyjson_mut_val)(unsafe.Pointer(i_val)).Tag
		*(*uintptr)(unsafe.Pointer(m_val + 8)) = str
		return m_val

	} else {
		(*Yyjson_mut_val)(unsafe.Pointer(m_val)).Tag = (*Yyjson_mut_val)(unsafe.Pointer(i_val)).Tag
		*(*Uint64_t)(unsafe.Pointer(m_val + 8)) = *(*Uint64_t)(unsafe.Pointer(i_val + 8))
		return m_val
	}
	return uintptr(0)
}

func Yyjson_mut_val_mut_copy(tls *libc.TLS, m_doc uintptr, i_vals uintptr) uintptr { /* yyjson.c:1383:27: */
	if m_doc != 0 && i_vals != 0 {
		return unsafe_yyjson_mut_ctn_mut_copy(tls, m_doc, i_vals)
	}
	return uintptr(0)
}

func Yyjson_mut_equals(tls *libc.TLS, lhs uintptr, rhs uintptr) uint8 { /* yyjson.c:1391:6: */
	bp := tls.Alloc(160)
	defer tls.Free(160)

	var type1 Yyjson_type = Yyjson_mut_get_type(tls, lhs)
	if int32(type1) != int32(Yyjson_mut_get_type(tls, rhs)) {
		return uint8(False)
	}

	if int32(type1) == int32(Uint8_t(2)) {
		return uint8(True)
	}
	if int32(type1) == int32(Uint8_t(3)) {
		return uint8(libc.Bool32(Unsafe_yyjson_get_bool(tls, lhs) == Unsafe_yyjson_get_bool(tls, rhs)))
	}
	if int32(type1) == int32(Uint8_t(4)) {
		var lt Yyjson_subtype
		var rt Yyjson_subtype
		lt = Unsafe_yyjson_get_subtype(tls, lhs)
		rt = Unsafe_yyjson_get_subtype(tls, rhs)
		if int32(lt) == int32(rt) {
			return uint8(libc.Bool32(*(*Uint64_t)(unsafe.Pointer(lhs + 8)) == *(*Uint64_t)(unsafe.Pointer(rhs + 8))))
		}
		if int32(lt) == int32(Uint8_t(int32(1)<<3)) && int32(rt) == int32(Uint8_t(int32(0)<<3)) {
			if *(*Int64_t)(unsafe.Pointer(lhs + 8)) >= int64(0) && *(*Int64_t)(unsafe.Pointer(lhs + 8)) == *(*Int64_t)(unsafe.Pointer(rhs + 8)) {
				return uint8(True)
			} else {
				return uint8(False)
			}
		}
		if int32(lt) == int32(Uint8_t(int32(0)<<3)) && int32(rt) == int32(Uint8_t(int32(1)<<3)) {
			if *(*Int64_t)(unsafe.Pointer(rhs + 8)) >= int64(0) && *(*Int64_t)(unsafe.Pointer(lhs + 8)) == *(*Int64_t)(unsafe.Pointer(rhs + 8)) {
				return uint8(True)
			} else {
				return uint8(False)
			}
		}
		return uint8(False)
	}
	if int32(type1) == int32(Uint8_t(5)) {
		var len Usize = Unsafe_yyjson_get_len(tls, lhs)
		if len != Unsafe_yyjson_get_len(tls, rhs) {
			return uint8(False)
		}
		return uint8(libc.Bool32(libc.Xmemcmp(tls, *(*uintptr)(unsafe.Pointer(lhs + 8)), *(*uintptr)(unsafe.Pointer(rhs + 8)), len) == 0))
	}
	if int32(type1) == int32(Uint8_t(6)) {
		var lhs_val uintptr
		var rhs_val uintptr
		// var lhs_iter Yyjson_mut_arr_iter at bp, 40

		// var rhs_iter Yyjson_mut_arr_iter at bp+40, 40

		var len Usize = Unsafe_yyjson_get_len(tls, lhs)
		if len != Unsafe_yyjson_get_len(tls, rhs) {
			return uint8(False)
		}
		if len == uint64(0) {
			return uint8(True)
		}

		Yyjson_mut_arr_iter_init(tls, lhs, bp)
		Yyjson_mut_arr_iter_init(tls, rhs, bp+40)
		for libc.AssignUintptr(&lhs_val, Yyjson_mut_arr_iter_next(tls, bp)) != 0 && libc.AssignUintptr(&rhs_val, Yyjson_mut_arr_iter_next(tls, bp+40)) != 0 {
			if !(Yyjson_mut_equals(tls, lhs_val, rhs_val) != 0) {
				return uint8(False)
			}
		}
		return uint8(True)
	}
	if int32(type1) == int32(Uint8_t(7)) {
		var key uintptr
		var lhs_val uintptr
		var rhs_val uintptr
		// var lhs_iter Yyjson_mut_obj_iter at bp+80, 40

		// var rhs_iter Yyjson_mut_obj_iter at bp+120, 40

		var len Usize = Unsafe_yyjson_get_len(tls, lhs)
		if len != Unsafe_yyjson_get_len(tls, rhs) {
			return uint8(False)
		}
		if len == uint64(0) {
			return uint8(True)
		}

		Yyjson_mut_obj_iter_init(tls, lhs, bp+80)
		Yyjson_mut_obj_iter_init(tls, rhs, bp+120)
		for libc.AssignUintptr(&key, Yyjson_mut_obj_iter_next(tls, bp+80)) != 0 {
			lhs_val = (*Yyjson_mut_val)(unsafe.Pointer(key)).Next
			rhs_val = Yyjson_mut_obj_iter_getn(tls, bp+120, *(*uintptr)(unsafe.Pointer(key + 8)),
				Unsafe_yyjson_get_len(tls, key))
			if !(rhs_val != 0) {
				return uint8(False)
			}
			if !(Yyjson_mut_equals(tls, lhs_val, rhs_val) != 0) {
				return uint8(False)
			}
		}
		// yyjson allows duplicate keys, so the check may be inaccurate
		return uint8(True)
	}

	return uint8(False)
}

// ==============================================================================
// JSON Pointer
//============================================================================

// only 0x0, 0x2F ('/') and 0x7E ('~') are excluded from this table
var pointer_char_table = [256]uint8{
	uint8(0), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
} /* yyjson.c:1464:19 */

func Pointer_read_index(tls *libc.TLS, ptr uintptr, end uintptr, idx uintptr) uint8 { /* yyjson.c:1483:6: */
	var num U64
	var i U32
	var add U8

	add = U8(int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1)))) - '0')
	if int32(add) == 0 {
		*(*Usize)(unsafe.Pointer(idx)) = uint64(0)
		*(*uintptr)(unsafe.Pointer(end)) = ptr
		return uint8(True)
	}
	if int32(add) > 9 {
		return uint8(False)
	}

	num = U64(add)
	for i = U32(0); i < U32(U64_SAFE_DIG); i++ {
		if int32(libc.AssignUint8(&add, U8(int32(*(*int8)(unsafe.Pointer(ptr + uintptr(i))))-'0'))) <= 9 {
			num = U64(add) + num*uint64(10)
		} else {
			*(*Usize)(unsafe.Pointer(idx)) = Usize(num)
			*(*uintptr)(unsafe.Pointer(end)) = ptr + uintptr(i)
			return uint8(libc.Bool32(num < U64(libc.CplUint64(uint64(0)))))
		}
	}
	return uint8(False)
}

func Pointer_read_str(tls *libc.TLS, ptr uintptr, end uintptr, buf uintptr, str uintptr, len uintptr) uint8 { /* yyjson.c:1511:6: */
	var hdr uintptr = ptr
	var dst uintptr = buf
	var distance Usize

	// skip unescaped characters, do not validate encoding
	for 1 != 0 {
		{
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(pointer_char_table[U8(*(*int8)(unsafe.Pointer(ptr)))]) != 0)), int64(1)) != 0 {
			} else {
				ptr += uintptr(0)
				break
			}
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(pointer_char_table[U8(*(*int8)(unsafe.Pointer(ptr + 1)))]) != 0)), int64(1)) != 0 {
			} else {
				ptr += uintptr(1)
				break
			}
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(pointer_char_table[U8(*(*int8)(unsafe.Pointer(ptr + 2)))]) != 0)), int64(1)) != 0 {
			} else {
				ptr += uintptr(2)
				break
			}
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(pointer_char_table[U8(*(*int8)(unsafe.Pointer(ptr + 3)))]) != 0)), int64(1)) != 0 {
			} else {
				ptr += uintptr(3)
				break
			}
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(pointer_char_table[U8(*(*int8)(unsafe.Pointer(ptr + 4)))]) != 0)), int64(1)) != 0 {
			} else {
				ptr += uintptr(4)
				break
			}
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(pointer_char_table[U8(*(*int8)(unsafe.Pointer(ptr + 5)))]) != 0)), int64(1)) != 0 {
			} else {
				ptr += uintptr(5)
				break
			}
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(pointer_char_table[U8(*(*int8)(unsafe.Pointer(ptr + 6)))]) != 0)), int64(1)) != 0 {
			} else {
				ptr += uintptr(6)
				break
			}
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(pointer_char_table[U8(*(*int8)(unsafe.Pointer(ptr + 7)))]) != 0)), int64(1)) != 0 {
			} else {
				ptr += uintptr(7)
				break
			}
		}
		ptr += uintptr(8)
	}
	distance = Usize((int64(ptr) - int64(hdr)) / 1)
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*int8)(unsafe.Pointer(ptr))) != '~')), int64(1)) != 0 {
		*(*uintptr)(unsafe.Pointer(end)) = ptr
		*(*uintptr)(unsafe.Pointer(str)) = hdr
		*(*Usize)(unsafe.Pointer(len)) = distance
		return uint8(True)
	}

	// copy escaped string
	libc.X__builtin___memcpy_chk(tls, dst, hdr, distance, libc.X__builtin_object_size(tls, dst, 0))
	dst += uintptr(distance)
	ptr += uintptr(1)
	if int32(*(*int8)(unsafe.Pointer(ptr))) != '0' && int32(*(*int8)(unsafe.Pointer(ptr))) != '1' {
		return uint8(False)
	}
	*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = func() int8 {
		if int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1)))) == '0' {
			return int8('~')
		}
		return int8('/')
	}()
	for 1 != 0 {
		if pointer_char_table[U8(*(*int8)(unsafe.Pointer(ptr)))] != 0 {
			*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1)))
		} else if int32(*(*int8)(unsafe.Pointer(ptr))) != '~' {
			*(*uintptr)(unsafe.Pointer(end)) = ptr
			*(*uintptr)(unsafe.Pointer(str)) = buf
			*(*Usize)(unsafe.Pointer(len)) = Usize((int64(dst) - int64(buf)) / 1)
			return uint8(True)
		} else {
			ptr++
			if int32(*(*int8)(unsafe.Pointer(ptr))) != '0' && int32(*(*int8)(unsafe.Pointer(ptr))) != '1' {
				return uint8(False)
			}
			*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = func() int8 {
				if int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&ptr, 1)))) == '0' {
					return int8('~')
				}
				return int8('/')
			}()
		}
	}
	return uint8(0)
}

func Unsafe_yyjson_get_pointer(tls *libc.TLS, val uintptr, ptr uintptr, len Size_t) uintptr { /* yyjson.c:1555:23: */
	bp := tls.Alloc(544)
	defer tls.Free(544)
	*(*uintptr)(unsafe.Pointer(bp + 512)) = ptr

	// var tmp [512]int8 at bp, 512

	var buf uintptr

	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(len <= Size_t(unsafe.Sizeof([512]int8{})))), int64(1)) != 0 {
		buf = bp /* &tmp[0] */
	} else {
		buf = libc.Xmalloc(tls, len)
		if !(buf != 0) {
			return uintptr(0)
		}
	}

	*(*uintptr)(unsafe.Pointer(bp + 512 /* ptr */))++
	for 1 != 0 {
		if Yyjson_is_obj(tls, val) != 0 {
			// var key uintptr at bp+520, 8

			// var key_len Usize at bp+528, 8

			if Pointer_read_str(tls, *(*uintptr)(unsafe.Pointer(bp + 512)), bp+512, buf, bp+520, bp+528) != 0 {
				val = Yyjson_obj_getn(tls, val, *(*uintptr)(unsafe.Pointer(bp + 520 /* key */)), *(*Usize)(unsafe.Pointer(bp + 528 /* key_len */)))
			} else {
				val = uintptr(0)
			}
		} else if Yyjson_is_arr(tls, val) != 0 {
			// var idx Usize at bp+536, 8

			if Pointer_read_index(tls, *(*uintptr)(unsafe.Pointer(bp + 512)), bp+512, bp+536) != 0 {
				val = Yyjson_arr_get(tls, val, *(*Usize)(unsafe.Pointer(bp + 536 /* idx */)))
			} else {
				val = uintptr(0)
			}
		} else {
			val = uintptr(0)
		}
		if val != 0 && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 512))))) == 0 {
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!(len > Size_t(unsafe.Sizeof([512]int8{})))), int64(0)) != 0 {
				libc.Xfree(tls, buf)
			}
			return val
		}
		if int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 512)), 1)))) == '/' {
			continue
		}
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(len > Size_t(unsafe.Sizeof([512]int8{})))), int64(0)) != 0 {
			libc.Xfree(tls, buf)
		}
		return uintptr(0)
	}
	return uintptr(0)
}

func Unsafe_yyjson_mut_get_pointer(tls *libc.TLS, val uintptr, ptr uintptr, len Size_t) uintptr { /* yyjson.c:1598:27: */
	bp := tls.Alloc(544)
	defer tls.Free(544)
	*(*uintptr)(unsafe.Pointer(bp + 512)) = ptr

	// var tmp [512]int8 at bp, 512

	var buf uintptr

	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(len <= Size_t(unsafe.Sizeof([512]int8{})))), int64(1)) != 0 {
		buf = bp /* &tmp[0] */
	} else {
		buf = libc.Xmalloc(tls, len)
		if !(buf != 0) {
			return uintptr(0)
		}
	}

	*(*uintptr)(unsafe.Pointer(bp + 512 /* ptr */))++
	for 1 != 0 {
		if Yyjson_mut_is_obj(tls, val) != 0 {
			// var key uintptr at bp+520, 8

			// var key_len Usize at bp+528, 8

			if Pointer_read_str(tls, *(*uintptr)(unsafe.Pointer(bp + 512)), bp+512, buf, bp+520, bp+528) != 0 {
				val = Yyjson_mut_obj_getn(tls, val, *(*uintptr)(unsafe.Pointer(bp + 520 /* key */)), *(*Usize)(unsafe.Pointer(bp + 528 /* key_len */)))
			} else {
				val = uintptr(0)
			}
		} else if Yyjson_mut_is_arr(tls, val) != 0 {
			// var idx Usize at bp+536, 8

			if Pointer_read_index(tls, *(*uintptr)(unsafe.Pointer(bp + 512)), bp+512, bp+536) != 0 {
				val = Yyjson_mut_arr_get(tls, val, *(*Usize)(unsafe.Pointer(bp + 536 /* idx */)))
			} else {
				val = uintptr(0)
			}
		} else {
			val = uintptr(0)
		}
		if val != 0 && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 512))))) == 0 {
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!(len > Size_t(unsafe.Sizeof([512]int8{})))), int64(0)) != 0 {
				libc.Xfree(tls, buf)
			}
			return val
		}
		if int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 512)), 1)))) == '/' {
			continue
		}
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(len > Size_t(unsafe.Sizeof([512]int8{})))), int64(0)) != 0 {
			libc.Xfree(tls, buf)
		}
		return uintptr(0)
	}
	return uintptr(0)
}

// ==============================================================================
// JSON Merge-Patch
//============================================================================

func Yyjson_merge_patch(tls *libc.TLS, doc uintptr, orig uintptr, patch uintptr) uintptr { /* yyjson.c:1647:27: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var idx Size_t
	var max Size_t
	var key uintptr
	var orig_val uintptr
	var patch_val uintptr
	// var local_orig Yyjson_val at bp, 16

	var builder uintptr
	var mut_key uintptr
	var mut_val uintptr
	var merged_val uintptr

	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Yyjson_is_obj(tls, patch) != 0)), int64(0)) != 0 {
		return Yyjson_val_mut_copy(tls, doc, patch)
	}

	builder = Yyjson_mut_obj(tls, doc)
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(builder != 0)), int64(0)) != 0 {
		return uintptr(0)
	}

	if !(Yyjson_is_obj(tls, orig) != 0) {
		orig = bp /* &local_orig */
		(*Yyjson_val)(unsafe.Pointer(orig)).Tag = (*Yyjson_mut_val)(unsafe.Pointer(builder)).Tag
		(*Yyjson_val)(unsafe.Pointer(orig)).Uni = (*Yyjson_mut_val)(unsafe.Pointer(builder)).Uni
	}

	// Merge items modified by the patch.
	idx = uint64(0)
	max = Yyjson_obj_size(tls, patch)
	key = func() uintptr {
		if patch != 0 {
			return Unsafe_yyjson_get_first(tls, patch)
		}
		return uintptr(0)
	}()
	patch_val = key + uintptr(1)*16
__1:
	if !(idx < max) {
		goto __3
	}
	{
		// null indicates the field is removed.
		if Unsafe_yyjson_is_null(tls, patch_val) != 0 {
			goto __2
		}
		mut_key = Yyjson_val_mut_copy(tls, doc, key)
		orig_val = Yyjson_obj_getn(tls, orig,
			Unsafe_yyjson_get_str(tls, key),
			Unsafe_yyjson_get_len(tls, key))
		merged_val = Yyjson_merge_patch(tls, doc, orig_val, patch_val)
		if !(Yyjson_mut_obj_add(tls, builder, mut_key, merged_val) != 0) {
			return uintptr(0)
		}

	}
	goto __2
__2:
	idx++
	key = Unsafe_yyjson_get_next(tls, patch_val)
	patch_val = key + uintptr(1)*16
	goto __1
	goto __3
__3:
	;

	// Exit early, if orig is not contributing to the final result.
	if orig == bp {
		return builder
	}

	// Copy over any items that weren't modified by the patch.
	idx = uint64(0)
	max = Yyjson_obj_size(tls, orig)
	key = func() uintptr {
		if orig != 0 {
			return Unsafe_yyjson_get_first(tls, orig)
		}
		return uintptr(0)
	}()
	orig_val = key + uintptr(1)*16
__4:
	if !(idx < max) {
		goto __6
	}
	{
		patch_val = Yyjson_obj_getn(tls, patch,
			Unsafe_yyjson_get_str(tls, key),
			Unsafe_yyjson_get_len(tls, key))
		if !(patch_val != 0) {
			mut_key = Yyjson_val_mut_copy(tls, doc, key)
			mut_val = Yyjson_val_mut_copy(tls, doc, orig_val)
			if !(Yyjson_mut_obj_add(tls, builder, mut_key, mut_val) != 0) {
				return uintptr(0)
			}
		}

	}
	goto __5
__5:
	idx++
	key = Unsafe_yyjson_get_next(tls, orig_val)
	orig_val = key + uintptr(1)*16
	goto __4
	goto __6
__6:
	;

	return builder
}

// ==============================================================================
// Power10 Lookup Table
// These data are used by the floating-point number reader and writer.
//============================================================================

//* Minimum decimal exponent in pow10_sig_table.

//* Maximum decimal exponent in pow10_sig_table.

//* Minimum exact decimal exponent in pow10_sig_table

//* Maximum exact decimal exponent in pow10_sig_table

//* Normalized significant 128 bits of pow10, no rounded up (size: 10.4KB).
//     This lookup table is used by both the double number reader and writer.
//     (generate with misc/make_tables.c)
var pow10_sig_table = [1336]U64{
	U64(0xBF29DCAB)<<32 + 0xA82FDEAE, U64(0x7432EE87)<<32 + 0x3880FC33,
	U64(0xEEF453D6)<<32 + 0x923BD65A, U64(0x113FAA29)<<32 + 0x06A13B3F,
	U64(0x9558B466)<<32 + 0x1B6565F8, U64(0x4AC7CA59)<<32 + 0xA424C507,
	U64(0xBAAEE17F)<<32 + 0xA23EBF76, U64(0x5D79BCF0)<<32 + 0x0D2DF649,
	U64(0xE95A99DF)<<32 + 0x8ACE6F53, U64(0xF4D82C2C)<<32 + 0x107973DC,
	U64(0x91D8A02B)<<32 + 0xB6C10594, U64(0x79071B9B)<<32 + 0x8A4BE869,
	U64(0xB64EC836)<<32 + 0xA47146F9, U64(0x9748E282)<<32 + 0x6CDEE284,
	U64(0xE3E27A44)<<32 + 0x4D8D98B7, U64(0xFD1B1B23)<<32 + 0x08169B25,
	U64(0x8E6D8C6A)<<32 + 0xB0787F72, U64(0xFE30F0F5)<<32 + 0xE50E20F7,
	U64(0xB208EF85)<<32 + 0x5C969F4F, U64(0xBDBD2D33)<<32 + 0x5E51A935,
	U64(0xDE8B2B66)<<32 + 0xB3BC4723, U64(0xAD2C7880)<<32 + 0x35E61382,
	U64(0x8B16FB20)<<32 + 0x3055AC76, U64(0x4C3BCB50)<<32 + 0x21AFCC31,
	U64(0xADDCB9E8)<<32 + 0x3C6B1793, U64(0xDF4ABE24)<<32 + 0x2A1BBF3D,
	U64(0xD953E862)<<32 + 0x4B85DD78, U64(0xD71D6DAD)<<32 + 0x34A2AF0D,
	U64(0x87D4713D)<<32 + 0x6F33AA6B, U64(0x8672648C)<<32 + 0x40E5AD68,
	U64(0xA9C98D8C)<<32 + 0xCB009506, U64(0x680EFDAF)<<32 + 0x511F18C2,
	U64(0xD43BF0EF)<<32 + 0xFDC0BA48, U64(0x0212BD1B)<<32 + 0x2566DEF2,
	U64(0x84A57695)<<32 + 0xFE98746D, U64(0x014BB630)<<32 + 0xF7604B57,
	U64(0xA5CED43B)<<32 + 0x7E3E9188, U64(0x419EA3BD)<<32 + 0x35385E2D,
	U64(0xCF42894A)<<32 + 0x5DCE35EA, U64(0x52064CAC)<<32 + 0x828675B9,
	U64(0x818995CE)<<32 + 0x7AA0E1B2, U64(0x7343EFEB)<<32 + 0xD1940993,
	U64(0xA1EBFB42)<<32 + 0x19491A1F, U64(0x1014EBE6)<<32 + 0xC5F90BF8,
	U64(0xCA66FA12)<<32 + 0x9F9B60A6, U64(0xD41A26E0)<<32 + 0x77774EF6,
	U64(0xFD00B897)<<32 + 0x478238D0, U64(0x8920B098)<<32 + 0x955522B4,
	U64(0x9E20735E)<<32 + 0x8CB16382, U64(0x55B46E5F)<<32 + 0x5D5535B0,
	U64(0xC5A89036)<<32 + 0x2FDDBC62, U64(0xEB2189F7)<<32 + 0x34AA831D,
	U64(0xF712B443)<<32 + 0xBBD52B7B, U64(0xA5E9EC75)<<32 + 0x01D523E4,
	U64(0x9A6BB0AA)<<32 + 0x55653B2D, U64(0x47B233C9)<<32 + 0x2125366E,
	U64(0xC1069CD4)<<32 + 0xEABE89F8, U64(0x999EC0BB)<<32 + 0x696E840A,
	U64(0xF148440A)<<32 + 0x256E2C76, U64(0xC00670EA)<<32 + 0x43CA250D,
	U64(0x96CD2A86)<<32 + 0x5764DBCA, U64(0x38040692)<<32 + 0x6A5E5728,
	U64(0xBC807527)<<32 + 0xED3E12BC, U64(0xC6050837)<<32 + 0x04F5ECF2,
	U64(0xEBA09271)<<32 + 0xE88D976B, U64(0xF7864A44)<<32 + 0xC633682E,
	U64(0x93445B87)<<32 + 0x31587EA3, U64(0x7AB3EE6A)<<32 + 0xFBE0211D,
	U64(0xB8157268)<<32 + 0xFDAE9E4C, U64(0x5960EA05)<<32 + 0xBAD82964,
	U64(0xE61ACF03)<<32 + 0x3D1A45DF, U64(0x6FB92487)<<32 + 0x298E33BD,
	U64(0x8FD0C162)<<32 + 0x06306BAB, U64(0xA5D3B6D4)<<32 + 0x79F8E056,
	U64(0xB3C4F1BA)<<32 + 0x87BC8696, U64(0x8F48A489)<<32 + 0x9877186C,
	U64(0xE0B62E29)<<32 + 0x29ABA83C, U64(0x331ACDAB)<<32 + 0xFE94DE87,
	U64(0x8C71DCD9)<<32 + 0xBA0B4925, U64(0x9FF0C08B)<<32 + 0x7F1D0B14,
	U64(0xAF8E5410)<<32 + 0x288E1B6F, U64(0x07ECF0AE)<<32 + 0x5EE44DD9,
	U64(0xDB71E914)<<32 + 0x32B1A24A, U64(0xC9E82CD9)<<32 + 0xF69D6150,
	U64(0x892731AC)<<32 + 0x9FAF056E, U64(0xBE311C08)<<32 + 0x3A225CD2,
	U64(0xAB70FE17)<<32 + 0xC79AC6CA, U64(0x6DBD630A)<<32 + 0x48AAF406,
	U64(0xD64D3D9D)<<32 + 0xB981787D, U64(0x092CBBCC)<<32 + 0xDAD5B108,
	U64(0x85F04682)<<32 + 0x93F0EB4E, U64(0x25BBF560)<<32 + 0x08C58EA5,
	U64(0xA76C5823)<<32 + 0x38ED2621, U64(0xAF2AF2B8)<<32 + 0x0AF6F24E,
	U64(0xD1476E2C)<<32 + 0x07286FAA, U64(0x1AF5AF66)<<32 + 0x0DB4AEE1,
	U64(0x82CCA4DB)<<32 + 0x847945CA, U64(0x50D98D9F)<<32 + 0xC890ED4D,
	U64(0xA37FCE12)<<32 + 0x6597973C, U64(0xE50FF107)<<32 + 0xBAB528A0,
	U64(0xCC5FC196)<<32 + 0xFEFD7D0C, U64(0x1E53ED49)<<32 + 0xA96272C8,
	U64(0xFF77B1FC)<<32 + 0xBEBCDC4F, U64(0x25E8E89C)<<32 + 0x13BB0F7A,
	U64(0x9FAACF3D)<<32 + 0xF73609B1, U64(0x77B19161)<<32 + 0x8C54E9AC,
	U64(0xC795830D)<<32 + 0x75038C1D, U64(0xD59DF5B9)<<32 + 0xEF6A2417,
	U64(0xF97AE3D0)<<32 + 0xD2446F25, U64(0x4B057328)<<32 + 0x6B44AD1D,
	U64(0x9BECCE62)<<32 + 0x836AC577, U64(0x4EE367F9)<<32 + 0x430AEC32,
	U64(0xC2E801FB)<<32 + 0x244576D5, U64(0x229C41F7)<<32 + 0x93CDA73F,
	U64(0xF3A20279)<<32 + 0xED56D48A, U64(0x6B435275)<<32 + 0x78C1110F,
	U64(0x9845418C)<<32 + 0x345644D6, U64(0x830A1389)<<32 + 0x6B78AAA9,
	U64(0xBE5691EF)<<32 + 0x416BD60C, U64(0x23CC986B)<<32 + 0xC656D553,
	U64(0xEDEC366B)<<32 + 0x11C6CB8F, U64(0x2CBFBE86)<<32 + 0xB7EC8AA8,
	U64(0x94B3A202)<<32 + 0xEB1C3F39, U64(0x7BF7D714)<<32 + 0x32F3D6A9,
	U64(0xB9E08A83)<<32 + 0xA5E34F07, U64(0xDAF5CCD9)<<32 + 0x3FB0CC53,
	U64(0xE858AD24)<<32 + 0x8F5C22C9, U64(0xD1B3400F)<<32 + 0x8F9CFF68,
	U64(0x91376C36)<<32 + 0xD99995BE, U64(0x23100809)<<32 + 0xB9C21FA1,
	U64(0xB5854744)<<32 + 0x8FFFFB2D, U64(0xABD40A0C)<<32 + 0x2832A78A,
	U64(0xE2E69915)<<32 + 0xB3FFF9F9, U64(0x16C90C8F)<<32 + 0x323F516C,
	U64(0x8DD01FAD)<<32 + 0x907FFC3B, U64(0xAE3DA7D9)<<32 + 0x7F6792E3,
	U64(0xB1442798)<<32 + 0xF49FFB4A, U64(0x99CD11CF)<<32 + 0xDF41779C,
	U64(0xDD95317F)<<32 + 0x31C7FA1D, U64(0x40405643)<<32 + 0xD711D583,
	U64(0x8A7D3EEF)<<32 + 0x7F1CFC52, U64(0x482835EA)<<32 + 0x666B2572,
	U64(0xAD1C8EAB)<<32 + 0x5EE43B66, U64(0xDA324365)<<32 + 0x0005EECF,
	U64(0xD863B256)<<32 + 0x369D4A40, U64(0x90BED43E)<<32 + 0x40076A82,
	U64(0x873E4F75)<<32 + 0xE2224E68, U64(0x5A7744A6)<<32 + 0xE804A291,
	U64(0xA90DE353)<<32 + 0x5AAAE202, U64(0x711515D0)<<32 + 0xA205CB36,
	U64(0xD3515C28)<<32 + 0x31559A83, U64(0x0D5A5B44)<<32 + 0xCA873E03,
	U64(0x8412D999)<<32 + 0x1ED58091, U64(0xE858790A)<<32 + 0xFE9486C2,
	U64(0xA5178FFF)<<32 + 0x668AE0B6, U64(0x626E974D)<<32 + 0xBE39A872,
	U64(0xCE5D73FF)<<32 + 0x402D98E3, U64(0xFB0A3D21)<<32 + 0x2DC8128F,
	U64(0x80FA687F)<<32 + 0x881C7F8E, U64(0x7CE66634)<<32 + 0xBC9D0B99,
	U64(0xA139029F)<<32 + 0x6A239F72, U64(0x1C1FFFC1)<<32 + 0xEBC44E80,
	U64(0xC9874347)<<32 + 0x44AC874E, U64(0xA327FFB2)<<32 + 0x66B56220,
	U64(0xFBE91419)<<32 + 0x15D7A922, U64(0x4BF1FF9F)<<32 + 0x0062BAA8,
	U64(0x9D71AC8F)<<32 + 0xADA6C9B5, U64(0x6F773FC3)<<32 + 0x603DB4A9,
	U64(0xC4CE17B3)<<32 + 0x99107C22, U64(0xCB550FB4)<<32 + 0x384D21D3,
	U64(0xF6019DA0)<<32 + 0x7F549B2B, U64(0x7E2A53A1)<<32 + 0x46606A48,
	U64(0x99C10284)<<32 + 0x4F94E0FB, U64(0x2EDA7444)<<32 + 0xCBFC426D,
	U64(0xC0314325)<<32 + 0x637A1939, U64(0xFA911155)<<32 + 0xFEFB5308,
	U64(0xF03D93EE)<<32 + 0xBC589F88, U64(0x793555AB)<<32 + 0x7EBA27CA,
	U64(0x96267C75)<<32 + 0x35B763B5, U64(0x4BC1558B)<<32 + 0x2F3458DE,
	U64(0xBBB01B92)<<32 + 0x83253CA2, U64(0x9EB1AAED)<<32 + 0xFB016F16,
	U64(0xEA9C2277)<<32 + 0x23EE8BCB, U64(0x465E15A9)<<32 + 0x79C1CADC,
	U64(0x92A1958A)<<32 + 0x7675175F, U64(0x0BFACD89)<<32 + 0xEC191EC9,
	U64(0xB749FAED)<<32 + 0x14125D36, U64(0xCEF980EC)<<32 + 0x671F667B,
	U64(0xE51C79A8)<<32 + 0x5916F484, U64(0x82B7E127)<<32 + 0x80E7401A,
	U64(0x8F31CC09)<<32 + 0x37AE58D2, U64(0xD1B2ECB8)<<32 + 0xB0908810,
	U64(0xB2FE3F0B)<<32 + 0x8599EF07, U64(0x861FA7E6)<<32 + 0xDCB4AA15,
	U64(0xDFBDCECE)<<32 + 0x67006AC9, U64(0x67A791E0)<<32 + 0x93E1D49A,
	U64(0x8BD6A141)<<32 + 0x006042BD, U64(0xE0C8BB2C)<<32 + 0x5C6D24E0,
	U64(0xAECC4991)<<32 + 0x4078536D, U64(0x58FAE9F7)<<32 + 0x73886E18,
	U64(0xDA7F5BF5)<<32 + 0x90966848, U64(0xAF39A475)<<32 + 0x506A899E,
	U64(0x888F9979)<<32 + 0x7A5E012D, U64(0x6D8406C9)<<32 + 0x52429603,
	U64(0xAAB37FD7)<<32 + 0xD8F58178, U64(0xC8E5087B)<<32 + 0xA6D33B83,
	U64(0xD5605FCD)<<32 + 0xCF32E1D6, U64(0xFB1E4A9A)<<32 + 0x90880A64,
	U64(0x855C3BE0)<<32 + 0xA17FCD26, U64(0x5CF2EEA0)<<32 + 0x9A55067F,
	U64(0xA6B34AD8)<<32 + 0xC9DFC06F, U64(0xF42FAA48)<<32 + 0xC0EA481E,
	U64(0xD0601D8E)<<32 + 0xFC57B08B, U64(0xF13B94DA)<<32 + 0xF124DA26,
	U64(0x823C1279)<<32 + 0x5DB6CE57, U64(0x76C53D08)<<32 + 0xD6B70858,
	U64(0xA2CB1717)<<32 + 0xB52481ED, U64(0x54768C4B)<<32 + 0x0C64CA6E,
	U64(0xCB7DDCDD)<<32 + 0xA26DA268, U64(0xA9942F5D)<<32 + 0xCF7DFD09,
	U64(0xFE5D5415)<<32 + 0x0B090B02, U64(0xD3F93B35)<<32 + 0x435D7C4C,
	U64(0x9EFA548D)<<32 + 0x26E5A6E1, U64(0xC47BC501)<<32 + 0x4A1A6DAF,
	U64(0xC6B8E9B0)<<32 + 0x709F109A, U64(0x359AB641)<<32 + 0x9CA1091B,
	U64(0xF867241C)<<32 + 0x8CC6D4C0, U64(0xC30163D2)<<32 + 0x03C94B62,
	U64(0x9B407691)<<32 + 0xD7FC44F8, U64(0x79E0DE63)<<32 + 0x425DCF1D,
	U64(0xC2109436)<<32 + 0x4DFB5636, U64(0x985915FC)<<32 + 0x12F542E4,
	U64(0xF294B943)<<32 + 0xE17A2BC4, U64(0x3E6F5B7B)<<32 + 0x17B2939D,
	U64(0x979CF3CA)<<32 + 0x6CEC5B5A, U64(0xA705992C)<<32 + 0xEECF9C42,
	U64(0xBD8430BD)<<32 + 0x08277231, U64(0x50C6FF78)<<32 + 0x2A838353,
	U64(0xECE53CEC)<<32 + 0x4A314EBD, U64(0xA4F8BF56)<<32 + 0x35246428,
	U64(0x940F4613)<<32 + 0xAE5ED136, U64(0x871B7795)<<32 + 0xE136BE99,
	U64(0xB9131798)<<32 + 0x99F68584, U64(0x28E2557B)<<32 + 0x59846E3F,
	U64(0xE757DD7E)<<32 + 0xC07426E5, U64(0x331AEADA)<<32 + 0x2FE589CF,
	U64(0x9096EA6F)<<32 + 0x3848984F, U64(0x3FF0D2C8)<<32 + 0x5DEF7621,
	U64(0xB4BCA50B)<<32 + 0x065ABE63, U64(0x0FED077A)<<32 + 0x756B53A9,
	U64(0xE1EBCE4D)<<32 + 0xC7F16DFB, U64(0xD3E84959)<<32 + 0x12C62894,
	U64(0x8D3360F0)<<32 + 0x9CF6E4BD, U64(0x64712DD7)<<32 + 0xABBBD95C,
	U64(0xB080392C)<<32 + 0xC4349DEC, U64(0xBD8D794D)<<32 + 0x96AACFB3,
	U64(0xDCA04777)<<32 + 0xF541C567, U64(0xECF0D7A0)<<32 + 0xFC5583A0,
	U64(0x89E42CAA)<<32 + 0xF9491B60, U64(0xF41686C4)<<32 + 0x9DB57244,
	U64(0xAC5D37D5)<<32 + 0xB79B6239, U64(0x311C2875)<<32 + 0xC522CED5,
	U64(0xD77485CB)<<32 + 0x25823AC7, U64(0x7D633293)<<32 + 0x366B828B,
	U64(0x86A8D39E)<<32 + 0xF77164BC, U64(0xAE5DFF9C)<<32 + 0x02033197,
	U64(0xA8530886)<<32 + 0xB54DBDEB, U64(0xD9F57F83)<<32 + 0x0283FDFC,
	U64(0xD267CAA8)<<32 + 0x62A12D66, U64(0xD072DF63)<<32 + 0xC324FD7B,
	U64(0x8380DEA9)<<32 + 0x3DA4BC60, U64(0x4247CB9E)<<32 + 0x59F71E6D,
	U64(0xA4611653)<<32 + 0x8D0DEB78, U64(0x52D9BE85)<<32 + 0xF074E608,
	U64(0xCD795BE8)<<32 + 0x70516656, U64(0x67902E27)<<32 + 0x6C921F8B,
	U64(0x806BD971)<<32 + 0x4632DFF6, U64(0x00BA1CD8)<<32 + 0xA3DB53B6,
	U64(0xA086CFCD)<<32 + 0x97BF97F3, U64(0x80E8A40E)<<32 + 0xCCD228A4,
	U64(0xC8A883C0)<<32 + 0xFDAF7DF0, U64(0x6122CD12)<<32 + 0x8006B2CD,
	U64(0xFAD2A4B1)<<32 + 0x3D1B5D6C, U64(0x796B8057)<<32 + 0x20085F81,
	U64(0x9CC3A6EE)<<32 + 0xC6311A63, U64(0xCBE33036)<<32 + 0x74053BB0,
	U64(0xC3F490AA)<<32 + 0x77BD60FC, U64(0xBEDBFC44)<<32 + 0x11068A9C,
	U64(0xF4F1B4D5)<<32 + 0x15ACB93B, U64(0xEE92FB55)<<32 + 0x15482D44,
	U64(0x99171105)<<32 + 0x2D8BF3C5, U64(0x751BDD15)<<32 + 0x2D4D1C4A,
	U64(0xBF5CD546)<<32 + 0x78EEF0B6, U64(0xD262D45A)<<32 + 0x78A0635D,
	U64(0xEF340A98)<<32 + 0x172AACE4, U64(0x86FB8971)<<32 + 0x16C87C34,
	U64(0x9580869F)<<32 + 0x0E7AAC0E, U64(0xD45D35E6)<<32 + 0xAE3D4DA0,
	U64(0xBAE0A846)<<32 + 0xD2195712, U64(0x89748360)<<32 + 0x59CCA109,
	U64(0xE998D258)<<32 + 0x869FACD7, U64(0x2BD1A438)<<32 + 0x703FC94B,
	U64(0x91FF8377)<<32 + 0x5423CC06, U64(0x7B6306A3)<<32 + 0x4627DDCF,
	U64(0xB67F6455)<<32 + 0x292CBF08, U64(0x1A3BC84C)<<32 + 0x17B1D542,
	U64(0xE41F3D6A)<<32 + 0x7377EECA, U64(0x20CABA5F)<<32 + 0x1D9E4A93,
	U64(0x8E938662)<<32 + 0x882AF53E, U64(0x547EB47B)<<32 + 0x7282EE9C,
	U64(0xB23867FB)<<32 + 0x2A35B28D, U64(0xE99E619A)<<32 + 0x4F23AA43,
	U64(0xDEC681F9)<<32 + 0xF4C31F31, U64(0x6405FA00)<<32 + 0xE2EC94D4,
	U64(0x8B3C113C)<<32 + 0x38F9F37E, U64(0xDE83BC40)<<32 + 0x8DD3DD04,
	U64(0xAE0B158B)<<32 + 0x4738705E, U64(0x9624AB50)<<32 + 0xB148D445,
	U64(0xD98DDAEE)<<32 + 0x19068C76, U64(0x3BADD624)<<32 + 0xDD9B0957,
	U64(0x87F8A8D4)<<32 + 0xCFA417C9, U64(0xE54CA5D7)<<32 + 0x0A80E5D6,
	U64(0xA9F6D30A)<<32 + 0x038D1DBC, U64(0x5E9FCF4C)<<32 + 0xCD211F4C,
	U64(0xD47487CC)<<32 + 0x8470652B, U64(0x7647C320)<<32 + 0x0069671F,
	U64(0x84C8D4DF)<<32 + 0xD2C63F3B, U64(0x29ECD9F4)<<32 + 0x0041E073,
	U64(0xA5FB0A17)<<32 + 0xC777CF09, U64(0xF4681071)<<32 + 0x00525890,
	U64(0xCF79CC9D)<<32 + 0xB955C2CC, U64(0x7182148D)<<32 + 0x4066EEB4,
	U64(0x81AC1FE2)<<32 + 0x93D599BF, U64(0xC6F14CD8)<<32 + 0x48405530,
	U64(0xA21727DB)<<32 + 0x38CB002F, U64(0xB8ADA00E)<<32 + 0x5A506A7C,
	U64(0xCA9CF1D2)<<32 + 0x06FDC03B, U64(0xA6D90811)<<32 + 0xF0E4851C,
	U64(0xFD442E46)<<32 + 0x88BD304A, U64(0x908F4A16)<<32 + 0x6D1DA663,
	U64(0x9E4A9CEC)<<32 + 0x15763E2E, U64(0x9A598E4E)<<32 + 0x043287FE,
	U64(0xC5DD4427)<<32 + 0x1AD3CDBA, U64(0x40EFF1E1)<<32 + 0x853F29FD,
	U64(0xF7549530)<<32 + 0xE188C128, U64(0xD12BEE59)<<32 + 0xE68EF47C,
	U64(0x9A94DD3E)<<32 + 0x8CF578B9, U64(0x82BB74F8)<<32 + 0x301958CE,
	U64(0xC13A148E)<<32 + 0x3032D6E7, U64(0xE36A5236)<<32 + 0x3C1FAF01,
	U64(0xF18899B1)<<32 + 0xBC3F8CA1, U64(0xDC44E6C3)<<32 + 0xCB279AC1,
	U64(0x96F5600F)<<32 + 0x15A7B7E5, U64(0x29AB103A)<<32 + 0x5EF8C0B9,
	U64(0xBCB2B812)<<32 + 0xDB11A5DE, U64(0x7415D448)<<32 + 0xF6B6F0E7,
	U64(0xEBDF6617)<<32 + 0x91D60F56, U64(0x111B495B)<<32 + 0x3464AD21,
	U64(0x936B9FCE)<<32 + 0xBB25C995, U64(0xCAB10DD9)<<32 + 0x00BEEC34,
	U64(0xB84687C2)<<32 + 0x69EF3BFB, U64(0x3D5D514F)<<32 + 0x40EEA742,
	U64(0xE65829B3)<<32 + 0x046B0AFA, U64(0x0CB4A5A3)<<32 + 0x112A5112,
	U64(0x8FF71A0F)<<32 + 0xE2C2E6DC, U64(0x47F0E785)<<32 + 0xEABA72AB,
	U64(0xB3F4E093)<<32 + 0xDB73A093, U64(0x59ED2167)<<32 + 0x65690F56,
	U64(0xE0F218B8)<<32 + 0xD25088B8, U64(0x306869C1)<<32 + 0x3EC3532C,
	U64(0x8C974F73)<<32 + 0x83725573, U64(0x1E414218)<<32 + 0xC73A13FB,
	U64(0xAFBD2350)<<32 + 0x644EEACF, U64(0xE5D1929E)<<32 + 0xF90898FA,
	U64(0xDBAC6C24)<<32 + 0x7D62A583, U64(0xDF45F746)<<32 + 0xB74ABF39,
	U64(0x894BC396)<<32 + 0xCE5DA772, U64(0x6B8BBA8C)<<32 + 0x328EB783,
	U64(0xAB9EB47C)<<32 + 0x81F5114F, U64(0x066EA92F)<<32 + 0x3F326564,
	U64(0xD686619B)<<32 + 0xA27255A2, U64(0xC80A537B)<<32 + 0x0EFEFEBD,
	U64(0x8613FD01)<<32 + 0x45877585, U64(0xBD06742C)<<32 + 0xE95F5F36,
	U64(0xA798FC41)<<32 + 0x96E952E7, U64(0x2C481138)<<32 + 0x23B73704,
	U64(0xD17F3B51)<<32 + 0xFCA3A7A0, U64(0xF75A1586)<<32 + 0x2CA504C5,
	U64(0x82EF8513)<<32 + 0x3DE648C4, U64(0x9A984D73)<<32 + 0xDBE722FB,
	U64(0xA3AB6658)<<32 + 0x0D5FDAF5, U64(0xC13E60D0)<<32 + 0xD2E0EBBA,
	U64(0xCC963FEE)<<32 + 0x10B7D1B3, U64(0x318DF905)<<32 + 0x079926A8,
	U64(0xFFBBCFE9)<<32 + 0x94E5C61F, U64(0xFDF17746)<<32 + 0x497F7052,
	U64(0x9FD561F1)<<32 + 0xFD0F9BD3, U64(0xFEB6EA8B)<<32 + 0xEDEFA633,
	U64(0xC7CABA6E)<<32 + 0x7C5382C8, U64(0xFE64A52E)<<32 + 0xE96B8FC0,
	U64(0xF9BD690A)<<32 + 0x1B68637B, U64(0x3DFDCE7A)<<32 + 0xA3C673B0,
	U64(0x9C1661A6)<<32 + 0x51213E2D, U64(0x06BEA10C)<<32 + 0xA65C084E,
	U64(0xC31BFA0F)<<32 + 0xE5698DB8, U64(0x486E494F)<<32 + 0xCFF30A62,
	U64(0xF3E2F893)<<32 + 0xDEC3F126, U64(0x5A89DBA3)<<32 + 0xC3EFCCFA,
	U64(0x986DDB5C)<<32 + 0x6B3A76B7, U64(0xF8962946)<<32 + 0x5A75E01C,
	U64(0xBE895233)<<32 + 0x86091465, U64(0xF6BBB397)<<32 + 0xF1135823,
	U64(0xEE2BA6C0)<<32 + 0x678B597F, U64(0x746AA07D)<<32 + 0xED582E2C,
	U64(0x94DB4838)<<32 + 0x40B717EF, U64(0xA8C2A44E)<<32 + 0xB4571CDC,
	U64(0xBA121A46)<<32 + 0x50E4DDEB, U64(0x92F34D62)<<32 + 0x616CE413,
	U64(0xE896A0D7)<<32 + 0xE51E1566, U64(0x77B020BA)<<32 + 0xF9C81D17,
	U64(0x915E2486)<<32 + 0xEF32CD60, U64(0x0ACE1474)<<32 + 0xDC1D122E,
	U64(0xB5B5ADA8)<<32 + 0xAAFF80B8, U64(0x0D819992)<<32 + 0x132456BA,
	U64(0xE3231912)<<32 + 0xD5BF60E6, U64(0x10E1FFF6)<<32 + 0x97ED6C69,
	U64(0x8DF5EFAB)<<32 + 0xC5979C8F, U64(0xCA8D3FFA)<<32 + 0x1EF463C1,
	U64(0xB1736B96)<<32 + 0xB6FD83B3, U64(0xBD308FF8)<<32 + 0xA6B17CB2,
	U64(0xDDD0467C)<<32 + 0x64BCE4A0, U64(0xAC7CB3F6)<<32 + 0xD05DDBDE,
	U64(0x8AA22C0D)<<32 + 0xBEF60EE4, U64(0x6BCDF07A)<<32 + 0x423AA96B,
	U64(0xAD4AB711)<<32 + 0x2EB3929D, U64(0x86C16C98)<<32 + 0xD2C953C6,
	U64(0xD89D64D5)<<32 + 0x7A607744, U64(0xE871C7BF)<<32 + 0x077BA8B7,
	U64(0x87625F05)<<32 + 0x6C7C4A8B, U64(0x11471CD7)<<32 + 0x64AD4972,
	U64(0xA93AF6C6)<<32 + 0xC79B5D2D, U64(0xD598E40D)<<32 + 0x3DD89BCF,
	U64(0xD389B478)<<32 + 0x79823479, U64(0x4AFF1D10)<<32 + 0x8D4EC2C3,
	U64(0x843610CB)<<32 + 0x4BF160CB, U64(0xCEDF722A)<<32 + 0x585139BA,
	U64(0xA54394FE)<<32 + 0x1EEDB8FE, U64(0xC2974EB4)<<32 + 0xEE658828,
	U64(0xCE947A3D)<<32 + 0xA6A9273E, U64(0x733D2262)<<32 + 0x29FEEA32,
	U64(0x811CCC66)<<32 + 0x8829B887, U64(0x0806357D)<<32 + 0x5A3F525F,
	U64(0xA163FF80)<<32 + 0x2A3426A8, U64(0xCA07C2DC)<<32 + 0xB0CF26F7,
	U64(0xC9BCFF60)<<32 + 0x34C13052, U64(0xFC89B393)<<32 + 0xDD02F0B5,
	U64(0xFC2C3F38)<<32 + 0x41F17C67, U64(0xBBAC2078)<<32 + 0xD443ACE2,
	U64(0x9D9BA783)<<32 + 0x2936EDC0, U64(0xD54B944B)<<32 + 0x84AA4C0D,
	U64(0xC5029163)<<32 + 0xF384A931, U64(0x0A9E795E)<<32 + 0x65D4DF11,
	U64(0xF64335BC)<<32 + 0xF065D37D, U64(0x4D4617B5)<<32 + 0xFF4A16D5,
	U64(0x99EA0196)<<32 + 0x163FA42E, U64(0x504BCED1)<<32 + 0xBF8E4E45,
	U64(0xC06481FB)<<32 + 0x9BCF8D39, U64(0xE45EC286)<<32 + 0x2F71E1D6,
	U64(0xF07DA27A)<<32 + 0x82C37088, U64(0x5D767327)<<32 + 0xBB4E5A4C,
	U64(0x964E858C)<<32 + 0x91BA2655, U64(0x3A6A07F8)<<32 + 0xD510F86F,
	U64(0xBBE226EF)<<32 + 0xB628AFEA, U64(0x890489F7)<<32 + 0x0A55368B,
	U64(0xEADAB0AB)<<32 + 0xA3B2DBE5, U64(0x2B45AC74)<<32 + 0xCCEA842E,
	U64(0x92C8AE6B)<<32 + 0x464FC96F, U64(0x3B0B8BC9)<<32 + 0x0012929D,
	U64(0xB77ADA06)<<32 + 0x17E3BBCB, U64(0x09CE6EBB)<<32 + 0x40173744,
	U64(0xE5599087)<<32 + 0x9DDCAABD, U64(0xCC420A6A)<<32 + 0x101D0515,
	U64(0x8F57FA54)<<32 + 0xC2A9EAB6, U64(0x9FA94682)<<32 + 0x4A12232D,
	U64(0xB32DF8E9)<<32 + 0xF3546564, U64(0x47939822)<<32 + 0xDC96ABF9,
	U64(0xDFF97724)<<32 + 0x70297EBD, U64(0x59787E2B)<<32 + 0x93BC56F7,
	U64(0x8BFBEA76)<<32 + 0xC619EF36, U64(0x57EB4EDB)<<32 + 0x3C55B65A,
	U64(0xAEFAE514)<<32 + 0x77A06B03, U64(0xEDE62292)<<32 + 0x0B6B23F1,
	U64(0xDAB99E59)<<32 + 0x958885C4, U64(0xE95FAB36)<<32 + 0x8E45ECED,
	U64(0x88B402F7)<<32 + 0xFD75539B, U64(0x11DBCB02)<<32 + 0x18EBB414,
	U64(0xAAE103B5)<<32 + 0xFCD2A881, U64(0xD652BDC2)<<32 + 0x9F26A119,
	U64(0xD59944A3)<<32 + 0x7C0752A2, U64(0x4BE76D33)<<32 + 0x46F0495F,
	U64(0x857FCAE6)<<32 + 0x2D8493A5, U64(0x6F70A440)<<32 + 0x0C562DDB,
	U64(0xA6DFBD9F)<<32 + 0xB8E5B88E, U64(0xCB4CCD50)<<32 + 0x0F6BB952,
	U64(0xD097AD07)<<32 + 0xA71F26B2, U64(0x7E2000A4)<<32 + 0x1346A7A7,
	U64(0x825ECC24)<<32 + 0xC873782F, U64(0x8ED40066)<<32 + 0x8C0C28C8,
	U64(0xA2F67F2D)<<32 + 0xFA90563B, U64(0x72890080)<<32 + 0x2F0F32FA,
	U64(0xCBB41EF9)<<32 + 0x79346BCA, U64(0x4F2B40A0)<<32 + 0x3AD2FFB9,
	U64(0xFEA126B7)<<32 + 0xD78186BC, U64(0xE2F610C8)<<32 + 0x4987BFA8,
	U64(0x9F24B832)<<32 + 0xE6B0F436, U64(0x0DD9CA7D)<<32 + 0x2DF4D7C9,
	U64(0xC6EDE63F)<<32 + 0xA05D3143, U64(0x91503D1C)<<32 + 0x79720DBB,
	U64(0xF8A95FCF)<<32 + 0x88747D94, U64(0x75A44C63)<<32 + 0x97CE912A,
	U64(0x9B69DBE1)<<32 + 0xB548CE7C, U64(0xC986AFBE)<<32 + 0x3EE11ABA,
	U64(0xC24452DA)<<32 + 0x229B021B, U64(0xFBE85BAD)<<32 + 0xCE996168,
	U64(0xF2D56790)<<32 + 0xAB41C2A2, U64(0xFAE27299)<<32 + 0x423FB9C3,
	U64(0x97C560BA)<<32 + 0x6B0919A5, U64(0xDCCD879F)<<32 + 0xC967D41A,
	U64(0xBDB6B8E9)<<32 + 0x05CB600F, U64(0x5400E987)<<32 + 0xBBC1C920,
	U64(0xED246723)<<32 + 0x473E3813, U64(0x290123E9)<<32 + 0xAAB23B68,
	U64(0x9436C076)<<32 + 0x0C86E30B, U64(0xF9A0B672)<<32 + 0x0AAF6521,
	U64(0xB9447093)<<32 + 0x8FA89BCE, U64(0xF808E40E)<<32 + 0x8D5B3E69,
	U64(0xE7958CB8)<<32 + 0x7392C2C2, U64(0xB60B1D12)<<32 + 0x30B20E04,
	U64(0x90BD77F3)<<32 + 0x483BB9B9, U64(0xB1C6F22B)<<32 + 0x5E6F48C2,
	U64(0xB4ECD5F0)<<32 + 0x1A4AA828, U64(0x1E38AEB6)<<32 + 0x360B1AF3,
	U64(0xE2280B6C)<<32 + 0x20DD5232, U64(0x25C6DA63)<<32 + 0xC38DE1B0,
	U64(0x8D590723)<<32 + 0x948A535F, U64(0x579C487E)<<32 + 0x5A38AD0E,
	U64(0xB0AF48EC)<<32 + 0x79ACE837, U64(0x2D835A9D)<<32 + 0xF0C6D851,
	U64(0xDCDB1B27)<<32 + 0x98182244, U64(0xF8E43145)<<32 + 0x6CF88E65,
	U64(0x8A08F0F8)<<32 + 0xBF0F156B, U64(0x1B8E9ECB)<<32 + 0x641B58FF,
	U64(0xAC8B2D36)<<32 + 0xEED2DAC5, U64(0xE272467E)<<32 + 0x3D222F3F,
	U64(0xD7ADF884)<<32 + 0xAA879177, U64(0x5B0ED81D)<<32 + 0xCC6ABB0F,
	U64(0x86CCBB52)<<32 + 0xEA94BAEA, U64(0x98E94712)<<32 + 0x9FC2B4E9,
	U64(0xA87FEA27)<<32 + 0xA539E9A5, U64(0x3F2398D7)<<32 + 0x47B36224,
	U64(0xD29FE4B1)<<32 + 0x8E88640E, U64(0x8EEC7F0D)<<32 + 0x19A03AAD,
	U64(0x83A3EEEE)<<32 + 0xF9153E89, U64(0x1953CF68)<<32 + 0x300424AC,
	U64(0xA48CEAAA)<<32 + 0xB75A8E2B, U64(0x5FA8C342)<<32 + 0x3C052DD7,
	U64(0xCDB02555)<<32 + 0x653131B6, U64(0x3792F412)<<32 + 0xCB06794D,
	U64(0x808E1755)<<32 + 0x5F3EBF11, U64(0xE2BBD88B)<<32 + 0xBEE40BD0,
	U64(0xA0B19D2A)<<32 + 0xB70E6ED6, U64(0x5B6ACEAE)<<32 + 0xAE9D0EC4,
	U64(0xC8DE0475)<<32 + 0x64D20A8B, U64(0xF245825A)<<32 + 0x5A445275,
	U64(0xFB158592)<<32 + 0xBE068D2E, U64(0xEED6E2F0)<<32 + 0xF0D56712,
	U64(0x9CED737B)<<32 + 0xB6C4183D, U64(0x55464DD6)<<32 + 0x9685606B,
	U64(0xC428D05A)<<32 + 0xA4751E4C, U64(0xAA97E14C)<<32 + 0x3C26B886,
	U64(0xF5330471)<<32 + 0x4D9265DF, U64(0xD53DD99F)<<32 + 0x4B3066A8,
	U64(0x993FE2C6)<<32 + 0xD07B7FAB, U64(0xE546A803)<<32 + 0x8EFE4029,
	U64(0xBF8FDB78)<<32 + 0x849A5F96, U64(0xDE985204)<<32 + 0x72BDD033,
	U64(0xEF73D256)<<32 + 0xA5C0F77C, U64(0x963E6685)<<32 + 0x8F6D4440,
	U64(0x95A86376)<<32 + 0x27989AAD, U64(0xDDE70013)<<32 + 0x79A44AA8,
	U64(0xBB127C53)<<32 + 0xB17EC159, U64(0x5560C018)<<32 + 0x580D5D52,
	U64(0xE9D71B68)<<32 + 0x9DDE71AF, U64(0xAAB8F01E)<<32 + 0x6E10B4A6,
	U64(0x92267121)<<32 + 0x62AB070D, U64(0xCAB39613)<<32 + 0x04CA70E8,
	U64(0xB6B00D69)<<32 + 0xBB55C8D1, U64(0x3D607B97)<<32 + 0xC5FD0D22,
	U64(0xE45C10C4)<<32 + 0x2A2B3B05, U64(0x8CB89A7D)<<32 + 0xB77C506A,
	U64(0x8EB98A7A)<<32 + 0x9A5B04E3, U64(0x77F3608E)<<32 + 0x92ADB242,
	U64(0xB267ED19)<<32 + 0x40F1C61C, U64(0x55F038B2)<<32 + 0x37591ED3,
	U64(0xDF01E85F)<<32 + 0x912E37A3, U64(0x6B6C46DE)<<32 + 0xC52F6688,
	U64(0x8B61313B)<<32 + 0xBABCE2C6, U64(0x2323AC4B)<<32 + 0x3B3DA015,
	U64(0xAE397D8A)<<32 + 0xA96C1B77, U64(0xABEC975E)<<32 + 0x0A0D081A,
	U64(0xD9C7DCED)<<32 + 0x53C72255, U64(0x96E7BD35)<<32 + 0x8C904A21,
	U64(0x881CEA14)<<32 + 0x545C7575, U64(0x7E50D641)<<32 + 0x77DA2E54,
	U64(0xAA242499)<<32 + 0x697392D2, U64(0xDDE50BD1)<<32 + 0xD5D0B9E9,
	U64(0xD4AD2DBF)<<32 + 0xC3D07787, U64(0x955E4EC6)<<32 + 0x4B44E864,
	U64(0x84EC3C97)<<32 + 0xDA624AB4, U64(0xBD5AF13B)<<32 + 0xEF0B113E,
	U64(0xA6274BBD)<<32 + 0xD0FADD61, U64(0xECB1AD8A)<<32 + 0xEACDD58E,
	U64(0xCFB11EAD)<<32 + 0x453994BA, U64(0x67DE18ED)<<32 + 0xA5814AF2,
	U64(0x81CEB32C)<<32 + 0x4B43FCF4, U64(0x80EACF94)<<32 + 0x8770CED7,
	U64(0xA2425FF7)<<32 + 0x5E14FC31, U64(0xA1258379)<<32 + 0xA94D028D,
	U64(0xCAD2F7F5)<<32 + 0x359A3B3E, U64(0x096EE458)<<32 + 0x13A04330,
	U64(0xFD87B5F2)<<32 + 0x8300CA0D, U64(0x8BCA9D6E)<<32 + 0x188853FC,
	U64(0x9E74D1B7)<<32 + 0x91E07E48, U64(0x775EA264)<<32 + 0xCF55347D,
	U64(0xC6120625)<<32 + 0x76589DDA, U64(0x95364AFE)<<32 + 0x032A819D,
	U64(0xF79687AE)<<32 + 0xD3EEC551, U64(0x3A83DDBD)<<32 + 0x83F52204,
	U64(0x9ABE14CD)<<32 + 0x44753B52, U64(0xC4926A96)<<32 + 0x72793542,
	U64(0xC16D9A00)<<32 + 0x95928A27, U64(0x75B7053C)<<32 + 0x0F178293,
	U64(0xF1C90080)<<32 + 0xBAF72CB1, U64(0x5324C68B)<<32 + 0x12DD6338,
	U64(0x971DA050)<<32 + 0x74DA7BEE, U64(0xD3F6FC16)<<32 + 0xEBCA5E03,
	U64(0xBCE50864)<<32 + 0x92111AEA, U64(0x88F4BB1C)<<32 + 0xA6BCF584,
	U64(0xEC1E4A7D)<<32 + 0xB69561A5, U64(0x2B31E9E3)<<32 + 0xD06C32E5,
	U64(0x9392EE8E)<<32 + 0x921D5D07, U64(0x3AFF322E)<<32 + 0x62439FCF,
	U64(0xB877AA32)<<32 + 0x36A4B449, U64(0x09BEFEB9)<<32 + 0xFAD487C2,
	U64(0xE69594BE)<<32 + 0xC44DE15B, U64(0x4C2EBE68)<<32 + 0x7989A9B3,
	U64(0x901D7CF7)<<32 + 0x3AB0ACD9, U64(0x0F9D3701)<<32 + 0x4BF60A10,
	U64(0xB424DC35)<<32 + 0x095CD80F, U64(0x538484C1)<<32 + 0x9EF38C94,
	U64(0xE12E1342)<<32 + 0x4BB40E13, U64(0x2865A5F2)<<32 + 0x06B06FB9,
	U64(0x8CBCCC09)<<32 + 0x6F5088CB, U64(0xF93F87B7)<<32 + 0x442E45D3,
	U64(0xAFEBFF0B)<<32 + 0xCB24AAFE, U64(0xF78F69A5)<<32 + 0x1539D748,
	U64(0xDBE6FECE)<<32 + 0xBDEDD5BE, U64(0xB573440E)<<32 + 0x5A884D1B,
	U64(0x89705F41)<<32 + 0x36B4A597, U64(0x31680A88)<<32 + 0xF8953030,
	U64(0xABCC7711)<<32 + 0x8461CEFC, U64(0xFDC20D2B)<<32 + 0x36BA7C3D,
	U64(0xD6BF94D5)<<32 + 0xE57A42BC, U64(0x3D329076)<<32 + 0x04691B4C,
	U64(0x8637BD05)<<32 + 0xAF6C69B5, U64(0xA63F9A49)<<32 + 0xC2C1B10F,
	U64(0xA7C5AC47)<<32 + 0x1B478423, U64(0x0FCF80DC)<<32 + 0x33721D53,
	U64(0xD1B71758)<<32 + 0xE219652B, U64(0xD3C36113)<<32 + 0x404EA4A8,
	U64(0x83126E97)<<32 + 0x8D4FDF3B, U64(0x645A1CAC)<<32 + 0x083126E9,
	U64(0xA3D70A3D)<<32 + 0x70A3D70A, U64(0x3D70A3D7)<<32 + 0x0A3D70A3,
	U64(0xCCCCCCCC)<<32 + 0xCCCCCCCC, U64(0xCCCCCCCC)<<32 + 0xCCCCCCCC,
	U64(0x80000000)<<32 + 0x00000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xA0000000)<<32 + 0x00000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xC8000000)<<32 + 0x00000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xFA000000)<<32 + 0x00000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0x9C400000)<<32 + 0x00000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xC3500000)<<32 + 0x00000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xF4240000)<<32 + 0x00000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0x98968000)<<32 + 0x00000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xBEBC2000)<<32 + 0x00000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xEE6B2800)<<32 + 0x00000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0x9502F900)<<32 + 0x00000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xBA43B740)<<32 + 0x00000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xE8D4A510)<<32 + 0x00000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0x9184E72A)<<32 + 0x00000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xB5E620F4)<<32 + 0x80000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xE35FA931)<<32 + 0xA0000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0x8E1BC9BF)<<32 + 0x04000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xB1A2BC2E)<<32 + 0xC5000000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xDE0B6B3A)<<32 + 0x76400000, U64(0x00000000)<<32 + 0x00000000,
	U64(0x8AC72304)<<32 + 0x89E80000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xAD78EBC5)<<32 + 0xAC620000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xD8D726B7)<<32 + 0x177A8000, U64(0x00000000)<<32 + 0x00000000,
	U64(0x87867832)<<32 + 0x6EAC9000, U64(0x00000000)<<32 + 0x00000000,
	U64(0xA968163F)<<32 + 0x0A57B400, U64(0x00000000)<<32 + 0x00000000,
	U64(0xD3C21BCE)<<32 + 0xCCEDA100, U64(0x00000000)<<32 + 0x00000000,
	U64(0x84595161)<<32 + 0x401484A0, U64(0x00000000)<<32 + 0x00000000,
	U64(0xA56FA5B9)<<32 + 0x9019A5C8, U64(0x00000000)<<32 + 0x00000000,
	U64(0xCECB8F27)<<32 + 0xF4200F3A, U64(0x00000000)<<32 + 0x00000000,
	U64(0x813F3978)<<32 + 0xF8940984, U64(0x40000000)<<32 + 0x00000000,
	U64(0xA18F07D7)<<32 + 0x36B90BE5, U64(0x50000000)<<32 + 0x00000000,
	U64(0xC9F2C9CD)<<32 + 0x04674EDE, U64(0xA4000000)<<32 + 0x00000000,
	U64(0xFC6F7C40)<<32 + 0x45812296, U64(0x4D000000)<<32 + 0x00000000,
	U64(0x9DC5ADA8)<<32 + 0x2B70B59D, U64(0xF0200000)<<32 + 0x00000000,
	U64(0xC5371912)<<32 + 0x364CE305, U64(0x6C280000)<<32 + 0x00000000,
	U64(0xF684DF56)<<32 + 0xC3E01BC6, U64(0xC7320000)<<32 + 0x00000000,
	U64(0x9A130B96)<<32 + 0x3A6C115C, U64(0x3C7F4000)<<32 + 0x00000000,
	U64(0xC097CE7B)<<32 + 0xC90715B3, U64(0x4B9F1000)<<32 + 0x00000000,
	U64(0xF0BDC21A)<<32 + 0xBB48DB20, U64(0x1E86D400)<<32 + 0x00000000,
	U64(0x96769950)<<32 + 0xB50D88F4, U64(0x13144480)<<32 + 0x00000000,
	U64(0xBC143FA4)<<32 + 0xE250EB31, U64(0x17D955A0)<<32 + 0x00000000,
	U64(0xEB194F8E)<<32 + 0x1AE525FD, U64(0x5DCFAB08)<<32 + 0x00000000,
	U64(0x92EFD1B8)<<32 + 0xD0CF37BE, U64(0x5AA1CAE5)<<32 + 0x00000000,
	U64(0xB7ABC627)<<32 + 0x050305AD, U64(0xF14A3D9E)<<32 + 0x40000000,
	U64(0xE596B7B0)<<32 + 0xC643C719, U64(0x6D9CCD05)<<32 + 0xD0000000,
	U64(0x8F7E32CE)<<32 + 0x7BEA5C6F, U64(0xE4820023)<<32 + 0xA2000000,
	U64(0xB35DBF82)<<32 + 0x1AE4F38B, U64(0xDDA2802C)<<32 + 0x8A800000,
	U64(0xE0352F62)<<32 + 0xA19E306E, U64(0xD50B2037)<<32 + 0xAD200000,
	U64(0x8C213D9D)<<32 + 0xA502DE45, U64(0x4526F422)<<32 + 0xCC340000,
	U64(0xAF298D05)<<32 + 0x0E4395D6, U64(0x9670B12B)<<32 + 0x7F410000,
	U64(0xDAF3F046)<<32 + 0x51D47B4C, U64(0x3C0CDD76)<<32 + 0x5F114000,
	U64(0x88D8762B)<<32 + 0xF324CD0F, U64(0xA5880A69)<<32 + 0xFB6AC800,
	U64(0xAB0E93B6)<<32 + 0xEFEE0053, U64(0x8EEA0D04)<<32 + 0x7A457A00,
	U64(0xD5D238A4)<<32 + 0xABE98068, U64(0x72A49045)<<32 + 0x98D6D880,
	U64(0x85A36366)<<32 + 0xEB71F041, U64(0x47A6DA2B)<<32 + 0x7F864750,
	U64(0xA70C3C40)<<32 + 0xA64E6C51, U64(0x999090B6)<<32 + 0x5F67D924,
	U64(0xD0CF4B50)<<32 + 0xCFE20765, U64(0xFFF4B4E3)<<32 + 0xF741CF6D,
	U64(0x82818F12)<<32 + 0x81ED449F, U64(0xBFF8F10E)<<32 + 0x7A8921A4,
	U64(0xA321F2D7)<<32 + 0x226895C7, U64(0xAFF72D52)<<32 + 0x192B6A0D,
	U64(0xCBEA6F8C)<<32 + 0xEB02BB39, U64(0x9BF4F8A6)<<32 + 0x9F764490,
	U64(0xFEE50B70)<<32 + 0x25C36A08, U64(0x02F236D0)<<32 + 0x4753D5B4,
	U64(0x9F4F2726)<<32 + 0x179A2245, U64(0x01D76242)<<32 + 0x2C946590,
	U64(0xC722F0EF)<<32 + 0x9D80AAD6, U64(0x424D3AD2)<<32 + 0xB7B97EF5,
	U64(0xF8EBAD2B)<<32 + 0x84E0D58B, U64(0xD2E08987)<<32 + 0x65A7DEB2,
	U64(0x9B934C3B)<<32 + 0x330C8577, U64(0x63CC55F4)<<32 + 0x9F88EB2F,
	U64(0xC2781F49)<<32 + 0xFFCFA6D5, U64(0x3CBF6B71)<<32 + 0xC76B25FB,
	U64(0xF316271C)<<32 + 0x7FC3908A, U64(0x8BEF464E)<<32 + 0x3945EF7A,
	U64(0x97EDD871)<<32 + 0xCFDA3A56, U64(0x97758BF0)<<32 + 0xE3CBB5AC,
	U64(0xBDE94E8E)<<32 + 0x43D0C8EC, U64(0x3D52EEED)<<32 + 0x1CBEA317,
	U64(0xED63A231)<<32 + 0xD4C4FB27, U64(0x4CA7AAA8)<<32 + 0x63EE4BDD,
	U64(0x945E455F)<<32 + 0x24FB1CF8, U64(0x8FE8CAA9)<<32 + 0x3E74EF6A,
	U64(0xB975D6B6)<<32 + 0xEE39E436, U64(0xB3E2FD53)<<32 + 0x8E122B44,
	U64(0xE7D34C64)<<32 + 0xA9C85D44, U64(0x60DBBCA8)<<32 + 0x7196B616,
	U64(0x90E40FBE)<<32 + 0xEA1D3A4A, U64(0xBC8955E9)<<32 + 0x46FE31CD,
	U64(0xB51D13AE)<<32 + 0xA4A488DD, U64(0x6BABAB63)<<32 + 0x98BDBE41,
	U64(0xE264589A)<<32 + 0x4DCDAB14, U64(0xC696963C)<<32 + 0x7EED2DD1,
	U64(0x8D7EB760)<<32 + 0x70A08AEC, U64(0xFC1E1DE5)<<32 + 0xCF543CA2,
	U64(0xB0DE6538)<<32 + 0x8CC8ADA8, U64(0x3B25A55F)<<32 + 0x43294BCB,
	U64(0xDD15FE86)<<32 + 0xAFFAD912, U64(0x49EF0EB7)<<32 + 0x13F39EBE,
	U64(0x8A2DBF14)<<32 + 0x2DFCC7AB, U64(0x6E356932)<<32 + 0x6C784337,
	U64(0xACB92ED9)<<32 + 0x397BF996, U64(0x49C2C37F)<<32 + 0x07965404,
	U64(0xD7E77A8F)<<32 + 0x87DAF7FB, U64(0xDC33745E)<<32 + 0xC97BE906,
	U64(0x86F0AC99)<<32 + 0xB4E8DAFD, U64(0x69A028BB)<<32 + 0x3DED71A3,
	U64(0xA8ACD7C0)<<32 + 0x222311BC, U64(0xC40832EA)<<32 + 0x0D68CE0C,
	U64(0xD2D80DB0)<<32 + 0x2AABD62B, U64(0xF50A3FA4)<<32 + 0x90C30190,
	U64(0x83C7088E)<<32 + 0x1AAB65DB, U64(0x792667C6)<<32 + 0xDA79E0FA,
	U64(0xA4B8CAB1)<<32 + 0xA1563F52, U64(0x577001B8)<<32 + 0x91185938,
	U64(0xCDE6FD5E)<<32 + 0x09ABCF26, U64(0xED4C0226)<<32 + 0xB55E6F86,
	U64(0x80B05E5A)<<32 + 0xC60B6178, U64(0x544F8158)<<32 + 0x315B05B4,
	U64(0xA0DC75F1)<<32 + 0x778E39D6, U64(0x696361AE)<<32 + 0x3DB1C721,
	U64(0xC913936D)<<32 + 0xD571C84C, U64(0x03BC3A19)<<32 + 0xCD1E38E9,
	U64(0xFB587849)<<32 + 0x4ACE3A5F, U64(0x04AB48A0)<<32 + 0x4065C723,
	U64(0x9D174B2D)<<32 + 0xCEC0E47B, U64(0x62EB0D64)<<32 + 0x283F9C76,
	U64(0xC45D1DF9)<<32 + 0x42711D9A, U64(0x3BA5D0BD)<<32 + 0x324F8394,
	U64(0xF5746577)<<32 + 0x930D6500, U64(0xCA8F44EC)<<32 + 0x7EE36479,
	U64(0x9968BF6A)<<32 + 0xBBE85F20, U64(0x7E998B13)<<32 + 0xCF4E1ECB,
	U64(0xBFC2EF45)<<32 + 0x6AE276E8, U64(0x9E3FEDD8)<<32 + 0xC321A67E,
	U64(0xEFB3AB16)<<32 + 0xC59B14A2, U64(0xC5CFE94E)<<32 + 0xF3EA101E,
	U64(0x95D04AEE)<<32 + 0x3B80ECE5, U64(0xBBA1F1D1)<<32 + 0x58724A12,
	U64(0xBB445DA9)<<32 + 0xCA61281F, U64(0x2A8A6E45)<<32 + 0xAE8EDC97,
	U64(0xEA157514)<<32 + 0x3CF97226, U64(0xF52D09D7)<<32 + 0x1A3293BD,
	U64(0x924D692C)<<32 + 0xA61BE758, U64(0x593C2626)<<32 + 0x705F9C56,
	U64(0xB6E0C377)<<32 + 0xCFA2E12E, U64(0x6F8B2FB0)<<32 + 0x0C77836C,
	U64(0xE498F455)<<32 + 0xC38B997A, U64(0x0B6DFB9C)<<32 + 0x0F956447,
	U64(0x8EDF98B5)<<32 + 0x9A373FEC, U64(0x4724BD41)<<32 + 0x89BD5EAC,
	U64(0xB2977EE3)<<32 + 0x00C50FE7, U64(0x58EDEC91)<<32 + 0xEC2CB657,
	U64(0xDF3D5E9B)<<32 + 0xC0F653E1, U64(0x2F2967B6)<<32 + 0x6737E3ED,
	U64(0x8B865B21)<<32 + 0x5899F46C, U64(0xBD79E0D2)<<32 + 0x0082EE74,
	U64(0xAE67F1E9)<<32 + 0xAEC07187, U64(0xECD85906)<<32 + 0x80A3AA11,
	U64(0xDA01EE64)<<32 + 0x1A708DE9, U64(0xE80E6F48)<<32 + 0x20CC9495,
	U64(0x884134FE)<<32 + 0x908658B2, U64(0x3109058D)<<32 + 0x147FDCDD,
	U64(0xAA51823E)<<32 + 0x34A7EEDE, U64(0xBD4B46F0)<<32 + 0x599FD415,
	U64(0xD4E5E2CD)<<32 + 0xC1D1EA96, U64(0x6C9E18AC)<<32 + 0x7007C91A,
	U64(0x850FADC0)<<32 + 0x9923329E, U64(0x03E2CF6B)<<32 + 0xC604DDB0,
	U64(0xA6539930)<<32 + 0xBF6BFF45, U64(0x84DB8346)<<32 + 0xB786151C,
	U64(0xCFE87F7C)<<32 + 0xEF46FF16, U64(0xE6126418)<<32 + 0x65679A63,
	U64(0x81F14FAE)<<32 + 0x158C5F6E, U64(0x4FCB7E8F)<<32 + 0x3F60C07E,
	U64(0xA26DA399)<<32 + 0x9AEF7749, U64(0xE3BE5E33)<<32 + 0x0F38F09D,
	U64(0xCB090C80)<<32 + 0x01AB551C, U64(0x5CADF5BF)<<32 + 0xD3072CC5,
	U64(0xFDCB4FA0)<<32 + 0x02162A63, U64(0x73D9732F)<<32 + 0xC7C8F7F6,
	U64(0x9E9F11C4)<<32 + 0x014DDA7E, U64(0x2867E7FD)<<32 + 0xDCDD9AFA,
	U64(0xC646D635)<<32 + 0x01A1511D, U64(0xB281E1FD)<<32 + 0x541501B8,
	U64(0xF7D88BC2)<<32 + 0x4209A565, U64(0x1F225A7C)<<32 + 0xA91A4226,
	U64(0x9AE75759)<<32 + 0x6946075F, U64(0x3375788D)<<32 + 0xE9B06958,
	U64(0xC1A12D2F)<<32 + 0xC3978937, U64(0x0052D6B1)<<32 + 0x641C83AE,
	U64(0xF209787B)<<32 + 0xB47D6B84, U64(0xC0678C5D)<<32 + 0xBD23A49A,
	U64(0x9745EB4D)<<32 + 0x50CE6332, U64(0xF840B7BA)<<32 + 0x963646E0,
	U64(0xBD176620)<<32 + 0xA501FBFF, U64(0xB650E5A9)<<32 + 0x3BC3D898,
	U64(0xEC5D3FA8)<<32 + 0xCE427AFF, U64(0xA3E51F13)<<32 + 0x8AB4CEBE,
	U64(0x93BA47C9)<<32 + 0x80E98CDF, U64(0xC66F336C)<<32 + 0x36B10137,
	U64(0xB8A8D9BB)<<32 + 0xE123F017, U64(0xB80B0047)<<32 + 0x445D4184,
	U64(0xE6D3102A)<<32 + 0xD96CEC1D, U64(0xA60DC059)<<32 + 0x157491E5,
	U64(0x9043EA1A)<<32 + 0xC7E41392, U64(0x87C89837)<<32 + 0xAD68DB2F,
	U64(0xB454E4A1)<<32 + 0x79DD1877, U64(0x29BABE45)<<32 + 0x98C311FB,
	U64(0xE16A1DC9)<<32 + 0xD8545E94, U64(0xF4296DD6)<<32 + 0xFEF3D67A,
	U64(0x8CE2529E)<<32 + 0x2734BB1D, U64(0x1899E4A6)<<32 + 0x5F58660C,
	U64(0xB01AE745)<<32 + 0xB101E9E4, U64(0x5EC05DCF)<<32 + 0xF72E7F8F,
	U64(0xDC21A117)<<32 + 0x1D42645D, U64(0x76707543)<<32 + 0xF4FA1F73,
	U64(0x899504AE)<<32 + 0x72497EBA, U64(0x6A06494A)<<32 + 0x791C53A8,
	U64(0xABFA45DA)<<32 + 0x0EDBDE69, U64(0x0487DB9D)<<32 + 0x17636892,
	U64(0xD6F8D750)<<32 + 0x9292D603, U64(0x45A9D284)<<32 + 0x5D3C42B6,
	U64(0x865B8692)<<32 + 0x5B9BC5C2, U64(0x0B8A2392)<<32 + 0xBA45A9B2,
	U64(0xA7F26836)<<32 + 0xF282B732, U64(0x8E6CAC77)<<32 + 0x68D7141E,
	U64(0xD1EF0244)<<32 + 0xAF2364FF, U64(0x3207D795)<<32 + 0x430CD926,
	U64(0x8335616A)<<32 + 0xED761F1F, U64(0x7F44E6BD)<<32 + 0x49E807B8,
	U64(0xA402B9C5)<<32 + 0xA8D3A6E7, U64(0x5F16206C)<<32 + 0x9C6209A6,
	U64(0xCD036837)<<32 + 0x130890A1, U64(0x36DBA887)<<32 + 0xC37A8C0F,
	U64(0x80222122)<<32 + 0x6BE55A64, U64(0xC2494954)<<32 + 0xDA2C9789,
	U64(0xA02AA96B)<<32 + 0x06DEB0FD, U64(0xF2DB9BAA)<<32 + 0x10B7BD6C,
	U64(0xC83553C5)<<32 + 0xC8965D3D, U64(0x6F928294)<<32 + 0x94E5ACC7,
	U64(0xFA42A8B7)<<32 + 0x3ABBF48C, U64(0xCB772339)<<32 + 0xBA1F17F9,
	U64(0x9C69A972)<<32 + 0x84B578D7, U64(0xFF2A7604)<<32 + 0x14536EFB,
	U64(0xC38413CF)<<32 + 0x25E2D70D, U64(0xFEF51385)<<32 + 0x19684ABA,
	U64(0xF46518C2)<<32 + 0xEF5B8CD1, U64(0x7EB25866)<<32 + 0x5FC25D69,
	U64(0x98BF2F79)<<32 + 0xD5993802, U64(0xEF2F773F)<<32 + 0xFBD97A61,
	U64(0xBEEEFB58)<<32 + 0x4AFF8603, U64(0xAAFB550F)<<32 + 0xFACFD8FA,
	U64(0xEEAABA2E)<<32 + 0x5DBF6784, U64(0x95BA2A53)<<32 + 0xF983CF38,
	U64(0x952AB45C)<<32 + 0xFA97A0B2, U64(0xDD945A74)<<32 + 0x7BF26183,
	U64(0xBA756174)<<32 + 0x393D88DF, U64(0x94F97111)<<32 + 0x9AEEF9E4,
	U64(0xE912B9D1)<<32 + 0x478CEB17, U64(0x7A37CD56)<<32 + 0x01AAB85D,
	U64(0x91ABB422)<<32 + 0xCCB812EE, U64(0xAC62E055)<<32 + 0xC10AB33A,
	U64(0xB616A12B)<<32 + 0x7FE617AA, U64(0x577B986B)<<32 + 0x314D6009,
	U64(0xE39C4976)<<32 + 0x5FDF9D94, U64(0xED5A7E85)<<32 + 0xFDA0B80B,
	U64(0x8E41ADE9)<<32 + 0xFBEBC27D, U64(0x14588F13)<<32 + 0xBE847307,
	U64(0xB1D21964)<<32 + 0x7AE6B31C, U64(0x596EB2D8)<<32 + 0xAE258FC8,
	U64(0xDE469FBD)<<32 + 0x99A05FE3, U64(0x6FCA5F8E)<<32 + 0xD9AEF3BB,
	U64(0x8AEC23D6)<<32 + 0x80043BEE, U64(0x25DE7BB9)<<32 + 0x480D5854,
	U64(0xADA72CCC)<<32 + 0x20054AE9, U64(0xAF561AA7)<<32 + 0x9A10AE6A,
	U64(0xD910F7FF)<<32 + 0x28069DA4, U64(0x1B2BA151)<<32 + 0x8094DA04,
	U64(0x87AA9AFF)<<32 + 0x79042286, U64(0x90FB44D2)<<32 + 0xF05D0842,
	U64(0xA99541BF)<<32 + 0x57452B28, U64(0x353A1607)<<32 + 0xAC744A53,
	U64(0xD3FA922F)<<32 + 0x2D1675F2, U64(0x42889B89)<<32 + 0x97915CE8,
	U64(0x847C9B5D)<<32 + 0x7C2E09B7, U64(0x69956135)<<32 + 0xFEBADA11,
	U64(0xA59BC234)<<32 + 0xDB398C25, U64(0x43FAB983)<<32 + 0x7E699095,
	U64(0xCF02B2C2)<<32 + 0x1207EF2E, U64(0x94F967E4)<<32 + 0x5E03F4BB,
	U64(0x8161AFB9)<<32 + 0x4B44F57D, U64(0x1D1BE0EE)<<32 + 0xBAC278F5,
	U64(0xA1BA1BA7)<<32 + 0x9E1632DC, U64(0x6462D92A)<<32 + 0x69731732,
	U64(0xCA28A291)<<32 + 0x859BBF93, U64(0x7D7B8F75)<<32 + 0x03CFDCFE,
	U64(0xFCB2CB35)<<32 + 0xE702AF78, U64(0x5CDA7352)<<32 + 0x44C3D43E,
	U64(0x9DEFBF01)<<32 + 0xB061ADAB, U64(0x3A088813)<<32 + 0x6AFA64A7,
	U64(0xC56BAEC2)<<32 + 0x1C7A1916, U64(0x088AAA18)<<32 + 0x45B8FDD0,
	U64(0xF6C69A72)<<32 + 0xA3989F5B, U64(0x8AAD549E)<<32 + 0x57273D45,
	U64(0x9A3C2087)<<32 + 0xA63F6399, U64(0x36AC54E2)<<32 + 0xF678864B,
	U64(0xC0CB28A9)<<32 + 0x8FCF3C7F, U64(0x84576A1B)<<32 + 0xB416A7DD,
	U64(0xF0FDF2D3)<<32 + 0xF3C30B9F, U64(0x656D44A2)<<32 + 0xA11C51D5,
	U64(0x969EB7C4)<<32 + 0x7859E743, U64(0x9F644AE5)<<32 + 0xA4B1B325,
	U64(0xBC4665B5)<<32 + 0x96706114, U64(0x873D5D9F)<<32 + 0x0DDE1FEE,
	U64(0xEB57FF22)<<32 + 0xFC0C7959, U64(0xA90CB506)<<32 + 0xD155A7EA,
	U64(0x9316FF75)<<32 + 0xDD87CBD8, U64(0x09A7F124)<<32 + 0x42D588F2,
	U64(0xB7DCBF53)<<32 + 0x54E9BECE, U64(0x0C11ED6D)<<32 + 0x538AEB2F,
	U64(0xE5D3EF28)<<32 + 0x2A242E81, U64(0x8F1668C8)<<32 + 0xA86DA5FA,
	U64(0x8FA47579)<<32 + 0x1A569D10, U64(0xF96E017D)<<32 + 0x694487BC,
	U64(0xB38D92D7)<<32 + 0x60EC4455, U64(0x37C981DC)<<32 + 0xC395A9AC,
	U64(0xE070F78D)<<32 + 0x3927556A, U64(0x85BBE253)<<32 + 0xF47B1417,
	U64(0x8C469AB8)<<32 + 0x43B89562, U64(0x93956D74)<<32 + 0x78CCEC8E,
	U64(0xAF584166)<<32 + 0x54A6BABB, U64(0x387AC8D1)<<32 + 0x970027B2,
	U64(0xDB2E51BF)<<32 + 0xE9D0696A, U64(0x06997B05)<<32 + 0xFCC0319E,
	U64(0x88FCF317)<<32 + 0xF22241E2, U64(0x441FECE3)<<32 + 0xBDF81F03,
	U64(0xAB3C2FDD)<<32 + 0xEEAAD25A, U64(0xD527E81C)<<32 + 0xAD7626C3,
	U64(0xD60B3BD5)<<32 + 0x6A5586F1, U64(0x8A71E223)<<32 + 0xD8D3B074,
	U64(0x85C70565)<<32 + 0x62757456, U64(0xF6872D56)<<32 + 0x67844E49,
	U64(0xA738C6BE)<<32 + 0xBB12D16C, U64(0xB428F8AC)<<32 + 0x016561DB,
	U64(0xD106F86E)<<32 + 0x69D785C7, U64(0xE13336D7)<<32 + 0x01BEBA52,
	U64(0x82A45B45)<<32 + 0x0226B39C, U64(0xECC00246)<<32 + 0x61173473,
	U64(0xA34D7216)<<32 + 0x42B06084, U64(0x27F002D7)<<32 + 0xF95D0190,
	U64(0xCC20CE9B)<<32 + 0xD35C78A5, U64(0x31EC038D)<<32 + 0xF7B441F4,
	U64(0xFF290242)<<32 + 0xC83396CE, U64(0x7E670471)<<32 + 0x75A15271,
	U64(0x9F79A169)<<32 + 0xBD203E41, U64(0x0F0062C6)<<32 + 0xE984D386,
	U64(0xC75809C4)<<32 + 0x2C684DD1, U64(0x52C07B78)<<32 + 0xA3E60868,
	U64(0xF92E0C35)<<32 + 0x37826145, U64(0xA7709A56)<<32 + 0xCCDF8A82,
	U64(0x9BBCC7A1)<<32 + 0x42B17CCB, U64(0x88A66076)<<32 + 0x400BB691,
	U64(0xC2ABF989)<<32 + 0x935DDBFE, U64(0x6ACFF893)<<32 + 0xD00EA435,
	U64(0xF356F7EB)<<32 + 0xF83552FE, U64(0x0583F6B8)<<32 + 0xC4124D43,
	U64(0x98165AF3)<<32 + 0x7B2153DE, U64(0xC3727A33)<<32 + 0x7A8B704A,
	U64(0xBE1BF1B0)<<32 + 0x59E9A8D6, U64(0x744F18C0)<<32 + 0x592E4C5C,
	U64(0xEDA2EE1C)<<32 + 0x7064130C, U64(0x1162DEF0)<<32 + 0x6F79DF73,
	U64(0x9485D4D1)<<32 + 0xC63E8BE7, U64(0x8ADDCB56)<<32 + 0x45AC2BA8,
	U64(0xB9A74A06)<<32 + 0x37CE2EE1, U64(0x6D953E2B)<<32 + 0xD7173692,
	U64(0xE8111C87)<<32 + 0xC5C1BA99, U64(0xC8FA8DB6)<<32 + 0xCCDD0437,
	U64(0x910AB1D4)<<32 + 0xDB9914A0, U64(0x1D9C9892)<<32 + 0x400A22A2,
	U64(0xB54D5E4A)<<32 + 0x127F59C8, U64(0x2503BEB6)<<32 + 0xD00CAB4B,
	U64(0xE2A0B5DC)<<32 + 0x971F303A, U64(0x2E44AE64)<<32 + 0x840FD61D,
	U64(0x8DA471A9)<<32 + 0xDE737E24, U64(0x5CEAECFE)<<32 + 0xD289E5D2,
	U64(0xB10D8E14)<<32 + 0x56105DAD, U64(0x7425A83E)<<32 + 0x872C5F47,
	U64(0xDD50F199)<<32 + 0x6B947518, U64(0xD12F124E)<<32 + 0x28F77719,
	U64(0x8A5296FF)<<32 + 0xE33CC92F, U64(0x82BD6B70)<<32 + 0xD99AAA6F,
	U64(0xACE73CBF)<<32 + 0xDC0BFB7B, U64(0x636CC64D)<<32 + 0x1001550B,
	U64(0xD8210BEF)<<32 + 0xD30EFA5A, U64(0x3C47F7E0)<<32 + 0x5401AA4E,
	U64(0x8714A775)<<32 + 0xE3E95C78, U64(0x65ACFAEC)<<32 + 0x34810A71,
	U64(0xA8D9D153)<<32 + 0x5CE3B396, U64(0x7F1839A7)<<32 + 0x41A14D0D,
	U64(0xD31045A8)<<32 + 0x341CA07C, U64(0x1EDE4811)<<32 + 0x1209A050,
	U64(0x83EA2B89)<<32 + 0x2091E44D, U64(0x934AED0A)<<32 + 0xAB460432,
	U64(0xA4E4B66B)<<32 + 0x68B65D60, U64(0xF81DA84D)<<32 + 0x5617853F,
	U64(0xCE1DE406)<<32 + 0x42E3F4B9, U64(0x36251260)<<32 + 0xAB9D668E,
	U64(0x80D2AE83)<<32 + 0xE9CE78F3, U64(0xC1D72B7C)<<32 + 0x6B426019,
	U64(0xA1075A24)<<32 + 0xE4421730, U64(0xB24CF65B)<<32 + 0x8612F81F,
	U64(0xC94930AE)<<32 + 0x1D529CFC, U64(0xDEE033F2)<<32 + 0x6797B627,
	U64(0xFB9B7CD9)<<32 + 0xA4A7443C, U64(0x169840EF)<<32 + 0x017DA3B1,
	U64(0x9D412E08)<<32 + 0x06E88AA5, U64(0x8E1F2895)<<32 + 0x60EE864E,
	U64(0xC491798A)<<32 + 0x08A2AD4E, U64(0xF1A6F2BA)<<32 + 0xB92A27E2,
	U64(0xF5B5D7EC)<<32 + 0x8ACB58A2, U64(0xAE10AF69)<<32 + 0x6774B1DB,
	U64(0x9991A6F3)<<32 + 0xD6BF1765, U64(0xACCA6DA1)<<32 + 0xE0A8EF29,
	U64(0xBFF610B0)<<32 + 0xCC6EDD3F, U64(0x17FD090A)<<32 + 0x58D32AF3,
	U64(0xEFF394DC)<<32 + 0xFF8A948E, U64(0xDDFC4B4C)<<32 + 0xEF07F5B0,
	U64(0x95F83D0A)<<32 + 0x1FB69CD9, U64(0x4ABDAF10)<<32 + 0x1564F98E,
	U64(0xBB764C4C)<<32 + 0xA7A4440F, U64(0x9D6D1AD4)<<32 + 0x1ABE37F1,
	U64(0xEA53DF5F)<<32 + 0xD18D5513, U64(0x84C86189)<<32 + 0x216DC5ED,
	U64(0x92746B9B)<<32 + 0xE2F8552C, U64(0x32FD3CF5)<<32 + 0xB4E49BB4,
	U64(0xB7118682)<<32 + 0xDBB66A77, U64(0x3FBC8C33)<<32 + 0x221DC2A1,
	U64(0xE4D5E823)<<32 + 0x92A40515, U64(0x0FABAF3F)<<32 + 0xEAA5334A,
	U64(0x8F05B116)<<32 + 0x3BA6832D, U64(0x29CB4D87)<<32 + 0xF2A7400E,
	U64(0xB2C71D5B)<<32 + 0xCA9023F8, U64(0x743E20E9)<<32 + 0xEF511012,
	U64(0xDF78E4B2)<<32 + 0xBD342CF6, U64(0x914DA924)<<32 + 0x6B255416,
	U64(0x8BAB8EEF)<<32 + 0xB6409C1A, U64(0x1AD089B6)<<32 + 0xC2F7548E,
	U64(0xAE9672AB)<<32 + 0xA3D0C320, U64(0xA184AC24)<<32 + 0x73B529B1,
	U64(0xDA3C0F56)<<32 + 0x8CC4F3E8, U64(0xC9E5D72D)<<32 + 0x90A2741E,
	U64(0x88658996)<<32 + 0x17FB1871, U64(0x7E2FA67C)<<32 + 0x7A658892,
	U64(0xAA7EEBFB)<<32 + 0x9DF9DE8D, U64(0xDDBB901B)<<32 + 0x98FEEAB7,
	U64(0xD51EA6FA)<<32 + 0x85785631, U64(0x552A7422)<<32 + 0x7F3EA565,
	U64(0x8533285C)<<32 + 0x936B35DE, U64(0xD53A8895)<<32 + 0x8F87275F,
	U64(0xA67FF273)<<32 + 0xB8460356, U64(0x8A892ABA)<<32 + 0xF368F137,
	U64(0xD01FEF10)<<32 + 0xA657842C, U64(0x2D2B7569)<<32 + 0xB0432D85,
	U64(0x8213F56A)<<32 + 0x67F6B29B, U64(0x9C3B2962)<<32 + 0x0E29FC73,
	U64(0xA298F2C5)<<32 + 0x01F45F42, U64(0x8349F3BA)<<32 + 0x91B47B8F,
	U64(0xCB3F2F76)<<32 + 0x42717713, U64(0x241C70A9)<<32 + 0x36219A73,
	U64(0xFE0EFB53)<<32 + 0xD30DD4D7, U64(0xED238CD3)<<32 + 0x83AA0110,
	U64(0x9EC95D14)<<32 + 0x63E8A506, U64(0xF4363804)<<32 + 0x324A40AA,
	U64(0xC67BB459)<<32 + 0x7CE2CE48, U64(0xB143C605)<<32 + 0x3EDCD0D5,
	U64(0xF81AA16F)<<32 + 0xDC1B81DA, U64(0xDD94B786)<<32 + 0x8E94050A,
	U64(0x9B10A4E5)<<32 + 0xE9913128, U64(0xCA7CF2B4)<<32 + 0x191C8326,
	U64(0xC1D4CE1F)<<32 + 0x63F57D72, U64(0xFD1C2F61)<<32 + 0x1F63A3F0,
	U64(0xF24A01A7)<<32 + 0x3CF2DCCF, U64(0xBC633B39)<<32 + 0x673C8CEC,
	U64(0x976E4108)<<32 + 0x8617CA01, U64(0xD5BE0503)<<32 + 0xE085D813,
	U64(0xBD49D14A)<<32 + 0xA79DBC82, U64(0x4B2D8644)<<32 + 0xD8A74E18,
	U64(0xEC9C459D)<<32 + 0x51852BA2, U64(0xDDF8E7D6)<<32 + 0x0ED1219E,
	U64(0x93E1AB82)<<32 + 0x52F33B45, U64(0xCABB90E5)<<32 + 0xC942B503,
	U64(0xB8DA1662)<<32 + 0xE7B00A17, U64(0x3D6A751F)<<32 + 0x3B936243,
	U64(0xE7109BFB)<<32 + 0xA19C0C9D, U64(0x0CC51267)<<32 + 0x0A783AD4,
	U64(0x906A617D)<<32 + 0x450187E2, U64(0x27FB2B80)<<32 + 0x668B24C5,
	U64(0xB484F9DC)<<32 + 0x9641E9DA, U64(0xB1F9F660)<<32 + 0x802DEDF6,
	U64(0xE1A63853)<<32 + 0xBBD26451, U64(0x5E7873F8)<<32 + 0xA0396973,
	U64(0x8D07E334)<<32 + 0x55637EB2, U64(0xDB0B487B)<<32 + 0x6423E1E8,
	U64(0xB049DC01)<<32 + 0x6ABC5E5F, U64(0x91CE1A9A)<<32 + 0x3D2CDA62,
	U64(0xDC5C5301)<<32 + 0xC56B75F7, U64(0x7641A140)<<32 + 0xCC7810FB,
	U64(0x89B9B3E1)<<32 + 0x1B6329BA, U64(0xA9E904C8)<<32 + 0x7FCB0A9D,
	U64(0xAC2820D9)<<32 + 0x623BF429, U64(0x546345FA)<<32 + 0x9FBDCD44,
	U64(0xD732290F)<<32 + 0xBACAF133, U64(0xA97C1779)<<32 + 0x47AD4095,
	U64(0x867F59A9)<<32 + 0xD4BED6C0, U64(0x49ED8EAB)<<32 + 0xCCCC485D,
	U64(0xA81F3014)<<32 + 0x49EE8C70, U64(0x5C68F256)<<32 + 0xBFFF5A74,
	U64(0xD226FC19)<<32 + 0x5C6A2F8C, U64(0x73832EEC)<<32 + 0x6FFF3111,
	U64(0x83585D8F)<<32 + 0xD9C25DB7, U64(0xC831FD53)<<32 + 0xC5FF7EAB,
	U64(0xA42E74F3)<<32 + 0xD032F525, U64(0xBA3E7CA8)<<32 + 0xB77F5E55,
	U64(0xCD3A1230)<<32 + 0xC43FB26F, U64(0x28CE1BD2)<<32 + 0xE55F35EB,
	U64(0x80444B5E)<<32 + 0x7AA7CF85, U64(0x7980D163)<<32 + 0xCF5B81B3,
	U64(0xA0555E36)<<32 + 0x1951C366, U64(0xD7E105BC)<<32 + 0xC332621F,
	U64(0xC86AB5C3)<<32 + 0x9FA63440, U64(0x8DD9472B)<<32 + 0xF3FEFAA7,
	U64(0xFA856334)<<32 + 0x878FC150, U64(0xB14F98F6)<<32 + 0xF0FEB951,
	U64(0x9C935E00)<<32 + 0xD4B9D8D2, U64(0x6ED1BF9A)<<32 + 0x569F33D3,
	U64(0xC3B83581)<<32 + 0x09E84F07, U64(0x0A862F80)<<32 + 0xEC4700C8,
	U64(0xF4A642E1)<<32 + 0x4C6262C8, U64(0xCD27BB61)<<32 + 0x2758C0FA,
	U64(0x98E7E9CC)<<32 + 0xCFBD7DBD, U64(0x8038D51C)<<32 + 0xB897789C,
	U64(0xBF21E440)<<32 + 0x03ACDD2C, U64(0xE0470A63)<<32 + 0xE6BD56C3,
	U64(0xEEEA5D50)<<32 + 0x04981478, U64(0x1858CCFC)<<32 + 0xE06CAC74,
	U64(0x95527A52)<<32 + 0x02DF0CCB, U64(0x0F37801E)<<32 + 0x0C43EBC8,
	U64(0xBAA718E6)<<32 + 0x8396CFFD, U64(0xD3056025)<<32 + 0x8F54E6BA,
	U64(0xE950DF20)<<32 + 0x247C83FD, U64(0x47C6B82E)<<32 + 0xF32A2069,
	U64(0x91D28B74)<<32 + 0x16CDD27E, U64(0x4CDC331D)<<32 + 0x57FA5441,
	U64(0xB6472E51)<<32 + 0x1C81471D, U64(0xE0133FE4)<<32 + 0xADF8E952,
	U64(0xE3D8F9E5)<<32 + 0x63A198E5, U64(0x58180FDD)<<32 + 0xD97723A6,
	U64(0x8E679C2F)<<32 + 0x5E44FF8F, U64(0x570F09EA)<<32 + 0xA7EA7648,
	U64(0xB201833B)<<32 + 0x35D63F73, U64(0x2CD2CC65)<<32 + 0x51E513DA,
	U64(0xDE81E40A)<<32 + 0x034BCF4F, U64(0xF8077F7E)<<32 + 0xA65E58D1,
	U64(0x8B112E86)<<32 + 0x420F6191, U64(0xFB04AFAF)<<32 + 0x27FAF782,
	U64(0xADD57A27)<<32 + 0xD29339F6, U64(0x79C5DB9A)<<32 + 0xF1F9B563,
	U64(0xD94AD8B1)<<32 + 0xC7380874, U64(0x18375281)<<32 + 0xAE7822BC,
	U64(0x87CEC76F)<<32 + 0x1C830548, U64(0x8F229391)<<32 + 0x0D0B15B5,
	U64(0xA9C2794A)<<32 + 0xE3A3C69A, U64(0xB2EB3875)<<32 + 0x504DDB22,
	U64(0xD433179D)<<32 + 0x9C8CB841, U64(0x5FA60692)<<32 + 0xA46151EB,
	U64(0x849FEEC2)<<32 + 0x81D7F328, U64(0xDBC7C41B)<<32 + 0xA6BCD333,
	U64(0xA5C7EA73)<<32 + 0x224DEFF3, U64(0x12B9B522)<<32 + 0x906C0800,
	U64(0xCF39E50F)<<32 + 0xEAE16BEF, U64(0xD768226B)<<32 + 0x34870A00,
	U64(0x81842F29)<<32 + 0xF2CCE375, U64(0xE6A11583)<<32 + 0x00D46640,
	U64(0xA1E53AF4)<<32 + 0x6F801C53, U64(0x60495AE3)<<32 + 0xC1097FD0,
	U64(0xCA5E89B1)<<32 + 0x8B602368, U64(0x385BB19C)<<32 + 0xB14BDFC4,
	U64(0xFCF62C1D)<<32 + 0xEE382C42, U64(0x46729E03)<<32 + 0xDD9ED7B5,
	U64(0x9E19DB92)<<32 + 0xB4E31BA9, U64(0x6C07A2C2)<<32 + 0x6A8346D1,
} /* yyjson.c:1726:18 */

//*
//  Get the cached pow10 value from pow10_sig_table.
//  @param exp10 The exponent of pow(10, e). This value must in range
//               POW10_SIG_TABLE_MIN_EXP to POW10_SIG_TABLE_MAX_EXP.
//  @param hi    The highest 64 bits of pow(10, e).
//  @param lo    The lower 64 bits after `hi`.
//
func Pow10_table_get_sig(tls *libc.TLS, exp10 I32, hi uintptr, lo uintptr) { /* yyjson.c:2404:6: */
	var idx I32 = exp10 - -343
	*(*U64)(unsafe.Pointer(hi)) = pow10_sig_table[idx*2]
	*(*U64)(unsafe.Pointer(lo)) = pow10_sig_table[idx*2+1]
}

//*
//  Get the exponent (base 2) for highest 64 bits significand in pow10_sig_table.
//
func Pow10_table_get_exp(tls *libc.TLS, exp10 I32, exp2 uintptr) { /* yyjson.c:2413:6: */
	// e2 = floor(log2(pow(10, e))) - 64 + 1
	//    = floor(e * log2(10) - 63)
	*(*I32)(unsafe.Pointer(exp2)) = (exp10*217706 - 4128768) >> 16
}

// ==============================================================================
// JSON Character Matcher
//============================================================================

//* Character type
type Char_type = U8 /* yyjson.c:2429:12 */

//* Whitespace character: ' ', '\\t', '\\n', '\\r'.
var sCHAR_TYPE_SPACE Char_type = Char_type(int32(1) << 0) /* yyjson.c:2432:24 */

//* Number character: '-', [0-9].
var sCHAR_TYPE_NUMBER Char_type = Char_type(int32(1) << 1) /* yyjson.c:2435:24 */

//* JSON Escaped character: '"', '\', [0x00-0x1F].
var sCHAR_TYPE_ESC_ASCII Char_type = Char_type(int32(1) << 2) /* yyjson.c:2438:24 */

//* Non-ASCII character: [0x80-0xFF].
var sCHAR_TYPE_NON_ASCII Char_type = Char_type(int32(1) << 3) /* yyjson.c:2441:24 */

//* JSON container character: '{', '['.
var sCHAR_TYPE_CONTAINER Char_type = Char_type(int32(1) << 4) /* yyjson.c:2444:24 */

//* Comment character: '/'.
var sCHAR_TYPE_COMMENT Char_type = Char_type(int32(1) << 5) /* yyjson.c:2447:24 */

//* Line end character '\\n', '\\r', '\0'.
var sCHAR_TYPE_LINE_END Char_type = Char_type(int32(1) << 6) /* yyjson.c:2450:24 */

//* Character type table (generate with misc/make_tables.c)
var char_table = [256]Char_type{
	Char_type(0x44), Char_type(0x04), Char_type(0x04), Char_type(0x04), Char_type(0x04), Char_type(0x04), Char_type(0x04), Char_type(0x04),
	Char_type(0x04), Char_type(0x05), Char_type(0x45), Char_type(0x04), Char_type(0x04), Char_type(0x45), Char_type(0x04), Char_type(0x04),
	Char_type(0x04), Char_type(0x04), Char_type(0x04), Char_type(0x04), Char_type(0x04), Char_type(0x04), Char_type(0x04), Char_type(0x04),
	Char_type(0x04), Char_type(0x04), Char_type(0x04), Char_type(0x04), Char_type(0x04), Char_type(0x04), Char_type(0x04), Char_type(0x04),
	Char_type(0x01), Char_type(0x00), Char_type(0x04), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00),
	Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x02), Char_type(0x00), Char_type(0x20),
	Char_type(0x02), Char_type(0x02), Char_type(0x02), Char_type(0x02), Char_type(0x02), Char_type(0x02), Char_type(0x02), Char_type(0x02),
	Char_type(0x02), Char_type(0x02), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00),
	Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00),
	Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00),
	Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00),
	Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x10), Char_type(0x04), Char_type(0x00), Char_type(0x00), Char_type(0x00),
	Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00),
	Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00),
	Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00),
	Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x10), Char_type(0x00), Char_type(0x00), Char_type(0x00), Char_type(0x00),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
	Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08), Char_type(0x08),
} /* yyjson.c:2453:24 */

//* Match a character with specified type.
func Char_is_type(tls *libc.TLS, c U8, type1 Char_type) uint8 { /* yyjson.c:2489:6: */
	return uint8(libc.Bool32(int32(char_table[c])&int32(type1) != 0))
}

//* Match a whitespace: ' ', '\\t', '\\n', '\\r'.
func Char_is_space(tls *libc.TLS, c U8) uint8 { /* yyjson.c:2494:6: */
	return Char_is_type(tls, c, sCHAR_TYPE_SPACE)
}

//* Match a whitespace or comment: ' ', '\\t', '\\n', '\\r', '/'.
func Char_is_space_or_comment(tls *libc.TLS, c U8) uint8 { /* yyjson.c:2499:6: */
	return Char_is_type(tls, c, Char_type(int32(sCHAR_TYPE_SPACE)|int32(sCHAR_TYPE_COMMENT)))
}

//* Match a JSON number: '-', [0-9].
func Char_is_number(tls *libc.TLS, c U8) uint8 { /* yyjson.c:2504:6: */
	return Char_is_type(tls, c, sCHAR_TYPE_NUMBER)
}

//* Match a JSON container: '{', '['.
func Char_is_container(tls *libc.TLS, c U8) uint8 { /* yyjson.c:2509:6: */
	return Char_is_type(tls, c, sCHAR_TYPE_CONTAINER)
}

//* Match a stop character in ASCII string: '"', '\', [0x00-0x1F], [0x80-0xFF]
func Char_is_ascii_stop(tls *libc.TLS, c U8) uint8 { /* yyjson.c:2514:6: */
	return Char_is_type(tls, c, Char_type(int32(sCHAR_TYPE_ESC_ASCII)|int32(sCHAR_TYPE_NON_ASCII)))
}

//* Match a line end character: '\\n', '\\r', '\0'
func Char_is_line_end(tls *libc.TLS, c U8) uint8 { /* yyjson.c:2520:6: */
	return Char_is_type(tls, c, sCHAR_TYPE_LINE_END)
}

// ==============================================================================
// Digit Character Matcher
//============================================================================

//* Digit type
type Digi_type = U8 /* yyjson.c:2531:12 */

//* Digit: '0'.
var sDIGI_TYPE_ZERO Digi_type = Digi_type(int32(1) << 0) /* yyjson.c:2534:24 */

//* Digit: [1-9].
var sDIGI_TYPE_NONZERO Digi_type = Digi_type(int32(1) << 1) /* yyjson.c:2537:24 */

//* Plus sign (positive): '+'.
var sDIGI_TYPE_POS Digi_type = Digi_type(int32(1) << 2) /* yyjson.c:2540:24 */

//* Minus sign (negative): '-'.
var sDIGI_TYPE_NEG Digi_type = Digi_type(int32(1) << 3) /* yyjson.c:2543:24 */

//* Decimal point: '.'
var sDIGI_TYPE_DOT Digi_type = Digi_type(int32(1) << 4) /* yyjson.c:2546:24 */

//* Exponent sign: 'e, 'E'.
var sDIGI_TYPE_EXP Digi_type = Digi_type(int32(1) << 5) /* yyjson.c:2549:24 */

//* Digit type table (generate with misc/make_tables.c)
var digi_table = [256]Digi_type{
	0: Digi_type(0x00), 1: Digi_type(0x00), 2: Digi_type(0x00), 3: Digi_type(0x00), 4: Digi_type(0x00), 5: Digi_type(0x00), 6: Digi_type(0x00), 7: Digi_type(0x00),
	8: Digi_type(0x00), 9: Digi_type(0x00), 10: Digi_type(0x00), 11: Digi_type(0x00), 12: Digi_type(0x00), 13: Digi_type(0x00), 14: Digi_type(0x00), 15: Digi_type(0x00),
	16: Digi_type(0x00), 17: Digi_type(0x00), 18: Digi_type(0x00), 19: Digi_type(0x00), 20: Digi_type(0x00), 21: Digi_type(0x00), 22: Digi_type(0x00), 23: Digi_type(0x00),
	24: Digi_type(0x00), 25: Digi_type(0x00), 26: Digi_type(0x00), 27: Digi_type(0x00), 28: Digi_type(0x00), 29: Digi_type(0x00), 30: Digi_type(0x00), 31: Digi_type(0x00),
	32: Digi_type(0x00), 33: Digi_type(0x00), 34: Digi_type(0x00), 35: Digi_type(0x00), 36: Digi_type(0x00), 37: Digi_type(0x00), 38: Digi_type(0x00), 39: Digi_type(0x00),
	40: Digi_type(0x00), 41: Digi_type(0x00), 42: Digi_type(0x00), 43: Digi_type(0x04), 44: Digi_type(0x00), 45: Digi_type(0x08), 46: Digi_type(0x10), 47: Digi_type(0x00),
	48: Digi_type(0x01), 49: Digi_type(0x02), 50: Digi_type(0x02), 51: Digi_type(0x02), 52: Digi_type(0x02), 53: Digi_type(0x02), 54: Digi_type(0x02), 55: Digi_type(0x02),
	56: Digi_type(0x02), 57: Digi_type(0x02), 58: Digi_type(0x00), 59: Digi_type(0x00), 60: Digi_type(0x00), 61: Digi_type(0x00), 62: Digi_type(0x00), 63: Digi_type(0x00),
	64: Digi_type(0x00), 65: Digi_type(0x00), 66: Digi_type(0x00), 67: Digi_type(0x00), 68: Digi_type(0x00), 69: Digi_type(0x20), 70: Digi_type(0x00), 71: Digi_type(0x00),
	72: Digi_type(0x00), 73: Digi_type(0x00), 74: Digi_type(0x00), 75: Digi_type(0x00), 76: Digi_type(0x00), 77: Digi_type(0x00), 78: Digi_type(0x00), 79: Digi_type(0x00),
	80: Digi_type(0x00), 81: Digi_type(0x00), 82: Digi_type(0x00), 83: Digi_type(0x00), 84: Digi_type(0x00), 85: Digi_type(0x00), 86: Digi_type(0x00), 87: Digi_type(0x00),
	88: Digi_type(0x00), 89: Digi_type(0x00), 90: Digi_type(0x00), 91: Digi_type(0x00), 92: Digi_type(0x00), 93: Digi_type(0x00), 94: Digi_type(0x00), 95: Digi_type(0x00),
	96: Digi_type(0x00), 97: Digi_type(0x00), 98: Digi_type(0x00), 99: Digi_type(0x00), 100: Digi_type(0x00), 101: Digi_type(0x20), 102: Digi_type(0x00), 103: Digi_type(0x00),
	104: Digi_type(0x00), 105: Digi_type(0x00), 106: Digi_type(0x00), 107: Digi_type(0x00), 108: Digi_type(0x00), 109: Digi_type(0x00), 110: Digi_type(0x00), 111: Digi_type(0x00),
	112: Digi_type(0x00), 113: Digi_type(0x00), 114: Digi_type(0x00), 115: Digi_type(0x00), 116: Digi_type(0x00), 117: Digi_type(0x00), 118: Digi_type(0x00), 119: Digi_type(0x00),
	120: Digi_type(0x00), 121: Digi_type(0x00), 122: Digi_type(0x00), 123: Digi_type(0x00), 124: Digi_type(0x00), 125: Digi_type(0x00), 126: Digi_type(0x00), 127: Digi_type(0x00),
} /* yyjson.c:2552:24 */

//* Match a character with specified type.
func Digi_is_type(tls *libc.TLS, d U8, type1 Digi_type) uint8 { /* yyjson.c:2572:6: */
	return uint8(libc.Bool32(int32(digi_table[d])&int32(type1) != 0))
}

//* Match a sign: '+', '-'
func Digi_is_sign(tls *libc.TLS, d U8) uint8 { /* yyjson.c:2577:6: */
	return Digi_is_type(tls, d, Digi_type(int32(sDIGI_TYPE_POS)|int32(sDIGI_TYPE_NEG)))
}

//* Match a none zero digit: [1-9]
func Digi_is_nonzero(tls *libc.TLS, d U8) uint8 { /* yyjson.c:2582:6: */
	return Digi_is_type(tls, d, sDIGI_TYPE_NONZERO)
}

//* Match a digit: [0-9]
func Digi_is_digit(tls *libc.TLS, d U8) uint8 { /* yyjson.c:2587:6: */
	return Digi_is_type(tls, d, Digi_type(int32(sDIGI_TYPE_ZERO)|int32(sDIGI_TYPE_NONZERO)))
}

//* Match an exponent sign: 'e', 'E'.
func Digi_is_exp(tls *libc.TLS, d U8) uint8 { /* yyjson.c:2592:6: */
	return Digi_is_type(tls, d, sDIGI_TYPE_EXP)
}

//* Match a floating point indicator: '.', 'e', 'E'.
func Digi_is_fp(tls *libc.TLS, d U8) uint8 { /* yyjson.c:2597:6: */
	return Digi_is_type(tls, d, Digi_type(int32(sDIGI_TYPE_DOT)|int32(sDIGI_TYPE_EXP)))
}

//* Match a digit or floating point indicator: [0-9], '.', 'e', 'E'.
func Digi_is_digit_or_fp(tls *libc.TLS, d U8) uint8 { /* yyjson.c:2602:6: */
	return Digi_is_type(tls, d, Digi_type(int32(sDIGI_TYPE_ZERO)|int32(sDIGI_TYPE_NONZERO)|int32(sDIGI_TYPE_DOT)|int32(sDIGI_TYPE_EXP)))
}

// ==============================================================================
// Hex Character Reader
// This function is used by JSON reader to read escaped characters.
//============================================================================

//*
//  This table is used to convert 4 hex character sequence to a number,
//  A valid hex character [0-9A-Fa-f] will mapped to it's raw number [0x00, 0x0F],
//  an invalid hex character will mapped to [0xF0].
//  (generate with misc/make_tables.c)
//
var hex_conv_table = [256]U8{
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0x00), U8(0x01), U8(0x02), U8(0x03), U8(0x04), U8(0x05), U8(0x06), U8(0x07),
	U8(0x08), U8(0x09), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0x0A), U8(0x0B), U8(0x0C), U8(0x0D), U8(0x0E), U8(0x0F), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0x0A), U8(0x0B), U8(0x0C), U8(0x0D), U8(0x0E), U8(0x0F), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
	U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0), U8(0xF0),
} /* yyjson.c:2620:17 */

//*
//  Scans an escaped character sequence as a UTF-16 code unit (branchless).
//  e.g. "\\u005C" should pass "005C" as `cur`.
//
//  This requires the string has 4-byte zero padding.
//
func Read_hex_u16(tls *libc.TLS, cur uintptr, val uintptr) uint8 { /* yyjson.c:2661:6: */
	var c0 U16
	var c1 U16
	var c2 U16
	var c3 U16
	var t0 U16
	var t1 U16
	c0 = U16(hex_conv_table[*(*U8)(unsafe.Pointer(cur))])
	c1 = U16(hex_conv_table[*(*U8)(unsafe.Pointer(cur + 1))])
	c2 = U16(hex_conv_table[*(*U8)(unsafe.Pointer(cur + 2))])
	c3 = U16(hex_conv_table[*(*U8)(unsafe.Pointer(cur + 3))])
	t0 = U16(int32(c0)<<8 | int32(c2))
	t1 = U16(int32(c1)<<8 | int32(c3))
	*(*U16)(unsafe.Pointer(val)) = U16(int32(t0)<<4 | int32(t1))
	return uint8(libc.Bool32((int32(t0)|int32(t1))&int32(U16(0xF0F0)) == 0))
}

// ==============================================================================
// JSON Reader Utils
// These functions are used by JSON reader to read literals and comments.
//============================================================================

//* Read 'true' literal, '*cur' should be 't'.
func Read_true(tls *libc.TLS, cur uintptr, end uintptr, val uintptr) uint8 { /* yyjson.c:2681:6: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_4(tls, cur, ts+25) != 0)), int64(1)) != 0 {
		(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(3)) | int32(Uint8_t(int32(1)<<3)))
		*(*uintptr)(unsafe.Pointer(end)) = cur + uintptr(4)
		return uint8(True)
	}
	return uint8(False)
}

//* Read 'false' literal, '*cur' should be 'f'.
func Read_false(tls *libc.TLS, cur uintptr, end uintptr, val uintptr) uint8 { /* yyjson.c:2691:6: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_4(tls, cur+uintptr(1), ts+65) != 0)), int64(1)) != 0 {
		(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(3)) | int32(Uint8_t(int32(0)<<3)))
		*(*uintptr)(unsafe.Pointer(end)) = cur + uintptr(5)
		return uint8(True)
	}
	return uint8(False)
}

//* Read 'null' literal, '*cur' should be 'n'.
func Read_null(tls *libc.TLS, cur uintptr, end uintptr, val uintptr) uint8 { /* yyjson.c:2701:6: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_4(tls, cur, ts) != 0)), int64(1)) != 0 {
		(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(Uint8_t(2))
		*(*uintptr)(unsafe.Pointer(end)) = cur + uintptr(4)
		return uint8(True)
	}
	return uint8(False)
}

//* Read 'Inf' or 'Infinity' literal (ignoring case).
func Read_inf(tls *libc.TLS, sign uint8, cur uintptr, end uintptr, val uintptr) uint8 { /* yyjson.c:2711:6: */
	if (int32(*(*U8)(unsafe.Pointer(cur))) == 'I' || int32(*(*U8)(unsafe.Pointer(cur))) == 'i') && (int32(*(*U8)(unsafe.Pointer(cur + 1))) == 'N' || int32(*(*U8)(unsafe.Pointer(cur + 1))) == 'n') && (int32(*(*U8)(unsafe.Pointer(cur + 2))) == 'F' || int32(*(*U8)(unsafe.Pointer(cur + 2))) == 'f') {
		if (int32(*(*U8)(unsafe.Pointer(cur + 3))) == 'I' || int32(*(*U8)(unsafe.Pointer(cur + 3))) == 'i') && (int32(*(*U8)(unsafe.Pointer(cur + 4))) == 'N' || int32(*(*U8)(unsafe.Pointer(cur + 4))) == 'n') && (int32(*(*U8)(unsafe.Pointer(cur + 5))) == 'I' || int32(*(*U8)(unsafe.Pointer(cur + 5))) == 'i') && (int32(*(*U8)(unsafe.Pointer(cur + 6))) == 'T' || int32(*(*U8)(unsafe.Pointer(cur + 6))) == 't') && (int32(*(*U8)(unsafe.Pointer(cur + 7))) == 'Y' || int32(*(*U8)(unsafe.Pointer(cur + 7))) == 'y') {
			*(*uintptr)(unsafe.Pointer(end)) = cur + uintptr(8)
		} else {
			*(*uintptr)(unsafe.Pointer(end)) = cur + uintptr(3)
		}
		(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
		*(*Uint64_t)(unsafe.Pointer(val + 8)) = F64_raw_get_inf(tls, sign)
		return uint8(True)
	}
	return uint8(False)
}

//* Read 'NaN' literal (ignoring case).
func Read_nan(tls *libc.TLS, sign uint8, cur uintptr, end uintptr, val uintptr) uint8 { /* yyjson.c:2734:6: */
	if (int32(*(*U8)(unsafe.Pointer(cur))) == 'N' || int32(*(*U8)(unsafe.Pointer(cur))) == 'n') && (int32(*(*U8)(unsafe.Pointer(cur + 1))) == 'A' || int32(*(*U8)(unsafe.Pointer(cur + 1))) == 'a') && (int32(*(*U8)(unsafe.Pointer(cur + 2))) == 'N' || int32(*(*U8)(unsafe.Pointer(cur + 2))) == 'n') {
		*(*uintptr)(unsafe.Pointer(end)) = cur + uintptr(3)
		(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
		*(*Uint64_t)(unsafe.Pointer(val + 8)) = F64_raw_get_nan(tls, sign)
		return uint8(True)
	}
	return uint8(False)
}

//* Read 'Inf', 'Infinity' or 'NaN' literal (ignoring case).
func Read_inf_or_nan(tls *libc.TLS, sign uint8, cur uintptr, end uintptr, val uintptr) uint8 { /* yyjson.c:2749:6: */
	if Read_inf(tls, sign, cur, end, val) != 0 {
		return uint8(True)
	}
	if Read_nan(tls, sign, cur, end, val) != 0 {
		return uint8(True)
	}
	return uint8(False)
}

//*
//  Skips spaces and comments as many as possible.
//
//  It will return false in these cases:
//     1. No character is skipped. The 'end' pointer is set as input cursor.
//     2. A multiline comment is not closed. The 'end' pointer is set as the head
//        of this comment block.
//
func skip_spaces_and_comments(tls *libc.TLS, cur uintptr, end uintptr) uint8 { /* yyjson.c:2766:22: */
	var hdr uintptr = cur
	for 1 != 0 {
		if Byte_match_2(tls, cur, ts+70) != 0 {
			hdr = cur
			cur += uintptr(2)
			for 1 != 0 {
				if Byte_match_2(tls, cur, ts+73) != 0 {
					cur += uintptr(2)
					break
				}
				if Byte_match_1(tls, cur, ts+76) != 0 {
					*(*uintptr)(unsafe.Pointer(end)) = hdr
					return uint8(False)
				}
				cur++
			}
			continue
		}
		if Byte_match_2(tls, cur, ts+78) != 0 {
			cur += uintptr(2)
			for !(Char_is_line_end(tls, *(*U8)(unsafe.Pointer(cur))) != 0) {
				cur++
			}
			continue
		}
		if Char_is_space(tls, *(*U8)(unsafe.Pointer(cur))) != 0 {
			cur += uintptr(1)
			for Char_is_space(tls, *(*U8)(unsafe.Pointer(cur))) != 0 {
				cur++
			}
			continue
		}
		break
	}
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(libc.Bool32(hdr != cur))
}

// ==============================================================================
// BigInt For Floating Point Number Reader
//
// The bigint algorithm is used by floating-point number reader to get correctly
// rounded result for numbers with lots of digits. This part of code is rarely
// used for common numbers.
//============================================================================

//* Maximum exponent of exact pow10

//* Table: [ 10^0, ..., 10^19 ] (generate with misc/make_tables.c)
var u64_pow10_table = [20]U64{
	U64(0x00000000)<<32 + 0x00000001, U64(0x00000000)<<32 + 0x0000000A,
	U64(0x00000000)<<32 + 0x00000064, U64(0x00000000)<<32 + 0x000003E8,
	U64(0x00000000)<<32 + 0x00002710, U64(0x00000000)<<32 + 0x000186A0,
	U64(0x00000000)<<32 + 0x000F4240, U64(0x00000000)<<32 + 0x00989680,
	U64(0x00000000)<<32 + 0x05F5E100, U64(0x00000000)<<32 + 0x3B9ACA00,
	U64(0x00000002)<<32 + 0x540BE400, U64(0x00000017)<<32 + 0x4876E800,
	U64(0x000000E8)<<32 + 0xD4A51000, U64(0x00000918)<<32 + 0x4E72A000,
	U64(0x00005AF3)<<32 + 0x107A4000, U64(0x00038D7E)<<32 + 0xA4C68000,
	U64(0x002386F2)<<32 + 0x6FC10000, U64(0x01634578)<<32 + 0x5D8A0000,
	U64(0x0DE0B6B3)<<32 + 0xA7640000, U64(0x8AC72304)<<32 + 0x89E80000,
} /* yyjson.c:2817:18 */

//* Maximum numbers of chunks used by a bigint (58 is enough here).

//* Unsigned arbitrarily large integer
type Bigint1 = struct {
	Used        U32
	__ccgo_pad1 [4]byte
	Bits        [64]U64
} /* yyjson.c:2834:9 */

//* Maximum numbers of chunks used by a bigint (58 is enough here).

//* Unsigned arbitrarily large integer
type Bigint = Bigint1 /* yyjson.c:2837:3 */

//*
//  Evaluate 'big += val'.
//  @param big A big number (can be 0).
//  @param val An unsigned integer (can be 0).
//
func Bigint_add_u64(tls *libc.TLS, big uintptr, val U64) { /* yyjson.c:2844:6: */
	var idx U32
	var max U32
	var num U64 = *(*U64)(unsafe.Pointer(big + 8))
	var add U64 = num + val
	*(*U64)(unsafe.Pointer(big + 8)) = add
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(add >= num || add >= val)), int64(1)) != 0 {
		return
	}
	idx = U32(1)
	max = (*Bigint)(unsafe.Pointer(big)).Used
	for ; idx < max; idx++ {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*U64)(unsafe.Pointer(big + 8 + uintptr(idx)*8)) != U64(0xFFFFFFFF)<<32+0xFFFFFFFF)), int64(1)) != 0 {
			*(*U64)(unsafe.Pointer(big + 8 + uintptr(idx)*8)) += uint64(1)
			return
		}
		*(*U64)(unsafe.Pointer(big + 8 + uintptr(idx)*8)) = uint64(0)
	}
	*(*U64)(unsafe.Pointer(big + 8 + uintptr(libc.PostIncUint32(&(*Bigint)(unsafe.Pointer(big)).Used, 1))*8)) = uint64(1)
}

//*
//  Evaluate 'big *= val'.
//  @param big A big number (can be 0).
//  @param val An unsigned integer (cannot be 0).
//
func Bigint_mul_u64(tls *libc.TLS, big uintptr, val U64) { /* yyjson.c:2865:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var idx U32 = U32(0)
	var max U32 = (*Bigint)(unsafe.Pointer(big)).Used
	// var hi U64 at bp, 8

	// var lo U64 at bp+8, 8

	var carry U64 = uint64(0)
	for ; idx < max; idx++ {
		if *(*U64)(unsafe.Pointer(big + 8 + uintptr(idx)*8)) != 0 {
			break
		}
	}
	for ; idx < max; idx++ {
		U128_mul_add(tls, *(*U64)(unsafe.Pointer(big + 8 + uintptr(idx)*8)), val, carry, bp, bp+8)
		*(*U64)(unsafe.Pointer(big + 8 + uintptr(idx)*8)) = *(*U64)(unsafe.Pointer(bp + 8 /* lo */))
		carry = *(*U64)(unsafe.Pointer(bp /* hi */))
	}
	if carry != 0 {
		*(*U64)(unsafe.Pointer(big + 8 + uintptr(libc.PostIncUint32(&(*Bigint)(unsafe.Pointer(big)).Used, 1))*8)) = carry
	}
}

//*
//  Evaluate 'big *= 2^exp'.
//  @param big A big number (can be 0).
//  @param exp An exponent integer (can be 0).
//
func Bigint_mul_pow2(tls *libc.TLS, big uintptr, exp U32) { /* yyjson.c:2884:6: */
	var shft U32 = exp % U32(64)
	var move U32 = exp / U32(64)
	var idx U32 = (*Bigint)(unsafe.Pointer(big)).Used
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(shft == U32(0))), int64(0)) != 0 {
		for ; idx > U32(0); idx-- {
			*(*U64)(unsafe.Pointer(big + 8 + uintptr(idx+move-U32(1))*8)) = *(*U64)(unsafe.Pointer(big + 8 + uintptr(idx-U32(1))*8))
		}
		*(*U32)(unsafe.Pointer(big)) += move
		for move != 0 {
			*(*U64)(unsafe.Pointer(big + 8 + uintptr(libc.PreDecUint32(&move, 1))*8)) = uint64(0)
		}
	} else {
		*(*U64)(unsafe.Pointer(big + 8 + uintptr(idx)*8)) = uint64(0)
		for ; idx > U32(0); idx-- {
			var num U64 = *(*U64)(unsafe.Pointer(big + 8 + uintptr(idx)*8)) << shft
			num = num | *(*U64)(unsafe.Pointer(big + 8 + uintptr(idx-U32(1))*8))>>(U32(64)-shft)
			*(*U64)(unsafe.Pointer(big + 8 + uintptr(idx+move)*8)) = num
		}
		*(*U64)(unsafe.Pointer(big + 8 + uintptr(move)*8)) = *(*U64)(unsafe.Pointer(big + 8)) << shft
		*(*U32)(unsafe.Pointer(big)) += move + U32(libc.Bool32(*(*U64)(unsafe.Pointer(big + 8 + uintptr((*Bigint)(unsafe.Pointer(big)).Used+move)*8)) > uint64(0)))
		for move != 0 {
			*(*U64)(unsafe.Pointer(big + 8 + uintptr(libc.PreDecUint32(&move, 1))*8)) = uint64(0)
		}
	}
}

//*
//  Evaluate 'big *= 10^exp'.
//  @param big A big number (can be 0).
//  @param exp An exponent integer (cannot be 0).
//
func Bigint_mul_pow10(tls *libc.TLS, big uintptr, exp I32) { /* yyjson.c:2912:6: */
	for ; exp >= U64_POW10_MAX_EXP; exp = exp - U64_POW10_MAX_EXP {
		Bigint_mul_u64(tls, big, u64_pow10_table[U64_POW10_MAX_EXP])
	}
	if exp != 0 {
		Bigint_mul_u64(tls, big, u64_pow10_table[exp])
	}
}

//*
//  Compare two bigint.
//  @return -1 if 'a < b', +1 if 'a > b', 0 if 'a == b'.
//
func Bigint_cmp(tls *libc.TLS, a uintptr, b uintptr) I32 { /* yyjson.c:2925:5: */
	var idx U32 = (*Bigint)(unsafe.Pointer(a)).Used
	if (*Bigint)(unsafe.Pointer(a)).Used < (*Bigint)(unsafe.Pointer(b)).Used {
		return -1
	}
	if (*Bigint)(unsafe.Pointer(a)).Used > (*Bigint)(unsafe.Pointer(b)).Used {
		return +1
	}
	for libc.PostDecUint32(&idx, 1) > U32(0) {
		var av U64 = *(*U64)(unsafe.Pointer(a + 8 + uintptr(idx)*8))
		var bv U64 = *(*U64)(unsafe.Pointer(b + 8 + uintptr(idx)*8))
		if av < bv {
			return -1
		}
		if av > bv {
			return +1
		}
	}
	return 0
}

//*
//  Evaluate 'big = val'.
//  @param big A big number (can be 0).
//  @param val An unsigned integer (can be 0).
//
func Bigint_set_u64(tls *libc.TLS, big uintptr, val U64) { /* yyjson.c:2943:6: */
	(*Bigint)(unsafe.Pointer(big)).Used = U32(1)
	*(*U64)(unsafe.Pointer(big + 8)) = val
}

//* Set a bigint with floating point number string.
func bigint_set_buf(tls *libc.TLS, big uintptr, sig U64, exp uintptr, sig_cut uintptr, sig_end uintptr, dot_pos uintptr) { /* yyjson.c:2949:22: */

	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(sig_cut != 0)), int64(0)) != 0 {
		// no digit cut, set significant part only
		Bigint_set_u64(tls, big, sig)
		return

	} else {
		// some digits were cut, read them from 'sig_cut' to 'sig_end'
		var hdr uintptr = sig_cut
		var cur uintptr = hdr
		var len U32 = U32(0)
		var val U64 = uint64(0)
		var dig_big_cut uint8 = uint8(False)
		var has_dot uint8 = uint8(libc.Bool32(hdr < dot_pos) & libc.Bool32(dot_pos < sig_end))
		var dig_len_total U32 = U32(U64_SAFE_DIG) + U32((int64(sig_end)-int64(hdr))/1) - U32(has_dot)

		sig = sig - U64(libc.Bool32(int32(*(*U8)(unsafe.Pointer(sig_cut))) >= '5')) // sig was rounded before
		if dig_len_total > U32(F64_MAX_DEC_DIG) {
			dig_big_cut = uint8(True)
			sig_end -= uintptr(dig_len_total - U32(F64_MAX_DEC_DIG+1))
			sig_end -= uintptr(libc.Bool32(dot_pos+uintptr(1) == sig_end))
			dig_len_total = U32(F64_MAX_DEC_DIG + 1)
		}
		*(*I32)(unsafe.Pointer(exp)) -= I32(dig_len_total) - U64_SAFE_DIG

		(*Bigint)(unsafe.Pointer(big)).Used = U32(1)
		*(*U64)(unsafe.Pointer(big + 8)) = sig
		for cur < sig_end {
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur != dot_pos)), int64(1)) != 0 {
				val = val*uint64(10) + U64(U8(int32(*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))))-'0'))
				len++
				if libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur == sig_end && dig_big_cut != 0)), int64(0)) != 0 {
					// The last digit must be non-zero,
					// set it to '1' for correct rounding.
					val = val - val%uint64(10) + uint64(1)
				}
				if len == U32(U64_SAFE_DIG) || cur == sig_end {
					Bigint_mul_pow10(tls, big, I32(len))
					Bigint_add_u64(tls, big, val)
					val = uint64(0)
					len = U32(0)
				}
			} else {
				cur++
			}
		}
	}
}

// ==============================================================================
// Diy Floating Point
//============================================================================

//* "Do It Yourself Floating Point" struct.
type Diy_fp1 = struct {
	Sig U64
	Exp I32
	Pad I32
} /* yyjson.c:3007:9 */

// ==============================================================================
// Diy Floating Point
//============================================================================

//* "Do It Yourself Floating Point" struct.
type Diy_fp = Diy_fp1 /* yyjson.c:3011:3 */

//* Get cached rounded diy_fp with pow(10, e) The input value must in range
//     [POW10_SIG_TABLE_MIN_EXP, POW10_SIG_TABLE_MAX_EXP].
func Diy_fp_get_cached_pow10(tls *libc.TLS, exp10 I32) Diy_fp { /* yyjson.c:3015:8: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var fp Diy_fp at bp, 16

	// var sig_ext U64 at bp+16, 8

	Pow10_table_get_sig(tls, exp10, bp, bp+16)
	Pow10_table_get_exp(tls, exp10, bp+8)
	*(*U64)(unsafe.Pointer(bp)) += *(*U64)(unsafe.Pointer(bp + 16)) >> 63
	return *(*Diy_fp)(unsafe.Pointer(bp /* fp */))
}

//* Returns fp * fp2.
func Diy_fp_mul(tls *libc.TLS, fp Diy_fp, fp2 Diy_fp) Diy_fp { /* yyjson.c:3025:8: */
	bp := tls.Alloc(32)
	defer tls.Free(32)
	*(*Diy_fp)(unsafe.Pointer(bp + 16)) = fp

	// var hi U64 at bp, 8

	// var lo U64 at bp+8, 8

	U128_mul(tls, (*Diy_fp)(unsafe.Pointer(bp+16 /* &fp */)).Sig, fp2.Sig, bp, bp+8)
	(*Diy_fp)(unsafe.Pointer(bp + 16 /* &fp */)).Sig = *(*U64)(unsafe.Pointer(bp)) + *(*U64)(unsafe.Pointer(bp + 8))>>63
	*(*I32)(unsafe.Pointer(bp + 16 + 8)) += fp2.Exp + 64
	return *(*Diy_fp)(unsafe.Pointer(bp + 16 /* fp */))
}

//* Convert diy_fp to IEEE-754 raw value.
func Diy_fp_to_ieee_raw(tls *libc.TLS, fp Diy_fp) U64 { /* yyjson.c:3034:5: */
	var sig U64 = fp.Sig
	var exp I32 = fp.Exp
	var lz_bits U32
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(fp.Sig == uint64(0))), int64(0)) != 0 {
		return uint64(0)
	}

	lz_bits = U64_lz_bits(tls, sig)
	sig <<= lz_bits
	sig >>= F64_BITS - F64_SIG_FULL_BITS
	exp = exp - I32(lz_bits)
	exp = exp + (F64_BITS - F64_SIG_FULL_BITS)
	exp = exp + F64_SIG_BITS

	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(exp >= F64_MAX_BIN_EXP)), int64(0)) != 0 {
		// overflow
		return U64(0x7FF00000)<<32 + 0x00000000
	} else if libc.X__builtin_expect(tls, libc.BoolInt64(!!(exp >= -1021-1)), int64(1)) != 0 {
		// normal
		exp = exp + F64_EXP_BIAS
		return U64(exp)<<F64_SIG_BITS | sig&(U64(0x000FFFFF)<<32+0xFFFFFFFF)
	} else if libc.X__builtin_expect(tls, libc.BoolInt64(!!(exp >= -1021-F64_SIG_FULL_BITS)), int64(1)) != 0 {
		// subnormal
		return sig >> (-1021 - exp - 1)
	} else {
		// underflow
		return uint64(0)
	}
	return U64(0)
}

// ==============================================================================
// JSON Number Reader (IEEE-754)
//============================================================================

//* Maximum exact pow10 exponent for double value.

//* Cached pow10 table.
var f64_pow10_table = [23]F64{
	1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12,
	1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19, 1e20, 1e21, 1e22,
} /* yyjson.c:3073:18 */

//*
//  Read a JSON number.
//
//  1. This function assume that the floating-point number is in IEEE-754 format.
//  2. This function support uint64/int64/double number. If an integer number
//     cannot fit in uint64/int64, it will returns as a double number. If a double
//     number is infinite, the return value is based on flag.
//  3. This function (with inline attribute) may generate a lot of instructions.
//
func Read_number(tls *libc.TLS, cur uintptr, end uintptr, flg Yyjson_read_flag, val uintptr, msg uintptr) uint8 { /* yyjson.c:3087:6: */
	bp := tls.Alloc(1136)
	defer tls.Free(1136)

	var sig_cut uintptr // significant part cutting position for long number
	var sig_end uintptr // significant part ending position
	var dot_pos uintptr // decimal point position

	var sig U64 // significant part of the number
	// var exp I32 at bp+608, 4
	// exponent part of the number

	var exp_sign uint8 // temporary exponent sign from literal part
	var exp_sig I64    // temporary exponent number from significant part
	var exp_lit I64    // temporary exponent number from exponent literal part
	var num U64        // temporary number for reading
	var tmp uintptr    // temporary cursor for reading

	var hdr uintptr
	var sign uint8
	var dbl F64
	//
	//          The result value is exactly equal to (sig * 10^exp),
	//          the exponent part (10^exp) can be converted to (sig2 * 2^exp2).
	//
	//          The sig2 can be an infinite length number, only the highest 128 bits
	//          is cached in the pow10_sig_table.
	//
	//          Now we have these bits:
	//          sig1 (normalized 64bit)        : aaaaaaaa
	//          sig2 (higher 64bit)            : bbbbbbbb
	//          sig2_ext (lower 64bit)         : cccccccc
	//          sig2_cut (extra unknown bits)  : dddddddddddd....
	//
	//          And the calculation process is:
	//          ----------------------------------------
	//                  aaaaaaaa *
	//                  bbbbbbbbccccccccdddddddddddd....
	//          ----------------------------------------
	//          abababababababab +
	//                  acacacacacacacac +
	//                          adadadadadadadadadad....
	//          ----------------------------------------
	//          [hi____][lo____] +
	//                  [hi2___][lo2___] +
	//                          [unknown___________....]
	//          ----------------------------------------
	//
	//          The addition with carry may affect higher bits, but if there is a 0
	//          in higher bits, the bits higher than 0 will not be affected.
	//
	//          `lo2` + `unknown` may get a carry bit and may affect `hi2`, the max
	//          value of `hi2` is 0xFFFFFFFFFFFFFFFE, so `hi2` will not overflow.
	//
	//          `lo` + `hi2` may also get a carry bit and may affect `hi`, but only
	//          the highest significant 53 bits of `hi` is needed. If there is a 0
	//          in the lower bits of `hi`, then all the following bits can be dropped.
	//
	//          To convert the result to IEEE-754 double number, we need to perform
	//          correct rounding:
	//          1. if bit 54 is 0, round down,
	//          2. if bit 54 is 1 and any bit beyond bit 54 is 1, round up,
	//          3. if bit 54 is 1 and all bits beyond bit 54 are 0, round to even,
	//             as the extra bits is unknown, this case will not be handled here.
	//

	var raw U64
	var sig1 U64
	// var sig2 U64 at bp, 8

	// var sig2_ext U64 at bp+8, 8

	// var hi U64 at bp+24, 8

	// var lo U64 at bp+32, 8

	// var hi2 U64 at bp+40, 8

	// var lo2 U64 at bp+48, 8

	var add U64
	var bits U64
	// var exp2 I32 at bp+16, 4

	var lz U32
	var exact uint8
	var carry uint8
	var round_up uint8
	var shr I32
	var ERR_ULP_LOG I32
	var ERR_ULP I32
	var ERR_CACHED_POW I32
	var ERR_MUL_FIXED I32
	var DIY_SIG_BITS I32
	var EXP_BIAS I32
	var EXP_SUBNORMAL I32
	var fp_err U64
	var bits1 U32
	var order_of_magnitude I32
	var effective_significand_size I32
	var precision_digits_count I32
	var precision_bits U64
	var half_way U64
	var raw1 U64
	// var fp Diy_fp at bp+56, 16

	// var fp_upper Diy_fp at bp+72, 16

	// var big_full Bigint at bp+88, 520

	// var big_comp Bigint at bp+616, 520

	var cmp I32
	sig_cut = uintptr(0)
	sig_end = uintptr(0)
	dot_pos = uintptr(0)
	sig = uint64(0)
	*(*I32)(unsafe.Pointer(bp + 608 /* exp */)) = 0
	exp_sig = int64(0)
	exp_lit = int64(0)
	hdr = cur
	sign = uint8(libc.Bool32(int32(*(*U8)(unsafe.Pointer(hdr))) == '-'))
	cur += uintptr(sign)

	// begin with a leading zero or non-digit
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_nonzero(tls, *(*U8)(unsafe.Pointer(cur))) != 0)), int64(0)) != 0) {
		goto __1
	} // 0 or non-digit char
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur))) != '0')), int64(0)) != 0) {
		goto __2
	} // non-digit char
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_INF_AND_NAN != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __3
	}
	if !(Read_inf_or_nan(tls, sign, cur, end, val) != 0) {
		goto __4
	}
	return uint8(True)
__4:
	;
__3:
	;
__5:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 81 /* "no digit after m..." */
	*(*uintptr)(unsafe.Pointer(end)) = cur - uintptr(1)
	return uint8(False)
	goto __6
__6:
	if 0 != 0 {
		goto __5
	}
	goto __7
__7:
	;
__2:
	;
	// begin with 0
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_digit_or_fp(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&cur, 1)))) != 0)), int64(1)) != 0) {
		goto __8
	}
__9:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return uint64(libc.CplInt32(0) + 1)
		}
		return uint64(0)
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __10
__10:
	if 0 != 0 {
		goto __9
	}
	goto __11
__11:
	;
__8:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur))) == '.')), int64(1)) != 0) {
		goto __12
	}
	dot_pos = libc.PostIncUintptr(&cur, 1)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_digit(tls, *(*U8)(unsafe.Pointer(cur))) != 0)), int64(0)) != 0) {
		goto __13
	}
__14:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 107 /* "no digit after d..." */
	*(*uintptr)(unsafe.Pointer(end)) = cur - uintptr(1)
	return uint8(False)
	goto __15
__15:
	if 0 != 0 {
		goto __14
	}
	goto __16
__16:
	;
__13:
	;
__17:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur))) == '0')), int64(0)) != 0) {
		goto __18
	}
	cur++
	goto __17
__18:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Digi_is_digit(tls, *(*U8)(unsafe.Pointer(cur))) != 0)), int64(1)) != 0) {
		goto __19
	}
	// first non-zero digit after decimal point
	sig = U64(int32(*(*U8)(unsafe.Pointer(cur))) - '0') // read first digit
	cur--
	goto digi_frac_1 // continue read fraction part
__19:
	;
__12:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Digi_is_digit(tls, *(*U8)(unsafe.Pointer(cur))) != 0)), int64(0)) != 0) {
		goto __20
	}
__21:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 136 /* "number with lead..." */
	*(*uintptr)(unsafe.Pointer(end)) = cur - uintptr(1)
	return uint8(False)
	goto __22
__22:
	if 0 != 0 {
		goto __21
	}
	goto __23
__23:
	;
__20:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Digi_is_exp(tls, *(*U8)(unsafe.Pointer(cur))) != 0)), int64(0)) != 0) {
		goto __24
	} // 0 with any exponent is still 0
	cur += uintptr(uint64(1) + Usize(Digi_is_sign(tls, *(*U8)(unsafe.Pointer(cur + 1)))))
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_digit(tls, *(*U8)(unsafe.Pointer(cur))) != 0)), int64(0)) != 0) {
		goto __25
	}
__26:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 176 /* "no digit after e..." */
	*(*uintptr)(unsafe.Pointer(end)) = cur - uintptr(1)
	return uint8(False)
	goto __27
__27:
	if 0 != 0 {
		goto __26
	}
	goto __28
__28:
	;
__25:
	;
__29:
	if !(Digi_is_digit(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&cur, 1)))) != 0) {
		goto __30
	}
	goto __29
__30:
	;
__24:
	;
__31:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = U64(sign)<<63 | uint64(0)
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __32
__32:
	if 0 != 0 {
		goto __31
	}
	goto __33
__33:
	;
__1:
	;

	// begin with non-zero digit
	sig = U64(int32(*(*U8)(unsafe.Pointer(cur))) - '0')

	/*
	   Read integral part, same as the following code.
	   For more explanation, see the comments under label `skip_ascii_begin`.

	       for (int i = 1; i <= 18; i++) {
	          num = cur[i] - '0';
	          if (num <= 9) sig = num + sig * 10;
	          else goto digi_sepr_i;
	       }
	*/
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 1)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __34
	}
	sig = num + sig*uint64(10)
	goto __35
__34:
	goto digi_sepr_1
__35:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 2)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __36
	}
	sig = num + sig*uint64(10)
	goto __37
__36:
	goto digi_sepr_2
__37:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 3)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __38
	}
	sig = num + sig*uint64(10)
	goto __39
__38:
	goto digi_sepr_3
__39:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 4)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __40
	}
	sig = num + sig*uint64(10)
	goto __41
__40:
	goto digi_sepr_4
__41:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 5)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __42
	}
	sig = num + sig*uint64(10)
	goto __43
__42:
	goto digi_sepr_5
__43:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 6)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __44
	}
	sig = num + sig*uint64(10)
	goto __45
__44:
	goto digi_sepr_6
__45:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 7)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __46
	}
	sig = num + sig*uint64(10)
	goto __47
__46:
	goto digi_sepr_7
__47:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 8)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __48
	}
	sig = num + sig*uint64(10)
	goto __49
__48:
	goto digi_sepr_8
__49:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 9)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __50
	}
	sig = num + sig*uint64(10)
	goto __51
__50:
	goto digi_sepr_9
__51:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 10)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __52
	}
	sig = num + sig*uint64(10)
	goto __53
__52:
	goto digi_sepr_10
__53:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 11)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __54
	}
	sig = num + sig*uint64(10)
	goto __55
__54:
	goto digi_sepr_11
__55:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 12)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __56
	}
	sig = num + sig*uint64(10)
	goto __57
__56:
	goto digi_sepr_12
__57:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 13)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __58
	}
	sig = num + sig*uint64(10)
	goto __59
__58:
	goto digi_sepr_13
__59:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 14)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __60
	}
	sig = num + sig*uint64(10)
	goto __61
__60:
	goto digi_sepr_14
__61:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 15)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __62
	}
	sig = num + sig*uint64(10)
	goto __63
__62:
	goto digi_sepr_15
__63:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 16)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __64
	}
	sig = num + sig*uint64(10)
	goto __65
__64:
	goto digi_sepr_16
__65:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 17)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __66
	}
	sig = num + sig*uint64(10)
	goto __67
__66:
	goto digi_sepr_17
__67:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 18)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __68
	}
	sig = num + sig*uint64(10)
	goto __69
__68:
	goto digi_sepr_18
__69:
	;

	cur += uintptr(19) // skip continuous 19 digits
	if !!(Digi_is_digit_or_fp(tls, *(*U8)(unsafe.Pointer(cur))) != 0) {
		goto __70
	}
	// this number is an integer consisting of 19 digits
	if !(sign != 0 && sig > U64(uint64(1))<<63) {
		goto __71
	} // overflow
__72:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
	*(*float64)(unsafe.Pointer(val + 8)) = func() float64 {
		if sign != 0 {
			return -Normalized_u64_to_f64(tls, sig)
		}
		return Normalized_u64_to_f64(tls, sig)
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __73
__73:
	if 0 != 0 {
		goto __72
	}
	goto __74
__74:
	;
__71:
	;
__75:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __76
__76:
	if 0 != 0 {
		goto __75
	}
	goto __77
__77:
	;
__70:
	;
	goto digi_intg_more /* read more digits in integral part */

	/* process first non-digit character */
digi_sepr_1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 1))) != 0)), int64(1)) != 0) {
		goto __78
	}
	cur += uintptr(1)
__79:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __80
__80:
	if 0 != 0 {
		goto __79
	}
	goto __81
__81:
	;
__78:
	;
	dot_pos = cur + uintptr(1)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 1))) == '.')), int64(1)) != 0) {
		goto __82
	}
	goto digi_frac_1
__82:
	;
	cur += uintptr(1)
	sig_end = cur
	goto digi_exp_more
digi_sepr_2:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 2))) != 0)), int64(1)) != 0) {
		goto __83
	}
	cur += uintptr(2)
__84:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __85
__85:
	if 0 != 0 {
		goto __84
	}
	goto __86
__86:
	;
__83:
	;
	dot_pos = cur + uintptr(2)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 2))) == '.')), int64(1)) != 0) {
		goto __87
	}
	goto digi_frac_2
__87:
	;
	cur += uintptr(2)
	sig_end = cur
	goto digi_exp_more
digi_sepr_3:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 3))) != 0)), int64(1)) != 0) {
		goto __88
	}
	cur += uintptr(3)
__89:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __90
__90:
	if 0 != 0 {
		goto __89
	}
	goto __91
__91:
	;
__88:
	;
	dot_pos = cur + uintptr(3)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 3))) == '.')), int64(1)) != 0) {
		goto __92
	}
	goto digi_frac_3
__92:
	;
	cur += uintptr(3)
	sig_end = cur
	goto digi_exp_more
digi_sepr_4:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 4))) != 0)), int64(1)) != 0) {
		goto __93
	}
	cur += uintptr(4)
__94:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __95
__95:
	if 0 != 0 {
		goto __94
	}
	goto __96
__96:
	;
__93:
	;
	dot_pos = cur + uintptr(4)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 4))) == '.')), int64(1)) != 0) {
		goto __97
	}
	goto digi_frac_4
__97:
	;
	cur += uintptr(4)
	sig_end = cur
	goto digi_exp_more
digi_sepr_5:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 5))) != 0)), int64(1)) != 0) {
		goto __98
	}
	cur += uintptr(5)
__99:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __100
__100:
	if 0 != 0 {
		goto __99
	}
	goto __101
__101:
	;
__98:
	;
	dot_pos = cur + uintptr(5)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 5))) == '.')), int64(1)) != 0) {
		goto __102
	}
	goto digi_frac_5
__102:
	;
	cur += uintptr(5)
	sig_end = cur
	goto digi_exp_more
digi_sepr_6:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 6))) != 0)), int64(1)) != 0) {
		goto __103
	}
	cur += uintptr(6)
__104:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __105
__105:
	if 0 != 0 {
		goto __104
	}
	goto __106
__106:
	;
__103:
	;
	dot_pos = cur + uintptr(6)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 6))) == '.')), int64(1)) != 0) {
		goto __107
	}
	goto digi_frac_6
__107:
	;
	cur += uintptr(6)
	sig_end = cur
	goto digi_exp_more
digi_sepr_7:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 7))) != 0)), int64(1)) != 0) {
		goto __108
	}
	cur += uintptr(7)
__109:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __110
__110:
	if 0 != 0 {
		goto __109
	}
	goto __111
__111:
	;
__108:
	;
	dot_pos = cur + uintptr(7)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 7))) == '.')), int64(1)) != 0) {
		goto __112
	}
	goto digi_frac_7
__112:
	;
	cur += uintptr(7)
	sig_end = cur
	goto digi_exp_more
digi_sepr_8:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 8))) != 0)), int64(1)) != 0) {
		goto __113
	}
	cur += uintptr(8)
__114:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __115
__115:
	if 0 != 0 {
		goto __114
	}
	goto __116
__116:
	;
__113:
	;
	dot_pos = cur + uintptr(8)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 8))) == '.')), int64(1)) != 0) {
		goto __117
	}
	goto digi_frac_8
__117:
	;
	cur += uintptr(8)
	sig_end = cur
	goto digi_exp_more
digi_sepr_9:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 9))) != 0)), int64(1)) != 0) {
		goto __118
	}
	cur += uintptr(9)
__119:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __120
__120:
	if 0 != 0 {
		goto __119
	}
	goto __121
__121:
	;
__118:
	;
	dot_pos = cur + uintptr(9)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 9))) == '.')), int64(1)) != 0) {
		goto __122
	}
	goto digi_frac_9
__122:
	;
	cur += uintptr(9)
	sig_end = cur
	goto digi_exp_more
digi_sepr_10:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 10))) != 0)), int64(1)) != 0) {
		goto __123
	}
	cur += uintptr(10)
__124:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __125
__125:
	if 0 != 0 {
		goto __124
	}
	goto __126
__126:
	;
__123:
	;
	dot_pos = cur + uintptr(10)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 10))) == '.')), int64(1)) != 0) {
		goto __127
	}
	goto digi_frac_10
__127:
	;
	cur += uintptr(10)
	sig_end = cur
	goto digi_exp_more
digi_sepr_11:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 11))) != 0)), int64(1)) != 0) {
		goto __128
	}
	cur += uintptr(11)
__129:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __130
__130:
	if 0 != 0 {
		goto __129
	}
	goto __131
__131:
	;
__128:
	;
	dot_pos = cur + uintptr(11)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 11))) == '.')), int64(1)) != 0) {
		goto __132
	}
	goto digi_frac_11
__132:
	;
	cur += uintptr(11)
	sig_end = cur
	goto digi_exp_more
digi_sepr_12:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 12))) != 0)), int64(1)) != 0) {
		goto __133
	}
	cur += uintptr(12)
__134:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __135
__135:
	if 0 != 0 {
		goto __134
	}
	goto __136
__136:
	;
__133:
	;
	dot_pos = cur + uintptr(12)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 12))) == '.')), int64(1)) != 0) {
		goto __137
	}
	goto digi_frac_12
__137:
	;
	cur += uintptr(12)
	sig_end = cur
	goto digi_exp_more
digi_sepr_13:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 13))) != 0)), int64(1)) != 0) {
		goto __138
	}
	cur += uintptr(13)
__139:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __140
__140:
	if 0 != 0 {
		goto __139
	}
	goto __141
__141:
	;
__138:
	;
	dot_pos = cur + uintptr(13)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 13))) == '.')), int64(1)) != 0) {
		goto __142
	}
	goto digi_frac_13
__142:
	;
	cur += uintptr(13)
	sig_end = cur
	goto digi_exp_more
digi_sepr_14:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 14))) != 0)), int64(1)) != 0) {
		goto __143
	}
	cur += uintptr(14)
__144:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __145
__145:
	if 0 != 0 {
		goto __144
	}
	goto __146
__146:
	;
__143:
	;
	dot_pos = cur + uintptr(14)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 14))) == '.')), int64(1)) != 0) {
		goto __147
	}
	goto digi_frac_14
__147:
	;
	cur += uintptr(14)
	sig_end = cur
	goto digi_exp_more
digi_sepr_15:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 15))) != 0)), int64(1)) != 0) {
		goto __148
	}
	cur += uintptr(15)
__149:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __150
__150:
	if 0 != 0 {
		goto __149
	}
	goto __151
__151:
	;
__148:
	;
	dot_pos = cur + uintptr(15)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 15))) == '.')), int64(1)) != 0) {
		goto __152
	}
	goto digi_frac_15
__152:
	;
	cur += uintptr(15)
	sig_end = cur
	goto digi_exp_more
digi_sepr_16:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 16))) != 0)), int64(1)) != 0) {
		goto __153
	}
	cur += uintptr(16)
__154:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __155
__155:
	if 0 != 0 {
		goto __154
	}
	goto __156
__156:
	;
__153:
	;
	dot_pos = cur + uintptr(16)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 16))) == '.')), int64(1)) != 0) {
		goto __157
	}
	goto digi_frac_16
__157:
	;
	cur += uintptr(16)
	sig_end = cur
	goto digi_exp_more
digi_sepr_17:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 17))) != 0)), int64(1)) != 0) {
		goto __158
	}
	cur += uintptr(17)
__159:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __160
__160:
	if 0 != 0 {
		goto __159
	}
	goto __161
__161:
	;
__158:
	;
	dot_pos = cur + uintptr(17)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 17))) == '.')), int64(1)) != 0) {
		goto __162
	}
	goto digi_frac_17
__162:
	;
	cur += uintptr(17)
	sig_end = cur
	goto digi_exp_more
digi_sepr_18:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_fp(tls, *(*U8)(unsafe.Pointer(cur + 18))) != 0)), int64(1)) != 0) {
		goto __163
	}
	cur += uintptr(18)
__164:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __165
__165:
	if 0 != 0 {
		goto __164
	}
	goto __166
__166:
	;
__163:
	;
	dot_pos = cur + uintptr(18)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(cur + 18))) == '.')), int64(1)) != 0) {
		goto __167
	}
	goto digi_frac_18
__167:
	;
	cur += uintptr(18)
	sig_end = cur
	goto digi_exp_more

	/* read fraction part */
digi_frac_1:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 2)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __168
	}
	sig = num + sig*uint64(10)
	goto __169
__168:
	goto digi_stop_1
__169:
	;
digi_frac_2:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 3)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __170
	}
	sig = num + sig*uint64(10)
	goto __171
__170:
	goto digi_stop_2
__171:
	;
digi_frac_3:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 4)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __172
	}
	sig = num + sig*uint64(10)
	goto __173
__172:
	goto digi_stop_3
__173:
	;
digi_frac_4:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 5)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __174
	}
	sig = num + sig*uint64(10)
	goto __175
__174:
	goto digi_stop_4
__175:
	;
digi_frac_5:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 6)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __176
	}
	sig = num + sig*uint64(10)
	goto __177
__176:
	goto digi_stop_5
__177:
	;
digi_frac_6:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 7)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __178
	}
	sig = num + sig*uint64(10)
	goto __179
__178:
	goto digi_stop_6
__179:
	;
digi_frac_7:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 8)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __180
	}
	sig = num + sig*uint64(10)
	goto __181
__180:
	goto digi_stop_7
__181:
	;
digi_frac_8:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 9)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __182
	}
	sig = num + sig*uint64(10)
	goto __183
__182:
	goto digi_stop_8
__183:
	;
digi_frac_9:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 10)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __184
	}
	sig = num + sig*uint64(10)
	goto __185
__184:
	goto digi_stop_9
__185:
	;
digi_frac_10:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 11)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __186
	}
	sig = num + sig*uint64(10)
	goto __187
__186:
	goto digi_stop_10
__187:
	;
digi_frac_11:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 12)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __188
	}
	sig = num + sig*uint64(10)
	goto __189
__188:
	goto digi_stop_11
__189:
	;
digi_frac_12:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 13)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __190
	}
	sig = num + sig*uint64(10)
	goto __191
__190:
	goto digi_stop_12
__191:
	;
digi_frac_13:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 14)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __192
	}
	sig = num + sig*uint64(10)
	goto __193
__192:
	goto digi_stop_13
__193:
	;
digi_frac_14:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 15)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __194
	}
	sig = num + sig*uint64(10)
	goto __195
__194:
	goto digi_stop_14
__195:
	;
digi_frac_15:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 16)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __196
	}
	sig = num + sig*uint64(10)
	goto __197
__196:
	goto digi_stop_15
__197:
	;
digi_frac_16:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 17)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __198
	}
	sig = num + sig*uint64(10)
	goto __199
__198:
	goto digi_stop_16
__199:
	;
digi_frac_17:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 18)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __200
	}
	sig = num + sig*uint64(10)
	goto __201
__200:
	goto digi_stop_17
__201:
	;
digi_frac_18:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(libc.AssignUint64(&num, U64(int32(*(*U8)(unsafe.Pointer(cur + 19)))-int32(U8('0')))) <= uint64(9))), int64(1)) != 0) {
		goto __202
	}
	sig = num + sig*uint64(10)
	goto __203
__202:
	goto digi_stop_18
__203:
	;

	cur += uintptr(20) // skip 19 digits and 1 decimal point
	if !!(Digi_is_digit(tls, *(*U8)(unsafe.Pointer(cur))) != 0) {
		goto __204
	}
	goto digi_frac_end
__204:
	;                   // fraction part end
	goto digi_frac_more /* read more digits in fraction part */

	/* significant part end */
digi_stop_1:
	cur += uintptr(1 + 1)
	goto digi_frac_end
digi_stop_2:
	cur += uintptr(2 + 1)
	goto digi_frac_end
digi_stop_3:
	cur += uintptr(3 + 1)
	goto digi_frac_end
digi_stop_4:
	cur += uintptr(4 + 1)
	goto digi_frac_end
digi_stop_5:
	cur += uintptr(5 + 1)
	goto digi_frac_end
digi_stop_6:
	cur += uintptr(6 + 1)
	goto digi_frac_end
digi_stop_7:
	cur += uintptr(7 + 1)
	goto digi_frac_end
digi_stop_8:
	cur += uintptr(8 + 1)
	goto digi_frac_end
digi_stop_9:
	cur += uintptr(9 + 1)
	goto digi_frac_end
digi_stop_10:
	cur += uintptr(10 + 1)
	goto digi_frac_end
digi_stop_11:
	cur += uintptr(11 + 1)
	goto digi_frac_end
digi_stop_12:
	cur += uintptr(12 + 1)
	goto digi_frac_end
digi_stop_13:
	cur += uintptr(13 + 1)
	goto digi_frac_end
digi_stop_14:
	cur += uintptr(14 + 1)
	goto digi_frac_end
digi_stop_15:
	cur += uintptr(15 + 1)
	goto digi_frac_end
digi_stop_16:
	cur += uintptr(16 + 1)
	goto digi_frac_end
digi_stop_17:
	cur += uintptr(17 + 1)
	goto digi_frac_end
digi_stop_18:
	cur += uintptr(18 + 1)
	goto digi_frac_end

	// read more digits in integral part
digi_intg_more:
	if !(Digi_is_digit(tls, *(*U8)(unsafe.Pointer(cur))) != 0) {
		goto __205
	}
	if !!(Digi_is_digit_or_fp(tls, *(*U8)(unsafe.Pointer(cur + 1))) != 0) {
		goto __206
	}
	// this number is an integer consisting of 20 digits
	num = U64(int32(*(*U8)(unsafe.Pointer(cur))) - '0')
	if !(sig < (U64(0xFFFFFFFF)<<32+0xFFFFFFFF)/uint64(10) || sig == (U64(0xFFFFFFFF)<<32+0xFFFFFFFF)/uint64(10) && num <= (U64(0xFFFFFFFF)<<32+0xFFFFFFFF)%uint64(10)) {
		goto __207
	}
	sig = num + sig*uint64(10)
	cur++
	// convert to double if overflow
	if !(sign != 0) {
		goto __208
	}
__209:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
	*(*float64)(unsafe.Pointer(val + 8)) = func() float64 {
		if sign != 0 {
			return -Normalized_u64_to_f64(tls, sig)
		}
		return Normalized_u64_to_f64(tls, sig)
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __210
__210:
	if 0 != 0 {
		goto __209
	}
	goto __211
__211:
	;
__208:
	;
__212:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(int32(Uint8_t(4)) | int32(U8(int32(U8(sign))<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = func() uint64 {
		if sign != 0 {
			return ^sig + uint64(1)
		}
		return sig
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __213
__213:
	if 0 != 0 {
		goto __212
	}
	goto __214
__214:
	;
__207:
	;
__206:
	;
__205:
	;

	if !(Digi_is_exp(tls, *(*U8)(unsafe.Pointer(cur))) != 0) {
		goto __215
	}
	dot_pos = cur
	goto digi_exp_more
__215:
	;

	if !(int32(*(*U8)(unsafe.Pointer(cur))) == '.') {
		goto __216
	}
	dot_pos = libc.PostIncUintptr(&cur, 1)
	if !!(Digi_is_digit(tls, *(*U8)(unsafe.Pointer(cur))) != 0) {
		goto __217
	}
__218:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 107 /* "no digit after d..." */
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(False)
	goto __219
__219:
	if 0 != 0 {
		goto __218
	}
	goto __220
__220:
	;
__217:
	;
__216:
	;

	// read more digits in fraction part
digi_frac_more:
	sig_cut = cur                                                           // too large to fit in u64, excess digits need to be cut
	sig = sig + U64(libc.Bool32(int32(*(*U8)(unsafe.Pointer(cur))) >= '5')) // round
__221:
	if !(Digi_is_digit(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&cur, 1)))) != 0) {
		goto __222
	}
	goto __221
__222:
	;
	if !!(dot_pos != 0) {
		goto __223
	}
	dot_pos = cur
	if !(int32(*(*U8)(unsafe.Pointer(cur))) == '.') {
		goto __224
	}
	if !!(Digi_is_digit(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&cur, 1)))) != 0) {
		goto __225
	}
__226:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 107 /* "no digit after d..." */
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(False)
	goto __227
__227:
	if 0 != 0 {
		goto __226
	}
	goto __228
__228:
	;
__225:
	;
__229:
	if !(Digi_is_digit(tls, *(*U8)(unsafe.Pointer(cur))) != 0) {
		goto __230
	}
	cur++
	goto __229
__230:
	;
__224:
	;
__223:
	;
	exp_sig = I64((int64(dot_pos) - int64(sig_cut)) / 1)
	exp_sig = exp_sig + I64(libc.Bool32(dot_pos < sig_cut))

	// ignore trailing zeros
	tmp = cur - uintptr(1)
__231:
	if !(int32(*(*U8)(unsafe.Pointer(tmp))) == '0' || int32(*(*U8)(unsafe.Pointer(tmp))) == '.') {
		goto __232
	}
	tmp--
	goto __231
__232:
	;
	if !(tmp < sig_cut) {
		goto __233
	}
	sig_cut = uintptr(0)
	goto __234
__233:
	sig_end = cur
__234:
	;

	if !(Digi_is_exp(tls, *(*U8)(unsafe.Pointer(cur))) != 0) {
		goto __235
	}
	goto digi_exp_more
__235:
	;
	goto digi_exp_finish

	// fraction part end
digi_frac_end:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(dot_pos+uintptr(1) == cur)), int64(0)) != 0) {
		goto __236
	}
__237:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 107 /* "no digit after d..." */
	*(*uintptr)(unsafe.Pointer(end)) = cur - uintptr(1)
	return uint8(False)
	goto __238
__238:
	if 0 != 0 {
		goto __237
	}
	goto __239
__239:
	;
__236:
	;
	sig_end = cur
	exp_sig = -I64(U64((int64(cur)-int64(dot_pos))/1) - uint64(1))
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_exp(tls, *(*U8)(unsafe.Pointer(cur))) != 0)), int64(1)) != 0) {
		goto __240
	}
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(exp_sig < int64(-324-19))), int64(0)) != 0) {
		goto __242
	}
__243:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = U64(sign)<<63 | uint64(0)
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __244
__244:
	if 0 != 0 {
		goto __243
	}
	goto __245
__245:
	; // underflow
__242:
	;
	*(*I32)(unsafe.Pointer(bp + 608 /* exp */)) = I32(exp_sig)
	goto digi_finish
	goto __241
__240:
	goto digi_exp_more
__241:
	;

	// read exponent part
digi_exp_more:
	exp_sign = uint8(libc.Bool32(int32(*(*U8)(unsafe.Pointer(libc.PreIncUintptr(&cur, 1)))) == '-'))
	cur += uintptr(Digi_is_sign(tls, *(*U8)(unsafe.Pointer(cur))))
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Digi_is_digit(tls, *(*U8)(unsafe.Pointer(cur))) != 0)), int64(0)) != 0) {
		goto __246
	}
__247:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 176 /* "no digit after e..." */
	*(*uintptr)(unsafe.Pointer(end)) = cur - uintptr(1)
	return uint8(False)
	goto __248
__248:
	if 0 != 0 {
		goto __247
	}
	goto __249
__249:
	;
__246:
	;
__250:
	if !(int32(*(*U8)(unsafe.Pointer(cur))) == '0') {
		goto __251
	}
	cur++
	goto __250
__251:
	;

	// read exponent literal
	tmp = cur
__252:
	if !(Digi_is_digit(tls, *(*U8)(unsafe.Pointer(cur))) != 0) {
		goto __253
	}
	exp_lit = I64(U64(U8(int32(*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))))-'0')) + U64(exp_lit)*uint64(10))
	goto __252
__253:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!((int64(cur)-int64(tmp))/1 >= int64(U64_SAFE_DIG))), int64(0)) != 0) {
		goto __254
	}
	if !(exp_sign != 0) {
		goto __255
	}
__257:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = U64(sign)<<63 | uint64(0)
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __258
__258:
	if 0 != 0 {
		goto __257
	}
	goto __259
__259:
	; // underflow
	goto __256
__255:
__260:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_INF_AND_NAN != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __263
	}
__265:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = U64(sign)<<63 | (U64(0x7FF00000)<<32 + 0x00000000)
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __266
__266:
	if 0 != 0 {
		goto __265
	}
	goto __267
__267:
	;
	goto __264
__263:
__268:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 205 /* "number is infini..." */
	*(*uintptr)(unsafe.Pointer(end)) = hdr
	return uint8(False)
	goto __269
__269:
	if 0 != 0 {
		goto __268
	}
	goto __270
__270:
	;
__264:
	;
	goto __261
__261:
	if 0 != 0 {
		goto __260
	}
	goto __262
__262:
	; // overflow
__256:
	;
__254:
	;
	exp_sig = exp_sig + func() int64 {
		if exp_sign != 0 {
			return -exp_lit
		}
		return exp_lit
	}()

	// validate exponent value
digi_exp_finish:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(exp_sig < int64(-324-19))), int64(0)) != 0) {
		goto __271
	}
__272:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = U64(sign)<<63 | uint64(0)
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __273
__273:
	if 0 != 0 {
		goto __272
	}
	goto __274
__274:
	; // underflow
__271:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(exp_sig > int64(F64_MAX_DEC_EXP))), int64(0)) != 0) {
		goto __275
	}
__276:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_INF_AND_NAN != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __279
	}
__281:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = U64(sign)<<63 | (U64(0x7FF00000)<<32 + 0x00000000)
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __282
__282:
	if 0 != 0 {
		goto __281
	}
	goto __283
__283:
	;
	goto __280
__279:
__284:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 205 /* "number is infini..." */
	*(*uintptr)(unsafe.Pointer(end)) = hdr
	return uint8(False)
	goto __285
__285:
	if 0 != 0 {
		goto __284
	}
	goto __286
__286:
	;
__280:
	;
	goto __277
__277:
	if 0 != 0 {
		goto __276
	}
	goto __278
__278:
	; // overflow
__275:
	;
	*(*I32)(unsafe.Pointer(bp + 608 /* exp */)) = I32(exp_sig)

	// all digit read finished
digi_finish:

	//
	//      Fast path 1:
	//
	//      1. The floating-point number calculation should be accurate, see the
	//         comments of macro `YYJSON_DOUBLE_MATH_CORRECT`.
	//      2. Correct rounding should be performed (fegetround() == FE_TONEAREST).
	//      3. The input of floating point number calculation does not lose precision,
	//         which means: 64 - leading_zero(input) - trailing_zero(input) < 53.
	//
	//      We don't check all available inputs here, because that would make the code
	//      more complicated, and not friendly to branch predictor.
	//
	if !(sig < U64(uint64(1))<<53 && *(*I32)(unsafe.Pointer(bp + 608)) >= -F64_POW10_EXP_MAX_EXACT && *(*I32)(unsafe.Pointer(bp + 608)) <= +F64_POW10_EXP_MAX_EXACT) {
		goto __287
	}
	dbl = F64(sig)
	if !(*(*I32)(unsafe.Pointer(bp + 608)) < 0) {
		goto __288
	}
	dbl = dbl / f64_pow10_table[-*(*I32)(unsafe.Pointer(bp + 608))]
	goto __289
__288:
	dbl = dbl * f64_pow10_table[+*(*I32)(unsafe.Pointer(bp + 608))]
__289:
	;
__290:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
	*(*float64)(unsafe.Pointer(val + 8)) = func() float64 {
		if sign != 0 {
			return -dbl
		}
		return dbl
	}()
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __291
__291:
	if 0 != 0 {
		goto __290
	}
	goto __292
__292:
	;
__287:
	;

	//
	//      Fast path 2:
	//
	//      To keep it simple, we only accept normal number here,
	//      let the slow path to handle subnormal and infinity number.
	//
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(!(sig_cut != 0) && *(*I32)(unsafe.Pointer(bp + 608)) > -F64_MAX_DEC_EXP+1 && *(*I32)(unsafe.Pointer(bp + 608)) < +F64_MAX_DEC_EXP-20)), int64(1)) != 0) {
		goto __293
	}
	exact = uint8(False)

	// convert (10^exp) to (sig2 * 2^exp2)
	Pow10_table_get_sig(tls, *(*I32)(unsafe.Pointer(bp + 608 /* exp */)), bp, bp+8)
	Pow10_table_get_exp(tls, *(*I32)(unsafe.Pointer(bp + 608 /* exp */)), bp+16)

	// normalize and multiply
	lz = U64_lz_bits(tls, sig)
	sig1 = sig << lz
	*(*I32)(unsafe.Pointer(bp + 16 /* exp2 */)) -= I32(lz)
	U128_mul(tls, sig1, *(*U64)(unsafe.Pointer(bp /* sig2 */)), bp+24, bp+32)

	//
	//          The `hi` is in range [0x4000000000000000, 0xFFFFFFFFFFFFFFFE],
	//          To get normalized value, `hi` should be shifted to the left by 0 or 1.
	//
	//          The highest significant 53 bits is used by IEEE-754 double number,
	//          and the bit 54 is used to detect rounding direction.
	//
	//          The lowest (64 - 54 - 1) bits is used to check whether it contains 0.
	//
	bits = *(*U64)(unsafe.Pointer(bp + 24)) & (U64(uint64(1))<<(64-54-1) - uint64(1))
	if !(bits-uint64(1) < U64(uint64(1))<<(64-54-1)-uint64(2)) {
		goto __294
	}
	//
	//              (bits != 0 && bits != 0x1FF) => (bits - 1 < 0x1FF - 1)
	//              The `bits` is not zero, so we don't need to check `round to even`
	//              case. The `bits` contains bit `0`, so we can drop the extra bits
	//              after `0`.
	//
	exact = uint8(True)

	goto __295
__294:
	//
	//              (bits == 0 || bits == 0x1FF)
	//              The `bits` is filled with all `0` or all `1`, so we need to check
	//              lower bits with another 64-bit multiplication.
	//
	U128_mul(tls, sig1, *(*U64)(unsafe.Pointer(bp + 8 /* sig2_ext */)), bp+40, bp+48)

	add = *(*U64)(unsafe.Pointer(bp + 32)) + *(*U64)(unsafe.Pointer(bp + 40))
	if !(add+uint64(1) > uint64(1)) {
		goto __296
	}
	//
	//                  (add != 0 && add != U64_MAX) => (add + 1 > 1)
	//                  The `add` is not zero, so we don't need to check `round to
	//                  even` case. The `add` contains bit `0`, so we can drop the
	//                  extra bits after `0`. The `hi` cannot be U64_MAX, so it will
	//                  not overflow.
	//
	carry = uint8(libc.Bool32(add < *(*U64)(unsafe.Pointer(bp + 32)) || add < *(*U64)(unsafe.Pointer(bp + 40))))
	*(*U64)(unsafe.Pointer(bp + 24 /* hi */)) += U64(carry)
	exact = uint8(True)
__296:
	;
__295:
	;

	if !(exact != 0) {
		goto __297
	}
	// normalize
	lz = U32(libc.Bool32(*(*U64)(unsafe.Pointer(bp + 24)) < U64(uint64(1))<<63))
	*(*U64)(unsafe.Pointer(bp + 24 /* hi */)) <<= lz
	*(*I32)(unsafe.Pointer(bp + 16 /* exp2 */)) -= I32(lz)
	*(*I32)(unsafe.Pointer(bp + 16 /* exp2 */)) += 64

	// test the bit 54 and get rounding direction
	round_up = uint8(libc.Bool32(*(*U64)(unsafe.Pointer(bp + 24))&(U64(uint64(1))<<(64-54)) > uint64(0)))
	*(*U64)(unsafe.Pointer(bp + 24 /* hi */)) += func() uint64 {
		if round_up != 0 {
			return U64(uint64(1)) << (64 - 54)
		}
		return uint64(0)
	}()

	// test overflow
	if !(*(*U64)(unsafe.Pointer(bp + 24)) < U64(uint64(1))<<(64-54)) {
		goto __298
	}
	*(*U64)(unsafe.Pointer(bp + 24 /* hi */)) = U64(uint64(1)) << 63
	*(*I32)(unsafe.Pointer(bp + 16 /* exp2 */)) += 1
__298:
	;

	// This is a normal number, convert it to IEEE-754 format.
	*(*U64)(unsafe.Pointer(bp + 24 /* hi */)) >>= F64_BITS - F64_SIG_FULL_BITS
	*(*I32)(unsafe.Pointer(bp + 16 /* exp2 */)) += F64_BITS - F64_SIG_FULL_BITS + F64_SIG_BITS
	*(*I32)(unsafe.Pointer(bp + 16 /* exp2 */)) += F64_EXP_BIAS
	raw = U64(*(*I32)(unsafe.Pointer(bp + 16)))<<F64_SIG_BITS | *(*U64)(unsafe.Pointer(bp + 24))&(U64(0x000FFFFF)<<32+0xFFFFFFFF)
__299:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = U64(sign)<<63 | raw
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __300
__300:
	if 0 != 0 {
		goto __299
	}
	goto __301
__301:
	;
__297:
	;
__293:
	;

	/*
	   Slow path: read double number exactly with diyfp.
	   1. Use cached diyfp to get an approximation value.
	   2. Use bigcomp to check the approximation value if needed.

	   This algorithm refers to google's double-conversion project:
	   https://github.com/google/double-conversion
	*/

	ERR_ULP_LOG = 3
	ERR_ULP = int32(1) << ERR_ULP_LOG
	ERR_CACHED_POW = ERR_ULP / 2
	ERR_MUL_FIXED = ERR_ULP / 2
	DIY_SIG_BITS = 64
	EXP_BIAS = F64_EXP_BIAS + F64_SIG_BITS
	EXP_SUBNORMAL = -EXP_BIAS + 1

	(*Diy_fp)(unsafe.Pointer(bp + 56 /* &fp */)).Sig = sig
	(*Diy_fp)(unsafe.Pointer(bp + 56 /* &fp */)).Exp = 0
	if sig_cut != 0 {
		fp_err = U64(ERR_ULP / 2)
	} else {
		fp_err = uint64(0)
	}

	// normalize
	bits1 = U64_lz_bits(tls, (*Diy_fp)(unsafe.Pointer(bp+56 /* &fp */)).Sig)
	libc.AssignShlPtrUint64(bp+56, int(bits1))
	*(*I32)(unsafe.Pointer(bp + 56 + 8)) -= I32(bits1)
	fp_err <<= bits1

	// multiply and add error
	*(*Diy_fp)(unsafe.Pointer(bp + 56 /* fp */)) = Diy_fp_mul(tls, *(*Diy_fp)(unsafe.Pointer(bp + 56 /* fp */)), Diy_fp_get_cached_pow10(tls, *(*I32)(unsafe.Pointer(bp + 608 /* exp */))))
	fp_err = fp_err + (U64(ERR_CACHED_POW) + U64(libc.Bool32(fp_err != uint64(0))) + U64(ERR_MUL_FIXED))

	// normalize
	bits1 = U64_lz_bits(tls, (*Diy_fp)(unsafe.Pointer(bp+56 /* &fp */)).Sig)
	libc.AssignShlPtrUint64(bp+56, int(bits1))
	*(*I32)(unsafe.Pointer(bp + 56 + 8)) -= I32(bits1)
	fp_err <<= bits1

	// effective significand
	order_of_magnitude = DIY_SIG_BITS + (*Diy_fp)(unsafe.Pointer(bp+56)).Exp
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(order_of_magnitude >= EXP_SUBNORMAL+F64_SIG_FULL_BITS)), int64(1)) != 0) {
		goto __302
	}
	effective_significand_size = F64_SIG_FULL_BITS
	goto __303
__302:
	if !(order_of_magnitude <= EXP_SUBNORMAL) {
		goto __304
	}
	effective_significand_size = 0
	goto __305
__304:
	effective_significand_size = order_of_magnitude - EXP_SUBNORMAL
__305:
	;
__303:
	;

	// precision digits count
	precision_digits_count = DIY_SIG_BITS - effective_significand_size
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(precision_digits_count+ERR_ULP_LOG >= DIY_SIG_BITS)), int64(0)) != 0) {
		goto __306
	}
	shr = precision_digits_count + ERR_ULP_LOG - DIY_SIG_BITS + 1
	libc.AssignShrPtrUint64(bp+56, int(shr))
	*(*I32)(unsafe.Pointer(bp + 56 + 8)) += shr
	fp_err = fp_err>>shr + uint64(1) + U64(U32(ERR_ULP))
	precision_digits_count = precision_digits_count - shr
__306:
	;

	// half way
	precision_bits = (*Diy_fp)(unsafe.Pointer(bp+56)).Sig & (U64(uint64(1))<<precision_digits_count - uint64(1))
	precision_bits = precision_bits * U64(U32(ERR_ULP))
	half_way = U64(uint64(1)) << (precision_digits_count - 1)
	half_way = half_way * U64(U32(ERR_ULP))

	// rounding
	libc.AssignShrPtrUint64(bp+56, int(precision_digits_count))
	*(*U64)(unsafe.Pointer(bp + 56)) += U64(libc.Bool32(precision_bits >= half_way+fp_err))
	*(*I32)(unsafe.Pointer(bp + 56 + 8)) += precision_digits_count

	// get IEEE double raw value
	raw1 = Diy_fp_to_ieee_raw(tls, *(*Diy_fp)(unsafe.Pointer(bp + 56 /* fp */)))
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(raw1 == U64(0x7FF00000)<<32+0x00000000)), int64(0)) != 0) {
		goto __307
	}
__308:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_INF_AND_NAN != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __311
	}
__313:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = U64(sign)<<63 | (U64(0x7FF00000)<<32 + 0x00000000)
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __314
__314:
	if 0 != 0 {
		goto __313
	}
	goto __315
__315:
	;
	goto __312
__311:
__316:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 205 /* "number is infini..." */
	*(*uintptr)(unsafe.Pointer(end)) = hdr
	return uint8(False)
	goto __317
__317:
	if 0 != 0 {
		goto __316
	}
	goto __318
__318:
	;
__312:
	;
	goto __309
__309:
	if 0 != 0 {
		goto __308
	}
	goto __310
__310:
	;
__307:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(precision_bits <= half_way-fp_err || precision_bits >= half_way+fp_err)), int64(1)) != 0) {
		goto __319
	}
__320:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = U64(sign)<<63 | raw1
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __321
__321:
	if 0 != 0 {
		goto __320
	}
	goto __322
__322:
	; // number is accurate
__319:
	;
	// now the number is the correct value, or the next lower value

	// upper boundary
	if !(raw1&(U64(0x7FF00000)<<32+0x00000000) != 0) {
		goto __323
	}
	(*Diy_fp)(unsafe.Pointer(bp + 72 /* &fp_upper */)).Sig = raw1&(U64(0x000FFFFF)<<32+0xFFFFFFFF) + U64(uint64(1))<<F64_SIG_BITS
	(*Diy_fp)(unsafe.Pointer(bp + 72 /* &fp_upper */)).Exp = I32(raw1 & (U64(0x7FF00000)<<32 + 0x00000000) >> F64_SIG_BITS)
	goto __324
__323:
	(*Diy_fp)(unsafe.Pointer(bp + 72 /* &fp_upper */)).Sig = raw1 & (U64(0x000FFFFF)<<32 + 0xFFFFFFFF)
	(*Diy_fp)(unsafe.Pointer(bp + 72 /* &fp_upper */)).Exp = 1
__324:
	;
	*(*I32)(unsafe.Pointer(bp + 72 + 8)) -= F64_EXP_BIAS + F64_SIG_BITS
	libc.AssignShlPtrUint64(bp+72, int(1))
	*(*I32)(unsafe.Pointer(bp + 72 + 8)) -= 1
	*(*U64)(unsafe.Pointer(bp + 72)) += uint64(1) // add half ulp

	// compare with bigint
	bigint_set_buf(tls, bp+88, sig, bp+608, sig_cut, sig_end, dot_pos)
	Bigint_set_u64(tls, bp+616, (*Diy_fp)(unsafe.Pointer(bp+72 /* &fp_upper */)).Sig)
	if !(*(*I32)(unsafe.Pointer(bp + 608)) >= 0) {
		goto __325
	}
	Bigint_mul_pow10(tls, bp+88, +*(*I32)(unsafe.Pointer(bp + 608 /* exp */)))
	goto __326
__325:
	Bigint_mul_pow10(tls, bp+616, -*(*I32)(unsafe.Pointer(bp + 608 /* exp */)))
__326:
	;
	if !((*Diy_fp)(unsafe.Pointer(bp+72)).Exp > 0) {
		goto __327
	}
	Bigint_mul_pow2(tls, bp+616, +U32((*Diy_fp)(unsafe.Pointer(bp+72 /* &fp_upper */)).Exp))
	goto __328
__327:
	Bigint_mul_pow2(tls, bp+88, U32(-(*Diy_fp)(unsafe.Pointer(bp+72 /* &fp_upper */)).Exp))
__328:
	;
	cmp = Bigint_cmp(tls, bp+88, bp+616)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cmp != 0)), int64(1)) != 0) {
		goto __329
	}
	// round down or round up
	raw1 = raw1 + U64(libc.Bool32(cmp > 0))
	goto __330
__329:
	// falls midway, round to even
	raw1 = raw1 + raw1&uint64(1)
__330:
	;

	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(raw1 == U64(0x7FF00000)<<32+0x00000000)), int64(0)) != 0) {
		goto __331
	}
__332:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_INF_AND_NAN != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __335
	}
__337:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = U64(sign)<<63 | (U64(0x7FF00000)<<32 + 0x00000000)
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __338
__338:
	if 0 != 0 {
		goto __337
	}
	goto __339
__339:
	;
	goto __336
__335:
__340:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 205 /* "number is infini..." */
	*(*uintptr)(unsafe.Pointer(end)) = hdr
	return uint8(False)
	goto __341
__341:
	if 0 != 0 {
		goto __340
	}
	goto __342
__342:
	;
__336:
	;
	goto __333
__333:
	if 0 != 0 {
		goto __332
	}
	goto __334
__334:
	;
__331:
	;
__343:
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = uint64(int32(Uint8_t(4)) | int32(Uint8_t(int32(2)<<3)))
	*(*Uint64_t)(unsafe.Pointer(val + 8)) = U64(sign)<<63 | raw1
	*(*uintptr)(unsafe.Pointer(end)) = cur
	return uint8(True)
	goto __344
__344:
	if 0 != 0 {
		goto __343
	}
	goto __345
__345:
	;

	return uint8(0)

}

// ==============================================================================
// JSON String Reader
//============================================================================

//*
//  Read a JSON string.
//  @param cur The head of string before '"' prefix.
//  @param end The end of string after '"' suffix.
//  @param val The string value to be written.
//  @param msg The error message pointer.
//  @return Whether success.
//
func Read_string(tls *libc.TLS, cur uintptr, end uintptr, val uintptr, msg uintptr) uint8 { /* yyjson.c:3843:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	//
	//      Each unicode code point is encoded as 1 to 4 bytes in UTF-8 encoding,
	//      we use 4-byte mask and pattern value to validate UTF-8 byte sequence,
	//      this requires the input data to have 4-byte zero padding.
	//      ---------------------------------------------------
	//      1 byte
	//      unicode range [U+0000, U+007F]
	//      unicode min   [.......0]
	//      unicode max   [.1111111]
	//      bit pattern   [0.......]
	//      ---------------------------------------------------
	//      2 byte
	//      unicode range [U+0080, U+07FF]
	//      unicode min   [......10 ..000000]
	//      unicode max   [...11111 ..111111]
	//      bit require   [...xxxx. ........] (1E 00)
	//      bit mask      [xxx..... xx......] (E0 C0)
	//      bit pattern   [110..... 10......] (C0 80)
	//      ---------------------------------------------------
	//      3 byte
	//      unicode range [U+0800, U+FFFF]
	//      unicode min   [........ ..100000 ..000000]
	//      unicode max   [....1111 ..111111 ..111111]
	//      bit require   [....xxxx ..x..... ........] (0F 20 00)
	//      bit mask      [xxxx.... xx...... xx......] (F0 C0 C0)
	//      bit pattern   [1110.... 10...... 10......] (E0 80 80)
	//      ---------------------------------------------------
	//      3 byte invalid (reserved for surrogate halves)
	//      unicode range [U+D800, U+DFFF]
	//      unicode min   [....1101 ..100000 ..000000]
	//      unicode max   [....1101 ..111111 ..111111]
	//      bit mask      [....xxxx ..x..... ........] (0F 20 00)
	//      bit pattern   [....1101 ..1..... ........] (0D 20 00)
	//      ---------------------------------------------------
	//      4 byte
	//      unicode range [U+10000, U+10FFFF]
	//      unicode min   [........ ...10000 ..000000 ..000000]
	//      unicode max   [.....100 ..001111 ..111111 ..111111]
	//      bit require   [.....xxx ..xx.... ........ ........] (07 30 00 00)
	//      bit mask      [xxxxx... xx...... xx...... xx......] (F8 C0 C0 C0)
	//      bit pattern   [11110... 10...... 10...... 10......] (F0 80 80 80)
	//      ---------------------------------------------------
	//
	var b1_mask U32
	var b1_patt U32
	var b2_mask U32
	var b2_patt U32
	var b2_requ U32
	var b3_mask U32
	var b3_patt U32
	var b3_requ U32
	var b3_erro U32
	var b4_mask U32
	var b4_patt U32
	var b4_requ U32
	var b4_err0 U32
	var b4_err1 U32
	var src uintptr
	var dst uintptr
	var pos uintptr
	// var hi U16 at bp, 2

	// var lo U16 at bp+2, 2

	// var uni U32 at bp+4, 4

	var tmp U32
	b1_mask = uint32(0x00000080)
	b1_patt = uint32(0x00000000)
	b2_mask = uint32(0x0000C0E0)
	b2_patt = uint32(0x000080C0)
	b2_requ = uint32(0x0000001E)
	b3_mask = uint32(0x00C0C0F0)
	b3_patt = uint32(0x008080E0)
	b3_requ = uint32(0x0000200F)
	b3_erro = uint32(0x0000200D)
	b4_mask = uint32(0xC0C0C0F8)
	b4_patt = uint32(0x808080F0)
	b4_requ = uint32(0x00003007)
	b4_err0 = uint32(0x00000004)
	b4_err1 = uint32(0x00003003)
	src = libc.PreIncUintptr(&cur, 1)

skip_ascii:
	// Most strings have no escaped characters, so we can jump them quickly.

skip_ascii_begin:
	/*
	   We want to make loop unrolling, as shown in the following code. Some
	   compiler may not generate instructions as expected, so we rewrite it with
	   explicit goto statements. We hope the compiler can generate instructions
	   like this: https://godbolt.org/z/8vjsYq

	       while (true) repeat16({
	          if (likely(!(char_is_ascii_stop(*src)))) src++;
	          else break;
	       });
	*/

	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src))) != 0)), int64(1)) != 0) {
		goto __1
	}
	goto __2
__1:
	goto skip_ascii_stop0
__2:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 1))) != 0)), int64(1)) != 0) {
		goto __3
	}
	goto __4
__3:
	goto skip_ascii_stop1
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 2))) != 0)), int64(1)) != 0) {
		goto __5
	}
	goto __6
__5:
	goto skip_ascii_stop2
__6:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 3))) != 0)), int64(1)) != 0) {
		goto __7
	}
	goto __8
__7:
	goto skip_ascii_stop3
__8:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 4))) != 0)), int64(1)) != 0) {
		goto __9
	}
	goto __10
__9:
	goto skip_ascii_stop4
__10:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 5))) != 0)), int64(1)) != 0) {
		goto __11
	}
	goto __12
__11:
	goto skip_ascii_stop5
__12:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 6))) != 0)), int64(1)) != 0) {
		goto __13
	}
	goto __14
__13:
	goto skip_ascii_stop6
__14:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 7))) != 0)), int64(1)) != 0) {
		goto __15
	}
	goto __16
__15:
	goto skip_ascii_stop7
__16:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 8))) != 0)), int64(1)) != 0) {
		goto __17
	}
	goto __18
__17:
	goto skip_ascii_stop8
__18:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 9))) != 0)), int64(1)) != 0) {
		goto __19
	}
	goto __20
__19:
	goto skip_ascii_stop9
__20:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 10))) != 0)), int64(1)) != 0) {
		goto __21
	}
	goto __22
__21:
	goto skip_ascii_stop10
__22:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 11))) != 0)), int64(1)) != 0) {
		goto __23
	}
	goto __24
__23:
	goto skip_ascii_stop11
__24:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 12))) != 0)), int64(1)) != 0) {
		goto __25
	}
	goto __26
__25:
	goto skip_ascii_stop12
__26:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 13))) != 0)), int64(1)) != 0) {
		goto __27
	}
	goto __28
__27:
	goto skip_ascii_stop13
__28:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 14))) != 0)), int64(1)) != 0) {
		goto __29
	}
	goto __30
__29:
	goto skip_ascii_stop14
__30:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 15))) != 0)), int64(1)) != 0) {
		goto __31
	}
	goto __32
__31:
	goto skip_ascii_stop15
__32:
	;

	src += uintptr(16)
	goto skip_ascii_begin
skip_ascii_stop0:
	src += uintptr(0)
	goto skip_ascii_end
skip_ascii_stop1:
	src += uintptr(1)
	goto skip_ascii_end
skip_ascii_stop2:
	src += uintptr(2)
	goto skip_ascii_end
skip_ascii_stop3:
	src += uintptr(3)
	goto skip_ascii_end
skip_ascii_stop4:
	src += uintptr(4)
	goto skip_ascii_end
skip_ascii_stop5:
	src += uintptr(5)
	goto skip_ascii_end
skip_ascii_stop6:
	src += uintptr(6)
	goto skip_ascii_end
skip_ascii_stop7:
	src += uintptr(7)
	goto skip_ascii_end
skip_ascii_stop8:
	src += uintptr(8)
	goto skip_ascii_end
skip_ascii_stop9:
	src += uintptr(9)
	goto skip_ascii_end
skip_ascii_stop10:
	src += uintptr(10)
	goto skip_ascii_end
skip_ascii_stop11:
	src += uintptr(11)
	goto skip_ascii_end
skip_ascii_stop12:
	src += uintptr(12)
	goto skip_ascii_end
skip_ascii_stop13:
	src += uintptr(13)
	goto skip_ascii_end
skip_ascii_stop14:
	src += uintptr(14)
	goto skip_ascii_end
skip_ascii_stop15:
	src += uintptr(15)
	goto skip_ascii_end

skip_ascii_end:

	//
	//      GCC may store src[i] in a register at each line of expr_jump(i) above.
	//      These instructions are useless and will degrade performance.
	//      This inline asm is a hint for gcc: "the memory has been modified,
	//      do not cache it".
	//
	//      MSVC, Clang, ICC can generate expected instructions without this hint.
	//
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(src))) == '"')), int64(1)) != 0) {
		goto __33
	}
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = U64((int64(src)-int64(cur))/1)<<int32(Uint8_t(8)) | U64(Uint8_t(5))
	*(*uintptr)(unsafe.Pointer(val + 8)) = cur
	*(*U8)(unsafe.Pointer(src)) = U8(0)
	*(*uintptr)(unsafe.Pointer(end)) = src + uintptr(1)
	return uint8(True)
__33:
	;
	goto skip_utf8

skip_utf8:
	if !(int32(*(*U8)(unsafe.Pointer(src)))&0x80 != 0) {
		goto __34
	} // non-ASCII character
	//
	//          Non-ASCII character appears here, which means that the text is likely
	//          to be written in non-English or emoticons. According to some common
	//          data set statistics, byte sequences of the same length may appear
	//          consecutively. We process the byte sequences of the same length in each
	//          loop, which is more friendly to branch prediction.
	//
	pos = src
	*(*U32)(unsafe.Pointer(bp + 4 /* uni */)) = Byte_load_4(tls, src)
__35:
	if !(*(*U32)(unsafe.Pointer(bp + 4))&b3_mask == b3_patt && libc.AssignUint32(&tmp, *(*U32)(unsafe.Pointer(bp + 4))&b3_requ) != 0 && tmp != b3_erro) {
		goto __36
	}
	src += uintptr(3)
	*(*U32)(unsafe.Pointer(bp + 4 /* uni */)) = Byte_load_4(tls, src)
	goto __35
__36:
	;
	if !(*(*U32)(unsafe.Pointer(bp + 4))&b1_mask == b1_patt) {
		goto __37
	}
	goto skip_ascii
__37:
	;
__38:
	if !(*(*U32)(unsafe.Pointer(bp + 4))&b2_mask == b2_patt && *(*U32)(unsafe.Pointer(bp + 4))&b2_requ != 0) {
		goto __39
	}
	src += uintptr(2)
	*(*U32)(unsafe.Pointer(bp + 4 /* uni */)) = Byte_load_4(tls, src)
	goto __38
__39:
	;
__40:
	if !(*(*U32)(unsafe.Pointer(bp + 4))&b4_mask == b4_patt && libc.AssignUint32(&tmp, *(*U32)(unsafe.Pointer(bp + 4))&b4_requ) != 0 && (tmp&b4_err0 == U32(0) || tmp&b4_err1 == U32(0))) {
		goto __41
	}
	src += uintptr(4)
	*(*U32)(unsafe.Pointer(bp + 4 /* uni */)) = Byte_load_4(tls, src)
	goto __40
__41:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(pos == src)), int64(0)) != 0) {
		goto __42
	}
__43:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 246 /* "invalid UTF-8 en..." */
	*(*uintptr)(unsafe.Pointer(end)) = src
	return uint8(False)
	goto __44
__44:
	if 0 != 0 {
		goto __43
	}
	goto __45
__45:
	;

__42:
	;
	goto skip_ascii
__34:
	;

	// The escape character appears, we need to copy it.
	dst = src
copy_escape:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(src))) == '\\')), int64(1)) != 0) {
		goto __46
	}
	switch int32(*(*U8)(unsafe.Pointer(libc.PreIncUintptr(&src, 1)))) {
	case '"':
		goto __49
	case '\\':
		goto __50
	case '/':
		goto __51
	case 'b':
		goto __52
	case 'f':
		goto __53
	case 'n':
		goto __54
	case 'r':
		goto __55
	case 't':
		goto __56
	case 'u':
		goto __57
	default:
		goto __58
	}
	goto __48
__49:
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8('"')
	src++
	goto __48
__50:
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8('\\')
	src++
	goto __48
__51:
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8('/')
	src++
	goto __48
__52:
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8('\b')
	src++
	goto __48
__53:
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8('\f')
	src++
	goto __48
__54:
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8('\n')
	src++
	goto __48
__55:
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8('\r')
	src++
	goto __48
__56:
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8('\t')
	src++
	goto __48
__57:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Read_hex_u16(tls, libc.PreIncUintptr(&src, 1), bp) != 0)), int64(0)) != 0) {
		goto __59
	}
__60:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 279 /* "invalid escaped ..." */
	*(*uintptr)(unsafe.Pointer(end)) = src - uintptr(2)
	return uint8(False)
	goto __61
__61:
	if 0 != 0 {
		goto __60
	}
	goto __62
__62:
	;

__59:
	;
	src += uintptr(4)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U16)(unsafe.Pointer(bp)))&0xF800 != 0xD800)), int64(1)) != 0) {
		goto __63
	}
	// a BMP character
	if !(int32(*(*U16)(unsafe.Pointer(bp))) >= 0x800) {
		goto __65
	}
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8(0xE0 | int32(*(*U16)(unsafe.Pointer(bp)))>>12)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8(0x80 | int32(*(*U16)(unsafe.Pointer(bp)))>>6&0x3F)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8(0x80 | int32(*(*U16)(unsafe.Pointer(bp)))&0x3F)
	goto __66
__65:
	if !(int32(*(*U16)(unsafe.Pointer(bp))) >= 0x80) {
		goto __67
	}
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8(0xC0 | int32(*(*U16)(unsafe.Pointer(bp)))>>6)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8(0x80 | int32(*(*U16)(unsafe.Pointer(bp)))&0x3F)
	goto __68
__67:
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8(*(*U16)(unsafe.Pointer(bp /* hi */)))
__68:
	;
__66:
	;
	goto __64
__63:
	// a non-BMP character, represented as a surrogate pair
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U16)(unsafe.Pointer(bp)))&0xFC00 != 0xD800)), int64(0)) != 0) {
		goto __69
	}
__70:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 313 /* "invalid high sur..." */
	*(*uintptr)(unsafe.Pointer(end)) = src - uintptr(6)
	return uint8(False)
	goto __71
__71:
	if 0 != 0 {
		goto __70
	}
	goto __72
__72:
	;

__69:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Byte_match_2(tls, src, ts+346) != 0)), int64(0)) != 0 || libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Read_hex_u16(tls, src+uintptr(2), bp+2) != 0)), int64(0)) != 0) {
		goto __73
	}
__74:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 349 /* "no matched low s..." */
	*(*uintptr)(unsafe.Pointer(end)) = src
	return uint8(False)
	goto __75
__75:
	if 0 != 0 {
		goto __74
	}
	goto __76
__76:
	;

__73:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U16)(unsafe.Pointer(bp + 2)))&0xFC00 != 0xDC00)), int64(0)) != 0) {
		goto __77
	}
__78:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 384 /* "invalid low surr..." */
	*(*uintptr)(unsafe.Pointer(end)) = src
	return uint8(False)
	goto __79
__79:
	if 0 != 0 {
		goto __78
	}
	goto __80
__80:
	;

__77:
	;
	*(*U32)(unsafe.Pointer(bp + 4 /* uni */)) = (U32(*(*U16)(unsafe.Pointer(bp)))-U32(0xD800))<<10 | (U32(*(*U16)(unsafe.Pointer(bp + 2))) - U32(0xDC00)) + U32(0x10000)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8(U32(0xF0) | *(*U32)(unsafe.Pointer(bp + 4))>>18)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8(U32(0x80) | *(*U32)(unsafe.Pointer(bp + 4))>>12&U32(0x3F))
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8(U32(0x80) | *(*U32)(unsafe.Pointer(bp + 4))>>6&U32(0x3F))
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&dst, 1))) = U8(U32(0x80) | *(*U32)(unsafe.Pointer(bp + 4))&U32(0x3F))
	src += uintptr(6)
__64:
	;
	goto __48
__58:
__81:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 416 /* "invalid escaped ..." */
	*(*uintptr)(unsafe.Pointer(end)) = src
	return uint8(False)
	goto __82
__82:
	if 0 != 0 {
		goto __81
	}
	goto __83
__83:
	;

__48:
	;
	goto __47
__46:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(src))) == '"')), int64(1)) != 0) {
		goto __84
	}
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = U64((int64(dst)-int64(cur))/1)<<int32(Uint8_t(8)) | U64(Uint8_t(5))
	*(*uintptr)(unsafe.Pointer(val + 8)) = cur
	*(*U8)(unsafe.Pointer(dst)) = U8(0)
	*(*uintptr)(unsafe.Pointer(end)) = src + uintptr(1)
	return uint8(True)
	goto __85
__84:
__86:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 452 /* "unexpected contr..." */
	*(*uintptr)(unsafe.Pointer(end)) = src
	return uint8(False)
	goto __87
__87:
	if 0 != 0 {
		goto __86
	}
	goto __88
__88:
	;

__85:
	;
__47:
	;

copy_ascii:
	/*
	   Copy continuous ASCII, loop unrolling, same as the following code:

	       while (true) repeat16({
	          if (unlikely(char_is_ascii_stop(*src))) break;
	          *dst++ = *src++;
	       });
	*/
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src))) != 0)), int64(1)) != 0) {
		goto __89
	}
	goto __90
__89:
	goto copy_ascii_stop_0
__90:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 1))) != 0)), int64(1)) != 0) {
		goto __91
	}
	goto __92
__91:
	goto copy_ascii_stop_1
__92:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 2))) != 0)), int64(1)) != 0) {
		goto __93
	}
	goto __94
__93:
	goto copy_ascii_stop_2
__94:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 3))) != 0)), int64(1)) != 0) {
		goto __95
	}
	goto __96
__95:
	goto copy_ascii_stop_3
__96:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 4))) != 0)), int64(1)) != 0) {
		goto __97
	}
	goto __98
__97:
	goto copy_ascii_stop_4
__98:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 5))) != 0)), int64(1)) != 0) {
		goto __99
	}
	goto __100
__99:
	goto copy_ascii_stop_5
__100:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 6))) != 0)), int64(1)) != 0) {
		goto __101
	}
	goto __102
__101:
	goto copy_ascii_stop_6
__102:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 7))) != 0)), int64(1)) != 0) {
		goto __103
	}
	goto __104
__103:
	goto copy_ascii_stop_7
__104:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 8))) != 0)), int64(1)) != 0) {
		goto __105
	}
	goto __106
__105:
	goto copy_ascii_stop_8
__106:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 9))) != 0)), int64(1)) != 0) {
		goto __107
	}
	goto __108
__107:
	goto copy_ascii_stop_9
__108:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 10))) != 0)), int64(1)) != 0) {
		goto __109
	}
	goto __110
__109:
	goto copy_ascii_stop_10
__110:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 11))) != 0)), int64(1)) != 0) {
		goto __111
	}
	goto __112
__111:
	goto copy_ascii_stop_11
__112:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 12))) != 0)), int64(1)) != 0) {
		goto __113
	}
	goto __114
__113:
	goto copy_ascii_stop_12
__114:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 13))) != 0)), int64(1)) != 0) {
		goto __115
	}
	goto __116
__115:
	goto copy_ascii_stop_13
__116:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 14))) != 0)), int64(1)) != 0) {
		goto __117
	}
	goto __118
__117:
	goto copy_ascii_stop_14
__118:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(Char_is_ascii_stop(tls, *(*U8)(unsafe.Pointer(src + 15))) != 0)), int64(1)) != 0) {
		goto __119
	}
	goto __120
__119:
	goto copy_ascii_stop_15
__120:
	;

	Byte_move_16(tls, dst, src)
	src += uintptr(16)
	dst += uintptr(16)
	goto copy_ascii

copy_ascii_stop_0:
	goto copy_utf8
copy_ascii_stop_1:
	Byte_move_2(tls, dst, src)
	src += uintptr(1)
	dst += uintptr(1)
	goto copy_utf8
copy_ascii_stop_2:
	Byte_move_2(tls, dst, src)
	src += uintptr(2)
	dst += uintptr(2)
	goto copy_utf8
copy_ascii_stop_3:
	Byte_move_4(tls, dst, src)
	src += uintptr(3)
	dst += uintptr(3)
	goto copy_utf8
copy_ascii_stop_4:
	Byte_move_4(tls, dst, src)
	src += uintptr(4)
	dst += uintptr(4)
	goto copy_utf8
copy_ascii_stop_5:
	Byte_move_4(tls, dst, src)
	Byte_move_2(tls, dst+uintptr(4), src+uintptr(4))
	src += uintptr(5)
	dst += uintptr(5)
	goto copy_utf8
copy_ascii_stop_6:
	Byte_move_4(tls, dst, src)
	Byte_move_2(tls, dst+uintptr(4), src+uintptr(4))
	src += uintptr(6)
	dst += uintptr(6)
	goto copy_utf8
copy_ascii_stop_7:
	Byte_move_8(tls, dst, src)
	src += uintptr(7)
	dst += uintptr(7)
	goto copy_utf8
copy_ascii_stop_8:
	Byte_move_8(tls, dst, src)
	src += uintptr(8)
	dst += uintptr(8)
	goto copy_utf8
copy_ascii_stop_9:
	Byte_move_8(tls, dst, src)
	Byte_move_2(tls, dst+uintptr(8), src+uintptr(8))
	src += uintptr(9)
	dst += uintptr(9)
	goto copy_utf8
copy_ascii_stop_10:
	Byte_move_8(tls, dst, src)
	Byte_move_2(tls, dst+uintptr(8), src+uintptr(8))
	src += uintptr(10)
	dst += uintptr(10)
	goto copy_utf8
copy_ascii_stop_11:
	Byte_move_8(tls, dst, src)
	Byte_move_4(tls, dst+uintptr(8), src+uintptr(8))
	src += uintptr(11)
	dst += uintptr(11)
	goto copy_utf8
copy_ascii_stop_12:
	Byte_move_8(tls, dst, src)
	Byte_move_4(tls, dst+uintptr(8), src+uintptr(8))
	src += uintptr(12)
	dst += uintptr(12)
	goto copy_utf8
copy_ascii_stop_13:
	Byte_move_8(tls, dst, src)
	Byte_move_4(tls, dst+uintptr(8), src+uintptr(8))
	Byte_move_2(tls, dst+uintptr(12), src+uintptr(12))
	src += uintptr(13)
	dst += uintptr(13)
	goto copy_utf8
copy_ascii_stop_14:
	Byte_move_8(tls, dst, src)
	Byte_move_4(tls, dst+uintptr(8), src+uintptr(8))
	Byte_move_2(tls, dst+uintptr(12), src+uintptr(12))
	src += uintptr(14)
	dst += uintptr(14)
	goto copy_utf8
copy_ascii_stop_15:
	Byte_move_16(tls, dst, src)
	src += uintptr(15)
	dst += uintptr(15)
	goto copy_utf8

copy_utf8:
	if !(int32(*(*U8)(unsafe.Pointer(src)))&0x80 != 0) {
		goto __121
	} // non-ASCII character
	pos = src
	*(*U32)(unsafe.Pointer(bp + 4 /* uni */)) = Byte_load_4(tls, src)
__122:
	if !(*(*U32)(unsafe.Pointer(bp + 4))&b3_mask == b3_patt && libc.AssignUint32(&tmp, *(*U32)(unsafe.Pointer(bp + 4))&b3_requ) != 0 && tmp != b3_erro) {
		goto __123
	}
	Byte_move_4(tls, dst, bp+4)
	dst += uintptr(3)
	src += uintptr(3)
	*(*U32)(unsafe.Pointer(bp + 4 /* uni */)) = Byte_load_4(tls, src)
	goto __122
__123:
	;
	if !(*(*U32)(unsafe.Pointer(bp + 4))&b1_mask == b1_patt) {
		goto __124
	}
	goto copy_ascii
__124:
	;
__125:
	if !(*(*U32)(unsafe.Pointer(bp + 4))&b2_mask == b2_patt && *(*U32)(unsafe.Pointer(bp + 4))&b2_requ != 0) {
		goto __126
	}
	Byte_move_2(tls, dst, bp+4)
	dst += uintptr(2)
	src += uintptr(2)
	*(*U32)(unsafe.Pointer(bp + 4 /* uni */)) = Byte_load_4(tls, src)
	goto __125
__126:
	;
__127:
	if !(*(*U32)(unsafe.Pointer(bp + 4))&b4_mask == b4_patt && libc.AssignUint32(&tmp, *(*U32)(unsafe.Pointer(bp + 4))&b4_requ) != 0 && (tmp&b4_err0 == U32(0) || tmp&b4_err1 == U32(0))) {
		goto __128
	}
	Byte_move_4(tls, dst, bp+4)
	dst += uintptr(4)
	src += uintptr(4)
	*(*U32)(unsafe.Pointer(bp + 4 /* uni */)) = Byte_load_4(tls, src)
	goto __127
__128:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(pos == src)), int64(0)) != 0) {
		goto __129
	}
__130:
	*(*uintptr)(unsafe.Pointer(msg)) = ts + 246 /* "invalid UTF-8 en..." */
	*(*uintptr)(unsafe.Pointer(end)) = src
	return uint8(False)
	goto __131
__131:
	if 0 != 0 {
		goto __130
	}
	goto __132
__132:
	;

__129:
	;
	goto copy_ascii
__121:
	;
	goto copy_escape
	return uint8(0)

}

// ==============================================================================
// JSON Reader Implementation
//
// We use goto statements to build the finite state machine (FSM).
// The FSM's state was held by program counter (PC) and the 'goto' make the
// state transitions.
//============================================================================

//* Read single value JSON document.
func read_root_single(tls *libc.TLS, hdr uintptr, cur uintptr, end uintptr, alc Yyjson_alc, flg Yyjson_read_flag, err uintptr) uintptr { /* yyjson.c:4287:28: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp)) = cur

	var hdr_len Usize   // value count used by doc
	var alc_num Usize   // value count capacity
	var val_hdr uintptr // the head of allocated values
	var val uintptr     // current value
	var doc uintptr     // the JSON document, equals to val_hdr
	// var msg uintptr at bp+8, 8
	// error message

	hdr_len = uint64(unsafe.Sizeof(Yyjson_doc{})) / uint64(unsafe.Sizeof(Yyjson_val{}))
	hdr_len = hdr_len + uint64(libc.Bool32(uint64(unsafe.Sizeof(Yyjson_doc{}))%uint64(unsafe.Sizeof(Yyjson_val{})) > uint64(0)))
	alc_num = hdr_len + uint64(1) // single value

	val_hdr = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Malloc})).f(tls, alc.Ctx, alc_num*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(val_hdr != 0)), int64(0)) != 0) {
		goto __1
	}
	goto fail_alloc
__1:
	;
	val = val_hdr + uintptr(hdr_len)*16

	if !(Char_is_number(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __2
	}
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_number(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, flg, val, bp+8) != 0)), int64(1)) != 0) {
		goto __3
	}
	goto doc_end
__3:
	;
	goto fail_number
__2:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '"') {
		goto __4
	}
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_string(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val, bp+8) != 0)), int64(1)) != 0) {
		goto __5
	}
	goto doc_end
__5:
	;
	goto fail_string
__4:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 't') {
		goto __6
	}
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_true(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0)), int64(1)) != 0) {
		goto __7
	}
	goto doc_end
__7:
	;
	goto fail_literal
__6:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'f') {
		goto __8
	}
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_false(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0)), int64(1)) != 0) {
		goto __9
	}
	goto doc_end
__9:
	;
	goto fail_literal
__8:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'n') {
		goto __10
	}
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_null(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0)), int64(1)) != 0) {
		goto __11
	}
	goto doc_end
__11:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_INF_AND_NAN != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __12
	}
	if !(Read_nan(tls, uint8(False), *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0) {
		goto __13
	}
	goto doc_end
__13:
	;
__12:
	;
	goto fail_literal
__10:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_INF_AND_NAN != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __14
	}
	if !(Read_inf_or_nan(tls, uint8(False), *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0) {
		goto __15
	}
	goto doc_end
__15:
	;
__14:
	;
	goto fail_character

doc_end:
	// check invalid contents after json document
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*uintptr)(unsafe.Pointer(bp)) < end)), int64(0)) != 0 && !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_STOP_WHEN_DONE != Yyjson_read_flag(0))), int64(0)) != 0)) {
		goto __16
	}
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __17
	}
	if !!(skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp)), bp) != 0) {
		goto __19
	}
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+70) != 0) {
		goto __20
	}
	goto fail_comment
__20:
	;
__19:
	;
	goto __18
__17:
__21:
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __22
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto __21
__22:
	;
__18:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*uintptr)(unsafe.Pointer(bp)) < end)), int64(0)) != 0) {
		goto __23
	}
	goto fail_garbage
__23:
	;
__16:
	;

	doc = val_hdr
	(*Yyjson_doc)(unsafe.Pointer(doc)).Root = val_hdr + uintptr(hdr_len)*16
	(*Yyjson_doc)(unsafe.Pointer(doc)).Alc = alc
	(*Yyjson_doc)(unsafe.Pointer(doc)).Dat_read = Usize((int64(*(*uintptr)(unsafe.Pointer(bp))) - int64(hdr)) / 1)
	(*Yyjson_doc)(unsafe.Pointer(doc)).Val_read = uint64(1)
	(*Yyjson_doc)(unsafe.Pointer(doc)).Str_pool = func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_INSITU != Yyjson_read_flag(0))), int64(0)) != 0 {
			return uintptr(0)
		}
		return hdr
	}()
	return doc

fail_string:
__24:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __27
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __28
__27:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_INVALID_STRING
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = *(*uintptr)(unsafe.Pointer(bp + 8 /* msg */))
__28:
	;
	if !(val_hdr != 0) {
		goto __29
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__29:
	;
	return uintptr(0)
	goto __25
__25:
	if 0 != 0 {
		goto __24
	}
	goto __26
__26:
	;
fail_number:
__30:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __33
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __34
__33:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_INVALID_NUMBER
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = *(*uintptr)(unsafe.Pointer(bp + 8 /* msg */))
__34:
	;
	if !(val_hdr != 0) {
		goto __35
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__35:
	;
	return uintptr(0)
	goto __31
__31:
	if 0 != 0 {
		goto __30
	}
	goto __32
__32:
	;
fail_alloc:
__36:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __39
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __40
__39:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_MEMORY_ALLOCATION
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 514 /* "memory allocatio..." */
__40:
	;
	if !(val_hdr != 0) {
		goto __41
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__41:
	;
	return uintptr(0)
	goto __37
__37:
	if 0 != 0 {
		goto __36
	}
	goto __38
__38:
	;
fail_literal:
__42:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __45
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __46
__45:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_LITERAL
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 539 /* "invalid literal" */
__46:
	;
	if !(val_hdr != 0) {
		goto __47
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__47:
	;
	return uintptr(0)
	goto __43
__43:
	if 0 != 0 {
		goto __42
	}
	goto __44
__44:
	;
fail_comment:
__48:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __51
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __52
__51:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_INVALID_COMMENT
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 555 /* "unclosed multili..." */
__52:
	;
	if !(val_hdr != 0) {
		goto __53
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__53:
	;
	return uintptr(0)
	goto __49
__49:
	if 0 != 0 {
		goto __48
	}
	goto __50
__50:
	;
fail_character:
__54:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __57
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __58
__57:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_CHARACTER
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 582 /* "unexpected chara..." */
__58:
	;
	if !(val_hdr != 0) {
		goto __59
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__59:
	;
	return uintptr(0)
	goto __55
__55:
	if 0 != 0 {
		goto __54
	}
	goto __56
__56:
	;
fail_garbage:
__60:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __63
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __64
__63:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_CONTENT
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 603 /* "unexpected conte..." */
__64:
	;
	if !(val_hdr != 0) {
		goto __65
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__65:
	;
	return uintptr(0)
	goto __61
__61:
	if 0 != 0 {
		goto __60
	}
	goto __62
__62:
	;
	return uintptr(0)

}

//* Read JSON document (accept all style, but optimized for minify).
func Read_root_minify(tls *libc.TLS, hdr uintptr, cur uintptr, end uintptr, alc Yyjson_alc, flg Yyjson_read_flag, err uintptr) uintptr { /* yyjson.c:4396:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp)) = cur

	var dat_len Usize      // data length in bytes, hint for allocator
	var hdr_len Usize      // value count used by yyjson_doc
	var alc_len Usize      // value count allocated
	var alc_max Usize      // maximum value count for allocator
	var ctn_len Usize      // the number of elements in current container
	var val_hdr uintptr    // the head of allocated values
	var val_end uintptr    // the end of allocated values
	var val_tmp uintptr    // temporary pointer for realloc
	var val uintptr        // current JSON value
	var ctn uintptr        // current container
	var ctn_parent uintptr // parent of current container
	var doc uintptr        // the JSON document, equals to val_hdr
	// var msg uintptr at bp+8, 8
	// error message

	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_STOP_WHEN_DONE != Yyjson_read_flag(0))), int64(0)) != 0 {
		dat_len = uint64(256)
	} else {
		dat_len = Usize((int64(end) - int64(*(*uintptr)(unsafe.Pointer(bp)))) / 1)
	}
	hdr_len = uint64(unsafe.Sizeof(Yyjson_doc{})) / uint64(unsafe.Sizeof(Yyjson_val{}))
	hdr_len = hdr_len + uint64(libc.Bool32(uint64(unsafe.Sizeof(Yyjson_doc{}))%uint64(unsafe.Sizeof(Yyjson_val{})) > uint64(0)))
	alc_max = libc.CplUint64(uint64(0)) / Usize(unsafe.Sizeof(Yyjson_val{}))
	alc_len = hdr_len + dat_len/uint64(YYJSON_READER_ESTIMATED_MINIFY_RATIO) + uint64(4)
	alc_len = func() uint64 {
		if alc_len < alc_max {
			return alc_len
		}
		return alc_max
	}()

	val_hdr = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Malloc})).f(tls, alc.Ctx, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(val_hdr != 0)), int64(0)) != 0) {
		goto __1
	}
	goto fail_alloc
__1:
	;
	val_end = val_hdr + uintptr(alc_len-uint64(2))*16 // padding for key-value pair reading
	val = val_hdr + uintptr(hdr_len)*16
	ctn = val
	ctn_len = uint64(0)

	if !(int32(*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 1)))) == '{') {
		goto __2
	}
	(*Yyjson_val)(unsafe.Pointer(ctn)).Tag = Uint64_t(Uint8_t(7))
	*(*Size_t)(unsafe.Pointer(ctn + 8)) = uint64(0)
	goto obj_key_begin
	goto __3
__2:
	(*Yyjson_val)(unsafe.Pointer(ctn)).Tag = Uint64_t(Uint8_t(6))
	*(*Size_t)(unsafe.Pointer(ctn + 8)) = uint64(0)
	goto arr_val_begin
__3:
	;

arr_begin:
	// save current container
	(*Yyjson_val)(unsafe.Pointer(ctn)).Tag = (U64(ctn_len)+uint64(1))<<int32(Uint8_t(8)) | (*Yyjson_val)(unsafe.Pointer(ctn)).Tag&Uint64_t(Uint8_t(0xFF))

	// create a new array value, save parent container offset
__4:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __7
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __8
	}
	goto fail_alloc
__8:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __9
	}
	goto fail_alloc
__9:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__7:
	;
	goto __5
__5:
	if 0 != 0 {
		goto __4
	}
	goto __6
__6:
	;
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(Uint8_t(6))
	*(*Size_t)(unsafe.Pointer(val + 8)) = Usize((int64(val) - int64(ctn)) / 1)

	// push the new array value as current container
	ctn = val
	ctn_len = uint64(0)

arr_val_begin:
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '{') {
		goto __10
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto obj_begin
__10:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '[') {
		goto __11
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto arr_begin
__11:
	;
	if !(Char_is_number(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __12
	}
__13:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __16
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __17
	}
	goto fail_alloc
__17:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __18
	}
	goto fail_alloc
__18:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__16:
	;
	goto __14
__14:
	if 0 != 0 {
		goto __13
	}
	goto __15
__15:
	;
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_number(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, flg, val, bp+8) != 0)), int64(1)) != 0) {
		goto __19
	}
	goto arr_val_end
__19:
	;
	goto fail_number
__12:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '"') {
		goto __20
	}
__21:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __24
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __25
	}
	goto fail_alloc
__25:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __26
	}
	goto fail_alloc
__26:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__24:
	;
	goto __22
__22:
	if 0 != 0 {
		goto __21
	}
	goto __23
__23:
	;
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_string(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val, bp+8) != 0)), int64(1)) != 0) {
		goto __27
	}
	goto arr_val_end
__27:
	;
	goto fail_string
__20:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 't') {
		goto __28
	}
__29:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __32
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __33
	}
	goto fail_alloc
__33:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __34
	}
	goto fail_alloc
__34:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__32:
	;
	goto __30
__30:
	if 0 != 0 {
		goto __29
	}
	goto __31
__31:
	;
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_true(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0)), int64(1)) != 0) {
		goto __35
	}
	goto arr_val_end
__35:
	;
	goto fail_literal
__28:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'f') {
		goto __36
	}
__37:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __40
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __41
	}
	goto fail_alloc
__41:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __42
	}
	goto fail_alloc
__42:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__40:
	;
	goto __38
__38:
	if 0 != 0 {
		goto __37
	}
	goto __39
__39:
	;
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_false(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0)), int64(1)) != 0) {
		goto __43
	}
	goto arr_val_end
__43:
	;
	goto fail_literal
__36:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'n') {
		goto __44
	}
__45:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __48
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __49
	}
	goto fail_alloc
__49:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __50
	}
	goto fail_alloc
__50:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__48:
	;
	goto __46
__46:
	if 0 != 0 {
		goto __45
	}
	goto __47
__47:
	;
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_null(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0)), int64(1)) != 0) {
		goto __51
	}
	goto arr_val_end
__51:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_INF_AND_NAN != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __52
	}
	if !(Read_nan(tls, uint8(False), *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0) {
		goto __53
	}
	goto arr_val_end
__53:
	;
__52:
	;
	goto fail_literal
__44:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == ']') {
		goto __54
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctn_len == uint64(0))), int64(1)) != 0) {
		goto __55
	}
	goto arr_end
__55:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_TRAILING_COMMAS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __56
	}
	goto arr_end
__56:
	;
	goto fail_trailing_comma
__54:
	;
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __57
	}
__58:
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 1)))) != 0) {
		goto __59
	}
	goto __58
__59:
	;
	goto arr_val_begin
__57:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_INF_AND_NAN != Yyjson_read_flag(0))), int64(0)) != 0 && (int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'i' || int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'I' || int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'N')) {
		goto __60
	}
__61:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __64
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __65
	}
	goto fail_alloc
__65:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __66
	}
	goto fail_alloc
__66:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__64:
	;
	goto __62
__62:
	if 0 != 0 {
		goto __61
	}
	goto __63
__63:
	;
	ctn_len++
	if !(Read_inf_or_nan(tls, uint8(False), *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0) {
		goto __67
	}
	goto arr_val_end
__67:
	;
	goto fail_character
__60:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __68
	}
	if !(skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp)), bp) != 0) {
		goto __69
	}
	goto arr_val_begin
__69:
	;
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+70) != 0) {
		goto __70
	}
	goto fail_comment
__70:
	;
__68:
	;
	goto fail_character

arr_val_end:
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == ',') {
		goto __71
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto arr_val_begin
__71:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == ']') {
		goto __72
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto arr_end
__72:
	;
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __73
	}
__74:
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 1)))) != 0) {
		goto __75
	}
	goto __74
__75:
	;
	goto arr_val_end
__73:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __76
	}
	if !(skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp)), bp) != 0) {
		goto __77
	}
	goto arr_val_end
__77:
	;
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+70) != 0) {
		goto __78
	}
	goto fail_comment
__78:
	;
__76:
	;
	goto fail_character

arr_end:
	// get parent container
	ctn_parent = ctn - uintptr(*(*Size_t)(unsafe.Pointer(ctn + 8)))

	// save the next sibling value offset
	*(*Size_t)(unsafe.Pointer(ctn + 8)) = Usize((int64(val)-int64(ctn))/1) + Usize(unsafe.Sizeof(Yyjson_val{}))
	(*Yyjson_val)(unsafe.Pointer(ctn)).Tag = Uint64_t(ctn_len<<int32(Uint8_t(8)) | Usize(Uint8_t(6)))
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctn == ctn_parent)), int64(0)) != 0) {
		goto __79
	}
	goto doc_end
__79:
	;

	// pop parent as current container
	ctn = ctn_parent
	ctn_len = Usize((*Yyjson_val)(unsafe.Pointer(ctn)).Tag >> int32(Uint8_t(8)))
	if !((*Yyjson_val)(unsafe.Pointer(ctn)).Tag&Uint64_t(Uint8_t(0x07)) == Uint64_t(Uint8_t(7))) {
		goto __80
	}
	goto obj_val_end
	goto __81
__80:
	goto arr_val_end
__81:
	;

obj_begin:
	// push container
	(*Yyjson_val)(unsafe.Pointer(ctn)).Tag = (U64(ctn_len)+uint64(1))<<int32(Uint8_t(8)) | (*Yyjson_val)(unsafe.Pointer(ctn)).Tag&Uint64_t(Uint8_t(0xFF))
__82:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __85
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __86
	}
	goto fail_alloc
__86:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __87
	}
	goto fail_alloc
__87:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__85:
	;
	goto __83
__83:
	if 0 != 0 {
		goto __82
	}
	goto __84
__84:
	;
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(Uint8_t(7))
	// offset to the parent
	*(*Size_t)(unsafe.Pointer(val + 8)) = Usize((int64(val) - int64(ctn)) / 1)
	ctn = val
	ctn_len = uint64(0)

obj_key_begin:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '"')), int64(1)) != 0) {
		goto __88
	}
__89:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __92
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __93
	}
	goto fail_alloc
__93:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __94
	}
	goto fail_alloc
__94:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__92:
	;
	goto __90
__90:
	if 0 != 0 {
		goto __89
	}
	goto __91
__91:
	;
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_string(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val, bp+8) != 0)), int64(1)) != 0) {
		goto __95
	}
	goto obj_key_end
__95:
	;
	goto fail_string
__88:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '}')), int64(1)) != 0) {
		goto __96
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctn_len == uint64(0))), int64(1)) != 0) {
		goto __97
	}
	goto obj_end
__97:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_TRAILING_COMMAS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __98
	}
	goto obj_end
__98:
	;
	goto fail_trailing_comma
__96:
	;
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __99
	}
__100:
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 1)))) != 0) {
		goto __101
	}
	goto __100
__101:
	;
	goto obj_key_begin
__99:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __102
	}
	if !(skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp)), bp) != 0) {
		goto __103
	}
	goto obj_key_begin
__103:
	;
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+70) != 0) {
		goto __104
	}
	goto fail_comment
__104:
	;
__102:
	;
	goto fail_character

obj_key_end:
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == ':') {
		goto __105
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto obj_val_begin
__105:
	;
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __106
	}
__107:
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 1)))) != 0) {
		goto __108
	}
	goto __107
__108:
	;
	goto obj_key_end
__106:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __109
	}
	if !(skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp)), bp) != 0) {
		goto __110
	}
	goto obj_key_end
__110:
	;
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+70) != 0) {
		goto __111
	}
	goto fail_comment
__111:
	;
__109:
	;
	goto fail_character

obj_val_begin:
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '"') {
		goto __112
	}
	val += 16
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_string(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val, bp+8) != 0)), int64(1)) != 0) {
		goto __113
	}
	goto obj_val_end
__113:
	;
	goto fail_string
__112:
	;
	if !(Char_is_number(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __114
	}
	val += 16
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_number(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, flg, val, bp+8) != 0)), int64(1)) != 0) {
		goto __115
	}
	goto obj_val_end
__115:
	;
	goto fail_number
__114:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '{') {
		goto __116
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto obj_begin
__116:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '[') {
		goto __117
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto arr_begin
__117:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 't') {
		goto __118
	}
	val += 16
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_true(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0)), int64(1)) != 0) {
		goto __119
	}
	goto obj_val_end
__119:
	;
	goto fail_literal
__118:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'f') {
		goto __120
	}
	val += 16
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_false(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0)), int64(1)) != 0) {
		goto __121
	}
	goto obj_val_end
__121:
	;
	goto fail_literal
__120:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'n') {
		goto __122
	}
	val += 16
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_null(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0)), int64(1)) != 0) {
		goto __123
	}
	goto obj_val_end
__123:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_INF_AND_NAN != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __124
	}
	if !(Read_nan(tls, uint8(False), *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0) {
		goto __125
	}
	goto obj_val_end
__125:
	;
__124:
	;
	goto fail_literal
__122:
	;
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __126
	}
__127:
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 1)))) != 0) {
		goto __128
	}
	goto __127
__128:
	;
	goto obj_val_begin
__126:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_INF_AND_NAN != Yyjson_read_flag(0))), int64(0)) != 0 && (int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'i' || int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'I' || int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'N')) {
		goto __129
	}
	val += 16
	ctn_len++
	if !(Read_inf_or_nan(tls, uint8(False), *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0) {
		goto __130
	}
	goto obj_val_end
__130:
	;
	goto fail_character
__129:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __131
	}
	if !(skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp)), bp) != 0) {
		goto __132
	}
	goto obj_val_begin
__132:
	;
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+70) != 0) {
		goto __133
	}
	goto fail_comment
__133:
	;
__131:
	;
	goto fail_character

obj_val_end:
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == ',')), int64(1)) != 0) {
		goto __134
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto obj_key_begin
__134:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '}')), int64(1)) != 0) {
		goto __135
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto obj_end
__135:
	;
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __136
	}
__137:
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 1)))) != 0) {
		goto __138
	}
	goto __137
__138:
	;
	goto obj_val_end
__136:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __139
	}
	if !(skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp)), bp) != 0) {
		goto __140
	}
	goto obj_val_end
__140:
	;
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+70) != 0) {
		goto __141
	}
	goto fail_comment
__141:
	;
__139:
	;
	goto fail_character

obj_end:
	// pop container
	ctn_parent = ctn - uintptr(*(*Size_t)(unsafe.Pointer(ctn + 8)))
	// point to the next value
	*(*Size_t)(unsafe.Pointer(ctn + 8)) = Usize((int64(val)-int64(ctn))/1) + Usize(unsafe.Sizeof(Yyjson_val{}))
	(*Yyjson_val)(unsafe.Pointer(ctn)).Tag = Uint64_t(ctn_len<<(int32(Uint8_t(8))-1) | Usize(Uint8_t(7)))
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctn == ctn_parent)), int64(0)) != 0) {
		goto __142
	}
	goto doc_end
__142:
	;
	ctn = ctn_parent
	ctn_len = Usize((*Yyjson_val)(unsafe.Pointer(ctn)).Tag >> int32(Uint8_t(8)))
	if !((*Yyjson_val)(unsafe.Pointer(ctn)).Tag&Uint64_t(Uint8_t(0x07)) == Uint64_t(Uint8_t(7))) {
		goto __143
	}
	goto obj_val_end
	goto __144
__143:
	goto arr_val_end
__144:
	;

doc_end:

	// check invalid contents after json document
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*uintptr)(unsafe.Pointer(bp)) < end)), int64(0)) != 0 && !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_STOP_WHEN_DONE != Yyjson_read_flag(0))), int64(0)) != 0)) {
		goto __145
	}
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __146
	}
	skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp /* cur */)), bp)
	goto __147
__146:
__148:
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __149
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto __148
__149:
	;
__147:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*uintptr)(unsafe.Pointer(bp)) < end)), int64(0)) != 0) {
		goto __150
	}
	goto fail_garbage
__150:
	;
__145:
	;

	doc = val_hdr
	(*Yyjson_doc)(unsafe.Pointer(doc)).Root = val_hdr + uintptr(hdr_len)*16
	(*Yyjson_doc)(unsafe.Pointer(doc)).Alc = alc
	(*Yyjson_doc)(unsafe.Pointer(doc)).Dat_read = Usize((int64(*(*uintptr)(unsafe.Pointer(bp))) - int64(hdr)) / 1)
	(*Yyjson_doc)(unsafe.Pointer(doc)).Val_read = Usize((int64(val)-int64((*Yyjson_doc)(unsafe.Pointer(doc)).Root))/16 + int64(1))
	(*Yyjson_doc)(unsafe.Pointer(doc)).Str_pool = func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_INSITU != Yyjson_read_flag(0))), int64(0)) != 0 {
			return uintptr(0)
		}
		return hdr
	}()
	return doc

fail_string:
__151:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __154
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __155
__154:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_INVALID_STRING
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = *(*uintptr)(unsafe.Pointer(bp + 8 /* msg */))
__155:
	;
	if !(val_hdr != 0) {
		goto __156
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__156:
	;
	return uintptr(0)
	goto __152
__152:
	if 0 != 0 {
		goto __151
	}
	goto __153
__153:
	;
fail_number:
__157:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __160
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __161
__160:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_INVALID_NUMBER
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = *(*uintptr)(unsafe.Pointer(bp + 8 /* msg */))
__161:
	;
	if !(val_hdr != 0) {
		goto __162
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__162:
	;
	return uintptr(0)
	goto __158
__158:
	if 0 != 0 {
		goto __157
	}
	goto __159
__159:
	;
fail_alloc:
__163:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __166
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __167
__166:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_MEMORY_ALLOCATION
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 514 /* "memory allocatio..." */
__167:
	;
	if !(val_hdr != 0) {
		goto __168
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__168:
	;
	return uintptr(0)
	goto __164
__164:
	if 0 != 0 {
		goto __163
	}
	goto __165
__165:
	;
fail_trailing_comma:
__169:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __172
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __173
__172:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_JSON_STRUCTURE
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 637 /* "trailing comma i..." */
__173:
	;
	if !(val_hdr != 0) {
		goto __174
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__174:
	;
	return uintptr(0)
	goto __170
__170:
	if 0 != 0 {
		goto __169
	}
	goto __171
__171:
	;
fail_literal:
__175:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __178
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __179
__178:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_LITERAL
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 539 /* "invalid literal" */
__179:
	;
	if !(val_hdr != 0) {
		goto __180
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__180:
	;
	return uintptr(0)
	goto __176
__176:
	if 0 != 0 {
		goto __175
	}
	goto __177
__177:
	;
fail_comment:
__181:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __184
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __185
__184:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_INVALID_COMMENT
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 555 /* "unclosed multili..." */
__185:
	;
	if !(val_hdr != 0) {
		goto __186
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__186:
	;
	return uintptr(0)
	goto __182
__182:
	if 0 != 0 {
		goto __181
	}
	goto __183
__183:
	;
fail_character:
__187:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __190
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __191
__190:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_CHARACTER
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 582 /* "unexpected chara..." */
__191:
	;
	if !(val_hdr != 0) {
		goto __192
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__192:
	;
	return uintptr(0)
	goto __188
__188:
	if 0 != 0 {
		goto __187
	}
	goto __189
__189:
	;
fail_garbage:
__193:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __196
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __197
__196:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_CONTENT
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 603 /* "unexpected conte..." */
__197:
	;
	if !(val_hdr != 0) {
		goto __198
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__198:
	;
	return uintptr(0)
	goto __194
__194:
	if 0 != 0 {
		goto __193
	}
	goto __195
__195:
	;
	return uintptr(0)

}

//* Read JSON document (accept all style, but optimized for pretty).
func Read_root_pretty(tls *libc.TLS, hdr uintptr, cur uintptr, end uintptr, alc Yyjson_alc, flg Yyjson_read_flag, err uintptr) uintptr { /* yyjson.c:4784:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*uintptr)(unsafe.Pointer(bp)) = cur

	var dat_len Usize      // data length in bytes, hint for allocator
	var hdr_len Usize      // value count used by yyjson_doc
	var alc_len Usize      // value count allocated
	var alc_max Usize      // maximum value count for allocator
	var ctn_len Usize      // the number of elements in current container
	var val_hdr uintptr    // the head of allocated values
	var val_end uintptr    // the end of allocated values
	var val_tmp uintptr    // temporary pointer for realloc
	var val uintptr        // current JSON value
	var ctn uintptr        // current container
	var ctn_parent uintptr // parent of current container
	var doc uintptr        // the JSON document, equals to val_hdr
	// var msg uintptr at bp+8, 8
	// error message

	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_STOP_WHEN_DONE != Yyjson_read_flag(0))), int64(0)) != 0 {
		dat_len = uint64(256)
	} else {
		dat_len = Usize((int64(end) - int64(*(*uintptr)(unsafe.Pointer(bp)))) / 1)
	}
	hdr_len = uint64(unsafe.Sizeof(Yyjson_doc{})) / uint64(unsafe.Sizeof(Yyjson_val{}))
	hdr_len = hdr_len + uint64(libc.Bool32(uint64(unsafe.Sizeof(Yyjson_doc{}))%uint64(unsafe.Sizeof(Yyjson_val{})) > uint64(0)))
	alc_max = libc.CplUint64(uint64(0)) / Usize(unsafe.Sizeof(Yyjson_val{}))
	alc_len = hdr_len + dat_len/uint64(YYJSON_READER_ESTIMATED_PRETTY_RATIO) + uint64(4)
	alc_len = func() uint64 {
		if alc_len < alc_max {
			return alc_len
		}
		return alc_max
	}()

	val_hdr = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Malloc})).f(tls, alc.Ctx, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(val_hdr != 0)), int64(0)) != 0) {
		goto __1
	}
	goto fail_alloc
__1:
	;
	val_end = val_hdr + uintptr(alc_len-uint64(2))*16 // padding for key-value pair reading
	val = val_hdr + uintptr(hdr_len)*16
	ctn = val
	ctn_len = uint64(0)

	if !(int32(*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 1)))) == '{') {
		goto __2
	}
	(*Yyjson_val)(unsafe.Pointer(ctn)).Tag = Uint64_t(Uint8_t(7))
	*(*Size_t)(unsafe.Pointer(ctn + 8)) = uint64(0)
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\n') {
		goto __4
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
__4:
	;
	goto obj_key_begin
	goto __3
__2:
	(*Yyjson_val)(unsafe.Pointer(ctn)).Tag = Uint64_t(Uint8_t(6))
	*(*Size_t)(unsafe.Pointer(ctn + 8)) = uint64(0)
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\n') {
		goto __5
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
__5:
	;
	goto arr_val_begin
__3:
	;

arr_begin:
	// save current container
	(*Yyjson_val)(unsafe.Pointer(ctn)).Tag = (U64(ctn_len)+uint64(1))<<int32(Uint8_t(8)) | (*Yyjson_val)(unsafe.Pointer(ctn)).Tag&Uint64_t(Uint8_t(0xFF))

	// create a new array value, save parent container offset
__6:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __9
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __10
	}
	goto fail_alloc
__10:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __11
	}
	goto fail_alloc
__11:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__9:
	;
	goto __7
__7:
	if 0 != 0 {
		goto __6
	}
	goto __8
__8:
	;
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(Uint8_t(6))
	*(*Size_t)(unsafe.Pointer(val + 8)) = Usize((int64(val) - int64(ctn)) / 1)

	// push the new array value as current container
	ctn = val
	ctn_len = uint64(0)
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\n') {
		goto __12
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
__12:
	;

arr_val_begin:
__13:
	if !(1 != 0) {
		goto __14
	}
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __15
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __16
__15:
	goto __14
__16:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __17
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __18
__17:
	goto __14
__18:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __19
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __20
__19:
	goto __14
__20:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __21
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __22
__21:
	goto __14
__22:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __23
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __24
__23:
	goto __14
__24:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __25
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __26
__25:
	goto __14
__26:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __27
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __28
__27:
	goto __14
__28:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __29
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __30
__29:
	goto __14
__30:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __31
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __32
__31:
	goto __14
__32:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __33
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __34
__33:
	goto __14
__34:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __35
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __36
__35:
	goto __14
__36:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __37
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __38
__37:
	goto __14
__38:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __39
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __40
__39:
	goto __14
__40:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __41
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __42
__41:
	goto __14
__42:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __43
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __44
__43:
	goto __14
__44:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __45
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __46
__45:
	goto __14
__46:
	;
	goto __13
__14:
	;

	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '{') {
		goto __47
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto obj_begin
__47:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '[') {
		goto __48
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto arr_begin
__48:
	;
	if !(Char_is_number(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __49
	}
__50:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __53
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __54
	}
	goto fail_alloc
__54:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __55
	}
	goto fail_alloc
__55:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__53:
	;
	goto __51
__51:
	if 0 != 0 {
		goto __50
	}
	goto __52
__52:
	;
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_number(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, flg, val, bp+8) != 0)), int64(1)) != 0) {
		goto __56
	}
	goto arr_val_end
__56:
	;
	goto fail_number
__49:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '"') {
		goto __57
	}
__58:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __61
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __62
	}
	goto fail_alloc
__62:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __63
	}
	goto fail_alloc
__63:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__61:
	;
	goto __59
__59:
	if 0 != 0 {
		goto __58
	}
	goto __60
__60:
	;
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_string(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val, bp+8) != 0)), int64(1)) != 0) {
		goto __64
	}
	goto arr_val_end
__64:
	;
	goto fail_string
__57:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 't') {
		goto __65
	}
__66:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __69
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __70
	}
	goto fail_alloc
__70:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __71
	}
	goto fail_alloc
__71:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__69:
	;
	goto __67
__67:
	if 0 != 0 {
		goto __66
	}
	goto __68
__68:
	;
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_true(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0)), int64(1)) != 0) {
		goto __72
	}
	goto arr_val_end
__72:
	;
	goto fail_literal
__65:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'f') {
		goto __73
	}
__74:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __77
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __78
	}
	goto fail_alloc
__78:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __79
	}
	goto fail_alloc
__79:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__77:
	;
	goto __75
__75:
	if 0 != 0 {
		goto __74
	}
	goto __76
__76:
	;
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_false(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0)), int64(1)) != 0) {
		goto __80
	}
	goto arr_val_end
__80:
	;
	goto fail_literal
__73:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'n') {
		goto __81
	}
__82:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __85
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __86
	}
	goto fail_alloc
__86:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __87
	}
	goto fail_alloc
__87:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__85:
	;
	goto __83
__83:
	if 0 != 0 {
		goto __82
	}
	goto __84
__84:
	;
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_null(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0)), int64(1)) != 0) {
		goto __88
	}
	goto arr_val_end
__88:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_INF_AND_NAN != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __89
	}
	if !(Read_nan(tls, uint8(False), *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0) {
		goto __90
	}
	goto arr_val_end
__90:
	;
__89:
	;
	goto fail_literal
__81:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == ']') {
		goto __91
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctn_len == uint64(0))), int64(1)) != 0) {
		goto __92
	}
	goto arr_end
__92:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_TRAILING_COMMAS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __93
	}
	goto arr_end
__93:
	;
	goto fail_trailing_comma
__91:
	;
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __94
	}
__95:
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 1)))) != 0) {
		goto __96
	}
	goto __95
__96:
	;
	goto arr_val_begin
__94:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_INF_AND_NAN != Yyjson_read_flag(0))), int64(0)) != 0 && (int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'i' || int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'I' || int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'N')) {
		goto __97
	}
__98:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __101
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __102
	}
	goto fail_alloc
__102:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __103
	}
	goto fail_alloc
__103:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__101:
	;
	goto __99
__99:
	if 0 != 0 {
		goto __98
	}
	goto __100
__100:
	;
	ctn_len++
	if !(Read_inf_or_nan(tls, uint8(False), *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0) {
		goto __104
	}
	goto arr_val_end
__104:
	;
	goto fail_character
__97:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __105
	}
	if !(skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp)), bp) != 0) {
		goto __106
	}
	goto arr_val_begin
__106:
	;
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+70) != 0) {
		goto __107
	}
	goto fail_comment
__107:
	;
__105:
	;
	goto fail_character

arr_val_end:
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+670) != 0) {
		goto __108
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto arr_val_begin
__108:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == ',') {
		goto __109
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto arr_val_begin
__109:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == ']') {
		goto __110
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto arr_end
__110:
	;
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __111
	}
__112:
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 1)))) != 0) {
		goto __113
	}
	goto __112
__113:
	;
	goto arr_val_end
__111:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __114
	}
	if !(skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp)), bp) != 0) {
		goto __115
	}
	goto arr_val_end
__115:
	;
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+70) != 0) {
		goto __116
	}
	goto fail_comment
__116:
	;
__114:
	;
	goto fail_character

arr_end:
	// get parent container
	ctn_parent = ctn - uintptr(*(*Size_t)(unsafe.Pointer(ctn + 8)))

	// save the next sibling value offset
	*(*Size_t)(unsafe.Pointer(ctn + 8)) = Usize((int64(val)-int64(ctn))/1) + Usize(unsafe.Sizeof(Yyjson_val{}))
	(*Yyjson_val)(unsafe.Pointer(ctn)).Tag = Uint64_t(ctn_len<<int32(Uint8_t(8)) | Usize(Uint8_t(6)))
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctn == ctn_parent)), int64(0)) != 0) {
		goto __117
	}
	goto doc_end
__117:
	;

	// pop parent as current container
	ctn = ctn_parent
	ctn_len = Usize((*Yyjson_val)(unsafe.Pointer(ctn)).Tag >> int32(Uint8_t(8)))
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\n') {
		goto __118
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
__118:
	;
	if !((*Yyjson_val)(unsafe.Pointer(ctn)).Tag&Uint64_t(Uint8_t(0x07)) == Uint64_t(Uint8_t(7))) {
		goto __119
	}
	goto obj_val_end
	goto __120
__119:
	goto arr_val_end
__120:
	;

obj_begin:
	// push container
	(*Yyjson_val)(unsafe.Pointer(ctn)).Tag = (U64(ctn_len)+uint64(1))<<int32(Uint8_t(8)) | (*Yyjson_val)(unsafe.Pointer(ctn)).Tag&Uint64_t(Uint8_t(0xFF))
__121:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __124
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __125
	}
	goto fail_alloc
__125:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __126
	}
	goto fail_alloc
__126:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__124:
	;
	goto __122
__122:
	if 0 != 0 {
		goto __121
	}
	goto __123
__123:
	;
	(*Yyjson_val)(unsafe.Pointer(val)).Tag = Uint64_t(Uint8_t(7))
	// offset to the parent
	*(*Size_t)(unsafe.Pointer(val + 8)) = Usize((int64(val) - int64(ctn)) / 1)
	ctn = val
	ctn_len = uint64(0)
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\n') {
		goto __127
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
__127:
	;

obj_key_begin:
__128:
	if !(1 != 0) {
		goto __129
	}
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __130
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __131
__130:
	goto __129
__131:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __132
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __133
__132:
	goto __129
__133:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __134
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __135
__134:
	goto __129
__135:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __136
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __137
__136:
	goto __129
__137:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __138
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __139
__138:
	goto __129
__139:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __140
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __141
__140:
	goto __129
__141:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __142
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __143
__142:
	goto __129
__143:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __144
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __145
__144:
	goto __129
__145:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __146
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __147
__146:
	goto __129
__147:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __148
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __149
__148:
	goto __129
__149:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __150
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __151
__150:
	goto __129
__151:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __152
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __153
__152:
	goto __129
__153:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __154
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __155
__154:
	goto __129
__155:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __156
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __157
__156:
	goto __129
__157:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __158
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __159
__158:
	goto __129
__159:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+667) != 0)), int64(1)) != 0) {
		goto __160
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto __161
__160:
	goto __129
__161:
	;
	goto __128
__129:
	;

	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '"')), int64(1)) != 0) {
		goto __162
	}
__163:
	val += 16
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(val >= val_end)), int64(0)) != 0) {
		goto __166
	}
	alc_len = alc_len + alc_len/uint64(2)
	if !(alc_len >= alc_max) {
		goto __167
	}
	goto fail_alloc
__167:
	;
	val_tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, val_hdr, alc_len*Usize(unsafe.Sizeof(Yyjson_val{})))
	if !!(val_tmp != 0) {
		goto __168
	}
	goto fail_alloc
__168:
	;
	val = val_tmp + uintptr(Size_t((int64(val)-int64(val_hdr))/16))*16
	ctn = val_tmp + uintptr(Size_t((int64(ctn)-int64(val_hdr))/16))*16
	val_hdr = val_tmp
	val_end = val_tmp + uintptr(alc_len-uint64(2))*16
__166:
	;
	goto __164
__164:
	if 0 != 0 {
		goto __163
	}
	goto __165
__165:
	;
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_string(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val, bp+8) != 0)), int64(1)) != 0) {
		goto __169
	}
	goto obj_key_end
__169:
	;
	goto fail_string
__162:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '}')), int64(1)) != 0) {
		goto __170
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctn_len == uint64(0))), int64(1)) != 0) {
		goto __171
	}
	goto obj_end
__171:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_TRAILING_COMMAS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __172
	}
	goto obj_end
__172:
	;
	goto fail_trailing_comma
__170:
	;
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __173
	}
__174:
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 1)))) != 0) {
		goto __175
	}
	goto __174
__175:
	;
	goto obj_key_begin
__173:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __176
	}
	if !(skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp)), bp) != 0) {
		goto __177
	}
	goto obj_key_begin
__177:
	;
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+70) != 0) {
		goto __178
	}
	goto fail_comment
__178:
	;
__176:
	;
	goto fail_character

obj_key_end:
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+673) != 0) {
		goto __179
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto obj_val_begin
__179:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == ':') {
		goto __180
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto obj_val_begin
__180:
	;
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __181
	}
__182:
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 1)))) != 0) {
		goto __183
	}
	goto __182
__183:
	;
	goto obj_key_end
__181:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __184
	}
	if !(skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp)), bp) != 0) {
		goto __185
	}
	goto obj_key_end
__185:
	;
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+70) != 0) {
		goto __186
	}
	goto fail_comment
__186:
	;
__184:
	;
	goto fail_character

obj_val_begin:
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '"') {
		goto __187
	}
	val += 16
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_string(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val, bp+8) != 0)), int64(1)) != 0) {
		goto __188
	}
	goto obj_val_end
__188:
	;
	goto fail_string
__187:
	;
	if !(Char_is_number(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __189
	}
	val += 16
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_number(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, flg, val, bp+8) != 0)), int64(1)) != 0) {
		goto __190
	}
	goto obj_val_end
__190:
	;
	goto fail_number
__189:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '{') {
		goto __191
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto obj_begin
__191:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '[') {
		goto __192
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto arr_begin
__192:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 't') {
		goto __193
	}
	val += 16
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_true(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0)), int64(1)) != 0) {
		goto __194
	}
	goto obj_val_end
__194:
	;
	goto fail_literal
__193:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'f') {
		goto __195
	}
	val += 16
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_false(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0)), int64(1)) != 0) {
		goto __196
	}
	goto obj_val_end
__196:
	;
	goto fail_literal
__195:
	;
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'n') {
		goto __197
	}
	val += 16
	ctn_len++
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(Read_null(tls, *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0)), int64(1)) != 0) {
		goto __198
	}
	goto obj_val_end
__198:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_INF_AND_NAN != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __199
	}
	if !(Read_nan(tls, uint8(False), *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0) {
		goto __200
	}
	goto obj_val_end
__200:
	;
__199:
	;
	goto fail_literal
__197:
	;
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __201
	}
__202:
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 1)))) != 0) {
		goto __203
	}
	goto __202
__203:
	;
	goto obj_val_begin
__201:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_INF_AND_NAN != Yyjson_read_flag(0))), int64(0)) != 0 && (int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'i' || int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'I' || int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == 'N')) {
		goto __204
	}
	val += 16
	ctn_len++
	if !(Read_inf_or_nan(tls, uint8(False), *(*uintptr)(unsafe.Pointer(bp)), bp, val) != 0) {
		goto __205
	}
	goto obj_val_end
__205:
	;
	goto fail_character
__204:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __206
	}
	if !(skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp)), bp) != 0) {
		goto __207
	}
	goto obj_val_begin
__207:
	;
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+70) != 0) {
		goto __208
	}
	goto fail_comment
__208:
	;
__206:
	;
	goto fail_character

obj_val_end:
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+670) != 0) {
		goto __209
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */)) += uintptr(2)
	goto obj_key_begin
__209:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == ',')), int64(1)) != 0) {
		goto __210
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto obj_key_begin
__210:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '}')), int64(1)) != 0) {
		goto __211
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto obj_end
__211:
	;
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __212
	}
__213:
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp)), 1)))) != 0) {
		goto __214
	}
	goto __213
__214:
	;
	goto obj_val_end
__212:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __215
	}
	if !(skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp)), bp) != 0) {
		goto __216
	}
	goto obj_val_end
__216:
	;
	if !(Byte_match_2(tls, *(*uintptr)(unsafe.Pointer(bp)), ts+70) != 0) {
		goto __217
	}
	goto fail_comment
__217:
	;
__215:
	;
	goto fail_character

obj_end:
	// pop container
	ctn_parent = ctn - uintptr(*(*Size_t)(unsafe.Pointer(ctn + 8)))
	// point to the next value
	*(*Size_t)(unsafe.Pointer(ctn + 8)) = Usize((int64(val)-int64(ctn))/1) + Usize(unsafe.Sizeof(Yyjson_val{}))
	(*Yyjson_val)(unsafe.Pointer(ctn)).Tag = Uint64_t(ctn_len<<(int32(Uint8_t(8))-1) | Usize(Uint8_t(7)))
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctn == ctn_parent)), int64(0)) != 0) {
		goto __218
	}
	goto doc_end
__218:
	;
	ctn = ctn_parent
	ctn_len = Usize((*Yyjson_val)(unsafe.Pointer(ctn)).Tag >> int32(Uint8_t(8)))
	if !(int32(*(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) == '\n') {
		goto __219
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
__219:
	;
	if !((*Yyjson_val)(unsafe.Pointer(ctn)).Tag&Uint64_t(Uint8_t(0x07)) == Uint64_t(Uint8_t(7))) {
		goto __220
	}
	goto obj_val_end
	goto __221
__220:
	goto arr_val_end
__221:
	;

doc_end:

	// check invalid contents after json document
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*uintptr)(unsafe.Pointer(bp)) < end)), int64(0)) != 0 && !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_STOP_WHEN_DONE != Yyjson_read_flag(0))), int64(0)) != 0)) {
		goto __222
	}
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0) {
		goto __223
	}
	skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp /* cur */)), bp)
	goto __224
__223:
__225:
	if !(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp))))) != 0) {
		goto __226
	}
	*(*uintptr)(unsafe.Pointer(bp /* cur */))++
	goto __225
__226:
	;
__224:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*uintptr)(unsafe.Pointer(bp)) < end)), int64(0)) != 0) {
		goto __227
	}
	goto fail_garbage
__227:
	;
__222:
	;

	doc = val_hdr
	(*Yyjson_doc)(unsafe.Pointer(doc)).Root = val_hdr + uintptr(hdr_len)*16
	(*Yyjson_doc)(unsafe.Pointer(doc)).Alc = alc
	(*Yyjson_doc)(unsafe.Pointer(doc)).Dat_read = Usize((int64(*(*uintptr)(unsafe.Pointer(bp))) - int64(hdr)) / 1)
	(*Yyjson_doc)(unsafe.Pointer(doc)).Val_read = Usize((int64(val)-int64(val_hdr))/16) - hdr_len + uint64(1)
	(*Yyjson_doc)(unsafe.Pointer(doc)).Str_pool = func() uintptr {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_INSITU != Yyjson_read_flag(0))), int64(0)) != 0 {
			return uintptr(0)
		}
		return hdr
	}()
	return doc

fail_string:
__228:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __231
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __232
__231:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_INVALID_STRING
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = *(*uintptr)(unsafe.Pointer(bp + 8 /* msg */))
__232:
	;
	if !(val_hdr != 0) {
		goto __233
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__233:
	;
	return uintptr(0)
	goto __229
__229:
	if 0 != 0 {
		goto __228
	}
	goto __230
__230:
	;
fail_number:
__234:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __237
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __238
__237:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_INVALID_NUMBER
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = *(*uintptr)(unsafe.Pointer(bp + 8 /* msg */))
__238:
	;
	if !(val_hdr != 0) {
		goto __239
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__239:
	;
	return uintptr(0)
	goto __235
__235:
	if 0 != 0 {
		goto __234
	}
	goto __236
__236:
	;
fail_alloc:
__240:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __243
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __244
__243:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_MEMORY_ALLOCATION
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 514 /* "memory allocatio..." */
__244:
	;
	if !(val_hdr != 0) {
		goto __245
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__245:
	;
	return uintptr(0)
	goto __241
__241:
	if 0 != 0 {
		goto __240
	}
	goto __242
__242:
	;
fail_trailing_comma:
__246:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __249
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __250
__249:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_JSON_STRUCTURE
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 637 /* "trailing comma i..." */
__250:
	;
	if !(val_hdr != 0) {
		goto __251
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__251:
	;
	return uintptr(0)
	goto __247
__247:
	if 0 != 0 {
		goto __246
	}
	goto __248
__248:
	;
fail_literal:
__252:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __255
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __256
__255:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_LITERAL
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 539 /* "invalid literal" */
__256:
	;
	if !(val_hdr != 0) {
		goto __257
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__257:
	;
	return uintptr(0)
	goto __253
__253:
	if 0 != 0 {
		goto __252
	}
	goto __254
__254:
	;
fail_comment:
__258:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __261
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __262
__261:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_INVALID_COMMENT
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 555 /* "unclosed multili..." */
__262:
	;
	if !(val_hdr != 0) {
		goto __263
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__263:
	;
	return uintptr(0)
	goto __259
__259:
	if 0 != 0 {
		goto __258
	}
	goto __260
__260:
	;
fail_character:
__264:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __267
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __268
__267:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_CHARACTER
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 582 /* "unexpected chara..." */
__268:
	;
	if !(val_hdr != 0) {
		goto __269
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__269:
	;
	return uintptr(0)
	goto __265
__265:
	if 0 != 0 {
		goto __264
	}
	goto __266
__266:
	;
fail_garbage:
__270:
	if !(*(*uintptr)(unsafe.Pointer(bp)) >= end) {
		goto __273
	}
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(end) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_END
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 491 /* "unexpected end o..." */
	goto __274
__273:
	(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp /* cur */))) - int64(hdr)) / 1)
	(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_UNEXPECTED_CONTENT
	(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 603 /* "unexpected conte..." */
__274:
	;
	if !(val_hdr != 0) {
		goto __275
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, val_hdr)
__275:
	;
	return uintptr(0)
	goto __271
__271:
	if 0 != 0 {
		goto __270
	}
	goto __272
__272:
	;
	return uintptr(0)

}

// ==============================================================================
// JSON Reader Entrance
//============================================================================

func Yyjson_read_opts(tls *libc.TLS, dat uintptr, len Usize, flg Yyjson_read_flag, alc_ptr uintptr, err uintptr) uintptr { /* yyjson.c:5218:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var dummy_err Yyjson_read_err at bp, 24

	var alc Yyjson_alc
	var doc uintptr
	var hdr uintptr = uintptr(0)
	var end uintptr
	// var cur uintptr at bp+24, 8

	// validate input parameters
	if !(err != 0) {
		err = bp /* &dummy_err */
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(alc_ptr != 0)), int64(1)) != 0 {
		alc = sYYJSON_DEFAULT_ALC
	} else {
		alc = *(*Yyjson_alc)(unsafe.Pointer(alc_ptr))
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(dat != 0)), int64(0)) != 0 {
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = uint64(0)
			(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 676 /* "input data is NU..." */
			(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_INVALID_PARAMETER
			if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_INSITU != Yyjson_read_flag(0))), int64(0)) != 0) && hdr != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
			}
			return uintptr(0)
		}
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(len != 0)), int64(0)) != 0 {
		for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
			(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = uint64(0)
			(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 695 /* "input length is ..." */
			(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_INVALID_PARAMETER
			if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_INSITU != Yyjson_read_flag(0))), int64(0)) != 0) && hdr != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
			}
			return uintptr(0)
		}
	}

	// add 4-byte zero padding for input data if necessary
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_INSITU != Yyjson_read_flag(0))), int64(0)) != 0) {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(len >= libc.CplUint64(uint64(0))-uint64(YYJSON_PADDING_SIZE))), int64(0)) != 0 {
			for __ccgo2 := true; __ccgo2; __ccgo2 = 0 != 0 {
				(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = uint64(0)
				(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 514 /* "memory allocatio..." */
				(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_MEMORY_ALLOCATION
				if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_INSITU != Yyjson_read_flag(0))), int64(0)) != 0) && hdr != 0 {
					(*struct {
						f func(*libc.TLS, uintptr, uintptr)
					})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
				}
				return uintptr(0)
			}
		}
		hdr = (*struct {
			f func(*libc.TLS, uintptr, Size_t) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{alc.Malloc})).f(tls, alc.Ctx, len+uint64(YYJSON_PADDING_SIZE))
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(hdr != 0)), int64(0)) != 0 {
			for __ccgo3 := true; __ccgo3; __ccgo3 = 0 != 0 {
				(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = uint64(0)
				(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 514 /* "memory allocatio..." */
				(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_MEMORY_ALLOCATION
				if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_INSITU != Yyjson_read_flag(0))), int64(0)) != 0) && hdr != 0 {
					(*struct {
						f func(*libc.TLS, uintptr, uintptr)
					})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
				}
				return uintptr(0)
			}
		}
		end = hdr + uintptr(len)
		*(*uintptr)(unsafe.Pointer(bp + 24 /* cur */)) = hdr
		libc.X__builtin___memcpy_chk(tls, hdr, dat, len, libc.X__builtin_object_size(tls, hdr, 0))
		libc.X__builtin___memset_chk(tls, end, 0, uint64(YYJSON_PADDING_SIZE), libc.X__builtin_object_size(tls, end, 0))
	} else {
		hdr = dat
		end = dat + uintptr(len)
		*(*uintptr)(unsafe.Pointer(bp + 24 /* cur */)) = dat
	}

	// skip empty contents before json document
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Char_is_space_or_comment(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) != 0)), int64(0)) != 0 {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_ALLOW_COMMENTS != Yyjson_read_flag(0))), int64(0)) != 0 {
			if !(skip_spaces_and_comments(tls, *(*uintptr)(unsafe.Pointer(bp + 24)), bp+24) != 0) {
				for __ccgo4 := true; __ccgo4; __ccgo4 = 0 != 0 {
					(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = Usize((int64(*(*uintptr)(unsafe.Pointer(bp + 24))) - int64(hdr)) / 1)
					(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 555 /* "unclosed multili..." */
					(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_INVALID_COMMENT
					if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_INSITU != Yyjson_read_flag(0))), int64(0)) != 0) && hdr != 0 {
						(*struct {
							f func(*libc.TLS, uintptr, uintptr)
						})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
					}
					return uintptr(0)
				}
			}
		} else {
			if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) != 0)), int64(1)) != 0 {
				for Char_is_space(tls, *(*U8)(unsafe.Pointer(libc.PreIncUintptr(&*(*uintptr)(unsafe.Pointer(bp + 24)), 1)))) != 0 {
				}
			}
		}
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*uintptr)(unsafe.Pointer(bp + 24)) >= end)), int64(0)) != 0 {
			for __ccgo5 := true; __ccgo5; __ccgo5 = 0 != 0 {
				(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = uint64(0)
				(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 713 /* "input data is em..." */
				(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_EMPTY_CONTENT
				if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_INSITU != Yyjson_read_flag(0))), int64(0)) != 0) && hdr != 0 {
					(*struct {
						f func(*libc.TLS, uintptr, uintptr)
					})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
				}
				return uintptr(0)
			}
		}
	}

	// read json document
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(Char_is_container(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24))))) != 0)), int64(1)) != 0 {
		if Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 1))) != 0 && Char_is_space(tls, *(*U8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24)) + 2))) != 0 {
			doc = Read_root_pretty(tls, hdr, *(*uintptr)(unsafe.Pointer(bp + 24 /* cur */)), end, alc, flg, err)
		} else {
			doc = Read_root_minify(tls, hdr, *(*uintptr)(unsafe.Pointer(bp + 24 /* cur */)), end, alc, flg, err)
		}
	} else {
		doc = read_root_single(tls, hdr, *(*uintptr)(unsafe.Pointer(bp + 24 /* cur */)), end, alc, flg, err)
	}

	// check result
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(doc != 0)), int64(1)) != 0 {
		libc.X__builtin___memset_chk(tls, err, 0, uint64(unsafe.Sizeof(Yyjson_read_err{})), libc.X__builtin_object_size(tls, err, 0))
	} else {
		// RFC 8259: JSON text MUST be encoded using UTF-8
		if (*Yyjson_read_err)(unsafe.Pointer(err)).Pos == uint64(0) && (*Yyjson_read_err)(unsafe.Pointer(err)).Code != sYYJSON_READ_ERROR_MEMORY_ALLOCATION {
			if int32(*(*U8)(unsafe.Pointer(hdr))) == 0xEF && int32(*(*U8)(unsafe.Pointer(hdr + 1))) == 0xBB && int32(*(*U8)(unsafe.Pointer(hdr + 2))) == 0xBF {
				(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 733 /* "byte order mark ..." */
			} else if len >= uint64(4) && (int32(*(*U8)(unsafe.Pointer(hdr))) == 0x00 && int32(*(*U8)(unsafe.Pointer(hdr + 1))) == 0x00 && int32(*(*U8)(unsafe.Pointer(hdr + 2))) == 0xFE && int32(*(*U8)(unsafe.Pointer(hdr + 3))) == 0xFF || int32(*(*U8)(unsafe.Pointer(hdr))) == 0xFF && int32(*(*U8)(unsafe.Pointer(hdr + 1))) == 0xFE && int32(*(*U8)(unsafe.Pointer(hdr + 2))) == 0x00 && int32(*(*U8)(unsafe.Pointer(hdr + 3))) == 0x00) {
				(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 772 /* "UTF-32 encoding ..." */
			} else if len >= uint64(2) && (int32(*(*U8)(unsafe.Pointer(hdr))) == 0xFE && int32(*(*U8)(unsafe.Pointer(hdr + 1))) == 0xFF || int32(*(*U8)(unsafe.Pointer(hdr))) == 0xFF && int32(*(*U8)(unsafe.Pointer(hdr + 1))) == 0xFE) {
				(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 805 /* "UTF-16 encoding ..." */
			}
		}
		if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_READ_INSITU != Yyjson_read_flag(0))), int64(0)) != 0) && hdr != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
		}
	}
	return doc

}

func Yyjson_read_file(tls *libc.TLS, path uintptr, flg Yyjson_read_flag, alc_ptr uintptr, err uintptr) uintptr { /* yyjson.c:5340:12: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var dummy_err Yyjson_read_err at bp, 24

	if alc_ptr != 0 {
		*(*Yyjson_alc)(unsafe.Pointer(bp + 24 /* alc */)) = *(*Yyjson_alc)(unsafe.Pointer(alc_ptr))
	} else {
		*(*Yyjson_alc)(unsafe.Pointer(bp + 24 /* alc */)) = sYYJSON_DEFAULT_ALC
	}
	var doc uintptr

	var file uintptr = uintptr(0)
	var file_size int64 = int64(0)
	var buf uintptr = uintptr(0)
	var buf_size Usize = uint64(0)

	// validate input parameters
	if !(err != 0) {
		err = bp /* &dummy_err */
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(path != 0)), int64(0)) != 0 {
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = uint64(0)
			(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 838 /* "input path is NU..." */
			(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_INVALID_PARAMETER
			if file != 0 {
				libc.Xfclose(tls, file)
			}
			if buf != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(bp + 24 /* &alc */)).Free})).f(tls, (*Yyjson_alc)(unsafe.Pointer(bp+24 /* &alc */)).Ctx, buf)
			}
			return uintptr(0)
		}
	}

	// open file
	file = Fopen_readonly(tls, path)
	if file == uintptr(0) {
		for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
			(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = uint64(0)
			(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 857 /* "file opening fai..." */
			(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_FILE_OPEN
			if file != 0 {
				libc.Xfclose(tls, file)
			}
			if buf != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(bp + 24 /* &alc */)).Free})).f(tls, (*Yyjson_alc)(unsafe.Pointer(bp+24 /* &alc */)).Ctx, buf)
			}
			return uintptr(0)
		}
	}

	// get file size
	if libc.Xfseek(tls, file, int64(0), SEEK_END) == 0 {
		file_size = libc.Xftell(tls, file)
		if file_size < int64(0) || file_size+int64(1) < int64(0) {
			file_size = int64(0)
		}
	}
	libc.Xrewind(tls, file)

	// read file
	if file_size > int64(0) {
		// read the entire file in one call
		buf_size = Size_t(file_size) + uint64(YYJSON_PADDING_SIZE)
		buf = (*struct {
			f func(*libc.TLS, uintptr, Size_t) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(bp + 24 /* &alc */)).Malloc})).f(tls, (*Yyjson_alc)(unsafe.Pointer(bp+24 /* &alc */)).Ctx, buf_size)
		if buf == uintptr(0) {
			for __ccgo2 := true; __ccgo2; __ccgo2 = 0 != 0 {
				(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = uint64(0)
				(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 877 /* "fail to alloc me..." */
				(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_MEMORY_ALLOCATION
				if file != 0 {
					libc.Xfclose(tls, file)
				}
				if buf != 0 {
					(*struct {
						f func(*libc.TLS, uintptr, uintptr)
					})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(bp + 24 /* &alc */)).Free})).f(tls, (*Yyjson_alc)(unsafe.Pointer(bp+24 /* &alc */)).Ctx, buf)
				}
				return uintptr(0)
			}
		}
		if Fread_safe(tls, buf, Usize(file_size), file) != Usize(file_size) {
			for __ccgo3 := true; __ccgo3; __ccgo3 = 0 != 0 {
				(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = uint64(0)
				(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 898 /* "file reading fai..." */
				(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_FILE_READ
				if file != 0 {
					libc.Xfclose(tls, file)
				}
				if buf != 0 {
					(*struct {
						f func(*libc.TLS, uintptr, uintptr)
					})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(bp + 24 /* &alc */)).Free})).f(tls, (*Yyjson_alc)(unsafe.Pointer(bp+24 /* &alc */)).Ctx, buf)
				}
				return uintptr(0)
			}
		}
	} else {
		// failed to get file size, read it as a stream
		var chunk_min Usize = uint64(64)
		var chunk_max Usize = uint64(512) * uint64(1024) * uint64(1024)
		var chunk_now Usize = chunk_min
		var read_size Usize
		var tmp uintptr

		buf_size = uint64(YYJSON_PADDING_SIZE)
		for 1 != 0 {
			if buf_size+chunk_now < buf_size { // overflow
				for __ccgo4 := true; __ccgo4; __ccgo4 = 0 != 0 {
					(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = uint64(0)
					(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 877 /* "fail to alloc me..." */
					(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_MEMORY_ALLOCATION
					if file != 0 {
						libc.Xfclose(tls, file)
					}
					if buf != 0 {
						(*struct {
							f func(*libc.TLS, uintptr, uintptr)
						})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(bp + 24 /* &alc */)).Free})).f(tls, (*Yyjson_alc)(unsafe.Pointer(bp+24 /* &alc */)).Ctx, buf)
					}
					return uintptr(0)
				}
			}
			buf_size = buf_size + chunk_now
			if !(buf != 0) {
				buf = (*struct {
					f func(*libc.TLS, uintptr, Size_t) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(bp + 24 /* &alc */)).Malloc})).f(tls, (*Yyjson_alc)(unsafe.Pointer(bp+24 /* &alc */)).Ctx, buf_size)
				if !(buf != 0) {
					for __ccgo5 := true; __ccgo5; __ccgo5 = 0 != 0 {
						(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = uint64(0)
						(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 877 /* "fail to alloc me..." */
						(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_MEMORY_ALLOCATION
						if file != 0 {
							libc.Xfclose(tls, file)
						}
						if buf != 0 {
							(*struct {
								f func(*libc.TLS, uintptr, uintptr)
							})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(bp + 24 /* &alc */)).Free})).f(tls, (*Yyjson_alc)(unsafe.Pointer(bp+24 /* &alc */)).Ctx, buf)
						}
						return uintptr(0)
					}
				}
			} else {
				tmp = (*struct {
					f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
				})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(bp + 24 /* &alc */)).Realloc})).f(tls, (*Yyjson_alc)(unsafe.Pointer(bp+24 /* &alc */)).Ctx, buf, buf_size)
				if !(tmp != 0) {
					for __ccgo6 := true; __ccgo6; __ccgo6 = 0 != 0 {
						(*Yyjson_read_err)(unsafe.Pointer(err)).Pos = uint64(0)
						(*Yyjson_read_err)(unsafe.Pointer(err)).Msg = ts + 877 /* "fail to alloc me..." */
						(*Yyjson_read_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_MEMORY_ALLOCATION
						if file != 0 {
							libc.Xfclose(tls, file)
						}
						if buf != 0 {
							(*struct {
								f func(*libc.TLS, uintptr, uintptr)
							})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(bp + 24 /* &alc */)).Free})).f(tls, (*Yyjson_alc)(unsafe.Pointer(bp+24 /* &alc */)).Ctx, buf)
						}
						return uintptr(0)
					}
				}
				buf = tmp
			}
			tmp = buf + uintptr(buf_size) - uintptr(YYJSON_PADDING_SIZE) - uintptr(chunk_now)
			read_size = Fread_safe(tls, tmp, chunk_now, file)
			file_size = file_size + int64(read_size)
			if read_size != chunk_now {
				break
			}

			chunk_now = chunk_now * uint64(2)
			if chunk_now > chunk_max {
				chunk_now = chunk_max
			}
		}
	}
	libc.Xfclose(tls, file)

	// read JSON
	libc.X__builtin___memset_chk(tls, buf+uintptr(file_size), 0, uint64(YYJSON_PADDING_SIZE), libc.X__builtin_object_size(tls, buf+uintptr(file_size), 0))
	flg = flg | sYYJSON_READ_INSITU
	doc = Yyjson_read_opts(tls, buf, Usize(file_size), flg, bp+24, err)
	if doc != 0 {
		(*Yyjson_doc)(unsafe.Pointer(doc)).Str_pool = buf
		return doc
	} else {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(bp + 24 /* &alc */)).Free})).f(tls, (*Yyjson_alc)(unsafe.Pointer(bp+24 /* &alc */)).Ctx, buf)
		return uintptr(0)
	}
	return uintptr(0)

}

// ==============================================================================
// Integer Writer
//
// The maximum value of uint32_t is 4294967295 (10 digits),
// these digits are named as 'aabbccddee' here.
//
// Although most compilers may convert the "division by constant value" into
// "multiply and shift", manual conversion can still help some compilers
// generate fewer and better instructions.
//
// Reference:
// Division by Invariant Integers using Multiplication, 1994.
// https://gmplib.org/~tege/divcnst-pldi94.pdf
// Improved division by invariant integers, 2011.
// https://gmplib.org/~tege/division-paper.pdf
//============================================================================

//* Digit table from 00 to 99.
var Digit_table = [200]int8{
	int8('0'), int8('0'), int8('0'), int8('1'), int8('0'), int8('2'), int8('0'), int8('3'), int8('0'), int8('4'),
	int8('0'), int8('5'), int8('0'), int8('6'), int8('0'), int8('7'), int8('0'), int8('8'), int8('0'), int8('9'),
	int8('1'), int8('0'), int8('1'), int8('1'), int8('1'), int8('2'), int8('1'), int8('3'), int8('1'), int8('4'),
	int8('1'), int8('5'), int8('1'), int8('6'), int8('1'), int8('7'), int8('1'), int8('8'), int8('1'), int8('9'),
	int8('2'), int8('0'), int8('2'), int8('1'), int8('2'), int8('2'), int8('2'), int8('3'), int8('2'), int8('4'),
	int8('2'), int8('5'), int8('2'), int8('6'), int8('2'), int8('7'), int8('2'), int8('8'), int8('2'), int8('9'),
	int8('3'), int8('0'), int8('3'), int8('1'), int8('3'), int8('2'), int8('3'), int8('3'), int8('3'), int8('4'),
	int8('3'), int8('5'), int8('3'), int8('6'), int8('3'), int8('7'), int8('3'), int8('8'), int8('3'), int8('9'),
	int8('4'), int8('0'), int8('4'), int8('1'), int8('4'), int8('2'), int8('4'), int8('3'), int8('4'), int8('4'),
	int8('4'), int8('5'), int8('4'), int8('6'), int8('4'), int8('7'), int8('4'), int8('8'), int8('4'), int8('9'),
	int8('5'), int8('0'), int8('5'), int8('1'), int8('5'), int8('2'), int8('5'), int8('3'), int8('5'), int8('4'),
	int8('5'), int8('5'), int8('5'), int8('6'), int8('5'), int8('7'), int8('5'), int8('8'), int8('5'), int8('9'),
	int8('6'), int8('0'), int8('6'), int8('1'), int8('6'), int8('2'), int8('6'), int8('3'), int8('6'), int8('4'),
	int8('6'), int8('5'), int8('6'), int8('6'), int8('6'), int8('7'), int8('6'), int8('8'), int8('6'), int8('9'),
	int8('7'), int8('0'), int8('7'), int8('1'), int8('7'), int8('2'), int8('7'), int8('3'), int8('7'), int8('4'),
	int8('7'), int8('5'), int8('7'), int8('6'), int8('7'), int8('7'), int8('7'), int8('8'), int8('7'), int8('9'),
	int8('8'), int8('0'), int8('8'), int8('1'), int8('8'), int8('2'), int8('8'), int8('3'), int8('8'), int8('4'),
	int8('8'), int8('5'), int8('8'), int8('6'), int8('8'), int8('7'), int8('8'), int8('8'), int8('8'), int8('9'),
	int8('9'), int8('0'), int8('9'), int8('1'), int8('9'), int8('2'), int8('9'), int8('3'), int8('9'), int8('4'),
	int8('9'), int8('5'), int8('9'), int8('6'), int8('9'), int8('7'), int8('9'), int8('8'), int8('9'), int8('9'),
} /* yyjson.c:5462:19 */

func Write_u32_len_8(tls *libc.TLS, val U32, buf uintptr) uintptr { /* yyjson.c:5485:4: */
	var aa U32
	var bb U32
	var cc U32
	var dd U32
	var aabb U32
	var ccdd U32                                   // 8 digits: aabbccdd
	aabb = U32(U64(val) * uint64(109951163) >> 40) // (val / 10000)
	ccdd = val - aabb*U32(10000)                   // (val % 10000)
	aa = aabb * U32(5243) >> 19                    // (aabb / 100)
	cc = ccdd * U32(5243) >> 19                    // (ccdd / 100)
	bb = aabb - aa*U32(100)                        // (aabb % 100)
	dd = ccdd - cc*U32(100)                        // (ccdd % 100)
	*(*V16)(unsafe.Pointer(buf)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(aa)*2))
	*(*V16)(unsafe.Pointer(buf + 1*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(bb)*2))
	*(*V16)(unsafe.Pointer(buf + 2*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(cc)*2))
	*(*V16)(unsafe.Pointer(buf + 3*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(dd)*2))
	return buf + uintptr(8)
}

func Write_u32_len_4(tls *libc.TLS, val U32, buf uintptr) uintptr { /* yyjson.c:5500:4: */
	var aa U32
	var bb U32                 // 4 digits: aabb
	aa = val * U32(5243) >> 19 // (val / 100)
	bb = val - aa*U32(100)     // (val % 100)
	*(*V16)(unsafe.Pointer(buf)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(aa)*2))
	*(*V16)(unsafe.Pointer(buf + 1*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(bb)*2))
	return buf + uintptr(4)
}

func Write_u32_len_1_8(tls *libc.TLS, val U32, buf uintptr) uintptr { /* yyjson.c:5509:4: */
	var aa U32
	var bb U32
	var cc U32
	var dd U32
	var aabb U32
	var bbcc U32
	var ccdd U32
	var lz U32

	if val < U32(100) { // 1-2 digits: aa
		lz = U32(libc.Bool32(val < U32(10))) // leading zero: 0 or 1
		*(*V16)(unsafe.Pointer(buf)) = *(*V16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Digit_table)) + uintptr(val*U32(2)+lz)))
		buf -= uintptr(lz)
		return buf + uintptr(2)

	} else if val < U32(10000) { // 3-4 digits: aabb
		aa = val * U32(5243) >> 19          // (val / 100)
		bb = val - aa*U32(100)              // (val % 100)
		lz = U32(libc.Bool32(aa < U32(10))) // leading zero: 0 or 1
		*(*V16)(unsafe.Pointer(buf)) = *(*V16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Digit_table)) + uintptr(aa*U32(2)+lz)))
		buf -= uintptr(lz)
		*(*V16)(unsafe.Pointer(buf + 1*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(bb)*2))
		return buf + uintptr(4)

	} else if val < U32(1000000) { // 5-6 digits: aabbcc
		aa = U32(U64(val) * uint64(429497) >> 32) // (val / 10000)
		bbcc = val - aa*U32(10000)                // (val % 10000)
		bb = bbcc * U32(5243) >> 19               // (bbcc / 100)
		cc = bbcc - bb*U32(100)                   // (bbcc % 100)
		lz = U32(libc.Bool32(aa < U32(10)))       // leading zero: 0 or 1
		*(*V16)(unsafe.Pointer(buf)) = *(*V16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Digit_table)) + uintptr(aa*U32(2)+lz)))
		buf -= uintptr(lz)
		*(*V16)(unsafe.Pointer(buf + 1*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(bb)*2))
		*(*V16)(unsafe.Pointer(buf + 2*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(cc)*2))
		return buf + uintptr(6)

	} else { // 7-8 digits: aabbccdd
		aabb = U32(U64(val) * uint64(109951163) >> 40) // (val / 10000)
		ccdd = val - aabb*U32(10000)                   // (val % 10000)
		aa = aabb * U32(5243) >> 19                    // (aabb / 100)
		cc = ccdd * U32(5243) >> 19                    // (ccdd / 100)
		bb = aabb - aa*U32(100)                        // (aabb % 100)
		dd = ccdd - cc*U32(100)                        // (ccdd % 100)
		lz = U32(libc.Bool32(aa < U32(10)))            // leading zero: 0 or 1
		*(*V16)(unsafe.Pointer(buf)) = *(*V16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Digit_table)) + uintptr(aa*U32(2)+lz)))
		buf -= uintptr(lz)
		*(*V16)(unsafe.Pointer(buf + 1*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(bb)*2))
		*(*V16)(unsafe.Pointer(buf + 2*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(cc)*2))
		*(*V16)(unsafe.Pointer(buf + 3*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(dd)*2))
		return buf + uintptr(8)
	}
	return uintptr(0)
}

func Write_u64_len_5_8(tls *libc.TLS, val U32, buf uintptr) uintptr { /* yyjson.c:5556:4: */
	var aa U32
	var bb U32
	var cc U32
	var dd U32
	var aabb U32
	var bbcc U32
	var ccdd U32
	var lz U32

	if val < U32(1000000) { // 5-6 digits: aabbcc
		aa = U32(U64(val) * uint64(429497) >> 32) // (val / 10000)
		bbcc = val - aa*U32(10000)                // (val % 10000)
		bb = bbcc * U32(5243) >> 19               // (bbcc / 100)
		cc = bbcc - bb*U32(100)                   // (bbcc % 100)
		lz = U32(libc.Bool32(aa < U32(10)))       // leading zero: 0 or 1
		*(*V16)(unsafe.Pointer(buf)) = *(*V16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Digit_table)) + uintptr(aa*U32(2)+lz)))
		buf -= uintptr(lz)
		*(*V16)(unsafe.Pointer(buf + 1*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(bb)*2))
		*(*V16)(unsafe.Pointer(buf + 2*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(cc)*2))
		return buf + uintptr(6)

	} else { // 7-8 digits: aabbccdd
		aabb = U32(U64(val) * uint64(109951163) >> 40) // (val / 10000)
		ccdd = val - aabb*U32(10000)                   // (val % 10000)
		aa = aabb * U32(5243) >> 19                    // (aabb / 100)
		cc = ccdd * U32(5243) >> 19                    // (ccdd / 100)
		bb = aabb - aa*U32(100)                        // (aabb % 100)
		dd = ccdd - cc*U32(100)                        // (ccdd % 100)
		lz = U32(libc.Bool32(aa < U32(10)))            // leading zero: 0 or 1
		*(*V16)(unsafe.Pointer(buf)) = *(*V16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Digit_table)) + uintptr(aa*U32(2)+lz)))
		buf -= uintptr(lz)
		*(*V16)(unsafe.Pointer(buf + 1*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(bb)*2))
		*(*V16)(unsafe.Pointer(buf + 2*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(cc)*2))
		*(*V16)(unsafe.Pointer(buf + 3*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(dd)*2))
		return buf + uintptr(8)
	}
	return uintptr(0)
}

func Write_u64(tls *libc.TLS, val U64, buf uintptr) uintptr { /* yyjson.c:5588:4: */
	var tmp U64
	var hgh U64
	var mid U32
	var low U32

	if val < uint64(100000000) { // 1-8 digits
		buf = Write_u32_len_1_8(tls, U32(val), buf)
		return buf

	} else if val < uint64(100000000)*uint64(100000000) { // 9-16 digits
		hgh = val / uint64(100000000)          // (val / 100000000)
		low = U32(val - hgh*uint64(100000000)) // (val % 100000000)
		buf = Write_u32_len_1_8(tls, U32(hgh), buf)
		buf = Write_u32_len_8(tls, low, buf)
		return buf

	} else { // 17-20 digits
		tmp = val / uint64(100000000)          // (val / 100000000)
		low = U32(val - tmp*uint64(100000000)) // (val % 100000000)
		hgh = U64(U32(tmp / uint64(10000)))    // (tmp / 10000)
		mid = U32(tmp - hgh*uint64(10000))     // (tmp % 10000)
		buf = Write_u64_len_5_8(tls, U32(hgh), buf)
		buf = Write_u32_len_4(tls, mid, buf)
		buf = Write_u32_len_8(tls, low, buf)
		return buf
	}
	return uintptr(0)
}

// ==============================================================================
// Number Writer
//============================================================================

//* Trailing zero count table for number 0 to 99.
//     (generate with misc/make_tables.c)
var dec_trailing_zero_table = [100]U8{
	U8(2), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0),
	U8(1), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0),
	U8(1), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0),
	U8(1), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0),
	U8(1), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0),
	U8(1), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0),
	U8(1), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0),
	U8(1), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0),
	U8(1), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0),
	U8(1), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0), U8(0),
} /* yyjson.c:5625:17 */

//* Write an unsigned integer with a length of 1 to 16.
func Write_u64_len_1_to_16(tls *libc.TLS, val U64, buf uintptr) uintptr { /* yyjson.c:5639:4: */
	var hgh U64
	var low U32
	if val < uint64(100000000) { // 1-8 digits
		buf = Write_u32_len_1_8(tls, U32(val), buf)
		return buf
	} else { // 9-16 digits
		hgh = val / uint64(100000000)          // (val / 100000000)
		low = U32(val - hgh*uint64(100000000)) // (val % 100000000)
		buf = Write_u32_len_1_8(tls, U32(hgh), buf)
		buf = Write_u32_len_8(tls, low, buf)
		return buf
	}
	return uintptr(0)
}

//* Write an unsigned integer with a length of 1 to 17.
func Write_u64_len_1_to_17(tls *libc.TLS, val U64, buf uintptr) uintptr { /* yyjson.c:5655:4: */
	var hgh U64
	var mid U32
	var low U32
	var one U32
	if val >= uint64(100000000)*uint64(10000000) { // len: 16 to 17
		hgh = val / uint64(100000000)               // (val / 100000000)
		low = U32(val - hgh*uint64(100000000))      // (val % 100000000)
		one = U32(hgh / uint64(100000000))          // (hgh / 100000000)
		mid = U32(hgh - U64(one)*uint64(100000000)) // (hgh % 100000000)
		*(*U8)(unsafe.Pointer(buf)) = U8(int32(U8(one)) + int32(U8('0')))
		buf += uintptr(libc.Bool32(one > U32(0)))
		buf = Write_u32_len_8(tls, mid, buf)
		buf = Write_u32_len_8(tls, low, buf)
		return buf
	} else if val >= uint64(100000000) { // len: 9 to 15
		hgh = val / uint64(100000000)          // (val / 100000000)
		low = U32(val - hgh*uint64(100000000)) // (val % 100000000)
		buf = Write_u32_len_1_8(tls, U32(hgh), buf)
		buf = Write_u32_len_8(tls, low, buf)
		return buf
	} else { // len: 1 to 8
		buf = Write_u32_len_1_8(tls, U32(val), buf)
		return buf
	}
	return uintptr(0)
}

//*
//  Write an unsigned integer with a length of 15 to 17 with trailing zero trimmed.
//  These digits are named as "aabbccddeeffgghhii" here.
//  For example, input 1234567890123000, output "1234567890123".
//
func Write_u64_len_15_to_17_trim(tls *libc.TLS, buf uintptr, sig U64) uintptr { /* yyjson.c:5685:4: */
	var lz uint8 // leading zero
	var tz1 U32
	var tz2 U32
	var tz U32 // trailing zero

	var abbccddee U32 = U32(sig / uint64(100000000))
	var ffgghhii U32 = U32(sig - U64(abbccddee)*uint64(100000000))
	var abbcc U32 = abbccddee / U32(10000)               // (abbccddee / 10000)
	var ddee U32 = abbccddee - abbcc*U32(10000)          // (abbccddee % 10000)
	var abb U32 = U32(U64(abbcc) * uint64(167773) >> 24) // (abbcc / 100)
	var a U32 = abb * U32(41) >> 12                      // (abb / 100)
	var bb U32 = abb - a*U32(100)                        // (abb % 100)
	var cc U32 = abbcc - abb*U32(100)                    // (abbcc % 100)

	// write abbcc
	*(*U8)(unsafe.Pointer(buf)) = U8(a + U32('0'))
	buf += uintptr(libc.Bool32(a > U32(0)))
	lz = uint8(libc.Bool32(bb < U32(10) && a == U32(0)))
	*(*V16)(unsafe.Pointer(buf)) = *(*V16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Digit_table)) + uintptr(bb*U32(2)+U32(lz))))
	buf -= uintptr(lz)
	*(*V16)(unsafe.Pointer(buf + 1*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(cc)*2))

	if ffgghhii != 0 {
		var dd U32 = ddee * U32(5243) >> 19                         // (ddee / 100)
		var ee U32 = ddee - dd*U32(100)                             // (ddee % 100)
		var ffgg U32 = U32(U64(ffgghhii) * uint64(109951163) >> 40) // (val / 10000)
		var hhii U32 = ffgghhii - ffgg*U32(10000)                   // (val % 10000)
		var ff U32 = ffgg * U32(5243) >> 19                         // (aabb / 100)
		var gg U32 = ffgg - ff*U32(100)                             // (aabb % 100)
		*(*V16)(unsafe.Pointer(buf + 2*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(dd)*2))
		*(*V16)(unsafe.Pointer(buf + 3*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(ee)*2))
		*(*V16)(unsafe.Pointer(buf + 4*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(ff)*2))
		*(*V16)(unsafe.Pointer(buf + 5*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(gg)*2))
		if hhii != 0 {
			var hh U32 = hhii * U32(5243) >> 19 // (ccdd / 100)
			var ii U32 = hhii - hh*U32(100)     // (ccdd % 100)
			*(*V16)(unsafe.Pointer(buf + 6*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(hh)*2))
			*(*V16)(unsafe.Pointer(buf + 7*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(ii)*2))
			tz1 = U32(dec_trailing_zero_table[hh])
			tz2 = U32(dec_trailing_zero_table[ii])
			if ii != 0 {
				tz = tz2
			} else {
				tz = tz1 + U32(2)
			}
			buf += uintptr(U32(16) - tz)
			return buf
		} else {
			tz1 = U32(dec_trailing_zero_table[ff])
			tz2 = U32(dec_trailing_zero_table[gg])
			if gg != 0 {
				tz = tz2
			} else {
				tz = tz1 + U32(2)
			}
			buf += uintptr(U32(12) - tz)
			return buf
		}
	} else {
		if ddee != 0 {
			var dd U32 = ddee * U32(5243) >> 19 // (ddee / 100)
			var ee U32 = ddee - dd*U32(100)     // (ddee % 100)
			*(*V16)(unsafe.Pointer(buf + 2*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(dd)*2))
			*(*V16)(unsafe.Pointer(buf + 3*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Digit_table))) + uintptr(ee)*2))
			tz1 = U32(dec_trailing_zero_table[dd])
			tz2 = U32(dec_trailing_zero_table[ee])
			if ee != 0 {
				tz = tz2
			} else {
				tz = tz1 + U32(2)
			}
			buf += uintptr(U32(8) - tz)
			return buf
		} else {
			tz1 = U32(dec_trailing_zero_table[bb])
			tz2 = U32(dec_trailing_zero_table[cc])
			if cc != 0 {
				tz = tz2
			} else {
				tz = tz1 + tz2
			}
			buf += uintptr(U32(4) - tz)
			return buf
		}
	}
	return uintptr(0)
}

//* Write a signed integer in the range -324 to 308.
func Write_f64_exp(tls *libc.TLS, exp I32, buf uintptr) uintptr { /* yyjson.c:5756:4: */
	*(*U8)(unsafe.Pointer(buf)) = U8('-')
	buf += uintptr(libc.Bool32(exp < 0))
	if exp < 0 {
		exp = -exp
	} else {
		exp = exp
	}
	if exp < 100 {
		var lz U32 = U32(libc.Bool32(exp < 10))
		*(*V16)(unsafe.Pointer(buf)) = *(*V16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Digit_table)) + uintptr(U32(exp)*U32(2)+lz)))
		return buf + uintptr(2) - uintptr(lz)
	} else {
		var hi U32 = U32(exp) * U32(656) >> 16 // exp / 100
		var lo U32 = U32(exp) - hi*U32(100)    // exp % 100
		*(*U8)(unsafe.Pointer(buf)) = U8(int32(U8(hi)) + int32(U8('0')))
		*(*V16)(unsafe.Pointer(buf + 1)) = *(*V16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Digit_table)) + uintptr(lo*U32(2))))
		return buf + uintptr(3)
	}
	return uintptr(0)
}

//* Multiplies 128-bit integer and returns highest 64-bit rounded value.
func Round_to_odd(tls *libc.TLS, hi U64, lo U64, cp U64) U64 { /* yyjson.c:5774:5: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var x_hi U64 at bp, 8

	// var x_lo U64 at bp+8, 8

	// var y_hi U64 at bp+16, 8

	// var y_lo U64 at bp+24, 8

	U128_mul(tls, cp, lo, bp, bp+8)
	U128_mul_add(tls, cp, hi, *(*U64)(unsafe.Pointer(bp /* x_hi */)), bp+16, bp+24)
	return *(*U64)(unsafe.Pointer(bp + 16)) | U64(libc.Bool32(*(*U64)(unsafe.Pointer(bp + 24)) > uint64(1)))
}

//*
//  Convert double number from binary to decimal.
//  The output significand is shortest decimal but may have trailing zeros.
//
//  This function use the Schubfach algorithm:
//  Raffaello Giulietti, The Schubfach way to render doubles, 2020.
//  https://drive.google.com/open?id=1luHhyQF9zKlM8yJ1nebU0OgVYhfC6CBN
//  https://github.com/abolz/Drachennest
//
//  See also:
//  Dragonbox: A New Floating-Point Binary-to-Decimal Conversion Algorithm, 2020.
//  https://github.com/jk-jeon/dragonbox/blob/master/other_files/Dragonbox.pdf
//  https://github.com/jk-jeon/dragonbox
//
//  @param sig_raw The raw value of significand in IEEE 754 format.
//  @param exp_raw The raw value of exponent in IEEE 754 format.
//  @param sig_bin The decoded value of significand in binary.
//  @param exp_bin The decoded value of exponent in binary.
//  @param sig_dec The output value of significand in decimal.
//  @param exp_dec The output value of exponent in decimal.
//  @warning The input double number should not be 0, inf, nan.
//
func F64_bin_to_dec(tls *libc.TLS, sig_raw U64, exp_raw U32, sig_bin U64, exp_bin I32, sig_dec uintptr, exp_dec uintptr) { /* yyjson.c:5803:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var is_even uint8
	var lower_bound_closer uint8
	var u_inside uint8
	var w_inside uint8
	var round_up uint8
	var s U64
	var sp U64
	var cb U64
	var cbl U64
	var cbr U64
	var vb U64
	var vbl U64
	var vbr U64
	// var pow10hi U64 at bp, 8

	// var pow10lo U64 at bp+8, 8

	var upper U64
	var lower U64
	var mid U64
	var k I32
	var h I32
	var exp10 I32

	is_even = libc.BoolUint8(!(sig_bin&uint64(1) != 0))
	lower_bound_closer = uint8(libc.Bool32(sig_raw == uint64(0) && exp_raw > U32(1)))

	cbl = uint64(4)*sig_bin - uint64(2) + U64(lower_bound_closer)
	cb = uint64(4) * sig_bin
	cbr = uint64(4)*sig_bin + uint64(2)

	// exp_bin: [-1074, 971]
	// k = lower_bound_closer ? floor(log10(pow(2, exp_bin)))
	//                        : floor(log10(pow(2, exp_bin) * 3.0 / 4.0))
	//   = lower_bound_closer ? floor(exp_bin * log10(2))
	//                        : floor(exp_bin * log10(2) + log10(3.0 / 4.0))
	k = (exp_bin*315653 - func() int32 {
		if lower_bound_closer != 0 {
			return 131237
		}
		return 0
	}()) >> 20

	// k: [-324, 292]
	// h = exp_bin + floor(log2(pow(10, e)))
	//   = exp_bin + floor(log2(10) * e)
	exp10 = -k
	h = exp_bin + exp10*217707>>16 + 1

	Pow10_table_get_sig(tls, exp10, bp, bp+8)
	*(*U64)(unsafe.Pointer(bp + 8 /* pow10lo */)) += U64(libc.Bool32(exp10 < POW10_SIG_TABLE_MIN_EXACT_EXP || exp10 > POW10_SIG_TABLE_MAX_EXACT_EXP))
	vbl = Round_to_odd(tls, *(*U64)(unsafe.Pointer(bp /* pow10hi */)), *(*U64)(unsafe.Pointer(bp + 8 /* pow10lo */)), cbl<<h)
	vb = Round_to_odd(tls, *(*U64)(unsafe.Pointer(bp /* pow10hi */)), *(*U64)(unsafe.Pointer(bp + 8 /* pow10lo */)), cb<<h)
	vbr = Round_to_odd(tls, *(*U64)(unsafe.Pointer(bp /* pow10hi */)), *(*U64)(unsafe.Pointer(bp + 8 /* pow10lo */)), cbr<<h)

	lower = vbl + libc.BoolUint64(!(is_even != 0))
	upper = vbr - libc.BoolUint64(!(is_even != 0))

	s = vb / uint64(4)
	if s >= uint64(10) {
		sp = s / uint64(10)
		u_inside = uint8(libc.Bool32(lower <= uint64(40)*sp))
		w_inside = uint8(libc.Bool32(upper >= uint64(40)*sp+uint64(40)))
		if u_inside != w_inside {
			*(*U64)(unsafe.Pointer(sig_dec)) = sp + U64(w_inside)
			*(*I32)(unsafe.Pointer(exp_dec)) = k + 1
			return
		}
	}

	u_inside = uint8(libc.Bool32(lower <= uint64(4)*s))
	w_inside = uint8(libc.Bool32(upper >= uint64(4)*s+uint64(4)))

	mid = uint64(4)*s + uint64(2)
	round_up = uint8(libc.Bool32(vb > mid || vb == mid && s&uint64(1) != uint64(0)))

	*(*U64)(unsafe.Pointer(sig_dec)) = s + func() uint64 {
		if u_inside != w_inside {
			return uint64(w_inside)
		}
		return uint64(round_up)
	}()
	*(*I32)(unsafe.Pointer(exp_dec)) = k
}

//*
//  Write a double number (requires 32 bytes buffer).
//
//  We follows the ECMAScript specification to print floating point numbers,
//  but with the following changes:
//  1. Keep the negative sign of 0.0 to preserve input information.
//  2. Keep decimal point to indicate the number is floating point.
//  3. Remove positive sign of exponent part.
func write_f64_raw(tls *libc.TLS, buf uintptr, raw U64, flg Yyjson_write_flag) uintptr { /* yyjson.c:5872:20: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var sig_bin U64
	// var sig_dec U64 at bp, 8

	var sig_raw U64
	var exp_bin I32
	// var exp_dec I32 at bp+8, 4

	var sig_len I32
	var dot_pos I32
	var i I32
	var max I32
	var exp_raw U32
	var hi U32
	var lo U32
	var hdr uintptr
	var num_hdr uintptr
	var num_end uintptr
	var dot_end uintptr
	var sign uint8

	// decode raw bytes from IEEE-754 double format.
	sign = uint8(raw >> (F64_BITS - 1))
	sig_raw = raw & (U64(0x000FFFFF)<<32 + 0xFFFFFFFF)
	exp_raw = U32(raw & (U64(0x7FF00000)<<32 + 0x00000000) >> F64_SIG_BITS)

	// return inf and nan
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(exp_raw == U32(U32(1))<<F64_EXP_BITS-U32(1))), int64(0)) != 0 {
		if flg&sYYJSON_WRITE_INF_AND_NAN_AS_NULL != 0 {
			*(*V32)(unsafe.Pointer(buf)) = V32_make(tls, int8('n'), int8('u'), int8('l'), int8('l'))
			return buf + uintptr(4)
		} else if flg&sYYJSON_WRITE_ALLOW_INF_AND_NAN != 0 {
			if sig_raw == uint64(0) {
				*(*U8)(unsafe.Pointer(buf)) = U8('-')
				buf += uintptr(sign)
				*(*V32)(unsafe.Pointer(buf)) = V32_make(tls, int8('I'), int8('n'), int8('f'), int8('i'))
				*(*V32)(unsafe.Pointer(buf + 4)) = V32_make(tls, int8('n'), int8('i'), int8('t'), int8('y'))
				buf += uintptr(8)
				return buf
			} else {
				*(*V32)(unsafe.Pointer(buf)) = V32_make(tls, int8('N'), int8('a'), int8('N'), int8(0))
				return buf + uintptr(3)
			}
		} else {
			return uintptr(0)
		}
	}

	// add sign for all finite double value, including 0.0 and inf
	*(*U8)(unsafe.Pointer(buf)) = U8('-')
	buf += uintptr(sign)
	hdr = buf

	// return zero
	if raw<<1 == uint64(0) {
		*(*V32)(unsafe.Pointer(buf)) = V32_make(tls, int8('0'), int8('.'), int8('0'), int8(0))
		buf += uintptr(3)
		return buf
	}

	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(exp_raw != U32(0))), int64(1)) != 0 {
		// normal number
		sig_bin = sig_raw | U64(uint64(1))<<F64_SIG_BITS
		exp_bin = I32(exp_raw) - F64_EXP_BIAS - F64_SIG_BITS

		// fast path for small integer number without fraction
		if -F64_SIG_BITS <= exp_bin && exp_bin <= 0 {
			if U64_tz_bits(tls, sig_bin) >= U32(-exp_bin) {
				// number is integer in range 1 to 0x1FFFFFFFFFFFFF
				*(*U64)(unsafe.Pointer(bp /* sig_dec */)) = sig_bin >> -exp_bin
				buf = Write_u64_len_1_to_16(tls, *(*U64)(unsafe.Pointer(bp /* sig_dec */)), buf)
				*(*V16)(unsafe.Pointer(buf)) = V16_make(tls, int8('.'), int8('0'))
				buf += uintptr(2)
				return buf
			}
		}

		// binary to decimal
		F64_bin_to_dec(tls, sig_raw, exp_raw, sig_bin, exp_bin, bp, bp+8)

		// the sig length is 15 to 17
		sig_len = 17
		sig_len = sig_len - libc.Bool32(*(*U64)(unsafe.Pointer(bp)) < uint64(100000000)*uint64(100000000))
		sig_len = sig_len - libc.Bool32(*(*U64)(unsafe.Pointer(bp)) < uint64(100000000)*uint64(10000000))

		// the decimal point position relative to the first digit
		dot_pos = sig_len + *(*I32)(unsafe.Pointer(bp + 8))

		if -6 < dot_pos && dot_pos <= 21 {
			// no need to write exponent part
			if dot_pos <= 0 {
				// dot before first digit
				// such as 0.1234, 0.000001234
				num_hdr = hdr + uintptr(2-dot_pos)
				num_end = Write_u64_len_15_to_17_trim(tls, num_hdr, *(*U64)(unsafe.Pointer(bp /* sig_dec */)))
				*(*U8)(unsafe.Pointer(hdr)) = U8('0')
				*(*U8)(unsafe.Pointer(hdr + 1)) = U8('.')
				hdr += uintptr(2)
				max = -dot_pos
				for i = 0; i < max; i++ {
					*(*U8)(unsafe.Pointer(hdr + uintptr(i))) = U8('0')
				}
				return num_end
			} else {
				// dot after first digit
				// such as 1.234, 1234.0, 123400000000000000000.0
				libc.X__builtin___memset_chk(tls, hdr+uintptr(0), '0', uint64(8), libc.X__builtin_object_size(tls, hdr+uintptr(0), 0))
				libc.X__builtin___memset_chk(tls, hdr+uintptr(8), '0', uint64(8), libc.X__builtin_object_size(tls, hdr+uintptr(8), 0))
				libc.X__builtin___memset_chk(tls, hdr+uintptr(16), '0', uint64(8), libc.X__builtin_object_size(tls, hdr+uintptr(16), 0))
				num_hdr = hdr + uintptr(1)
				num_end = Write_u64_len_15_to_17_trim(tls, num_hdr, *(*U64)(unsafe.Pointer(bp /* sig_dec */)))
				for i = 0; i < dot_pos; i++ {
					*(*U8)(unsafe.Pointer(hdr + uintptr(i))) = *(*U8)(unsafe.Pointer(hdr + uintptr(i+1)))
				}
				*(*U8)(unsafe.Pointer(hdr + uintptr(dot_pos))) = U8('.')
				dot_end = hdr + uintptr(dot_pos) + uintptr(2)
				if dot_end < num_end {
					return num_end
				}
				return dot_end
			}
		} else {
			// write with scientific notation
			// such as 1.234e56
			var end uintptr = Write_u64_len_15_to_17_trim(tls, buf+uintptr(1), *(*U64)(unsafe.Pointer(bp /* sig_dec */)))
			*(*I32)(unsafe.Pointer(bp + 8 /* exp_dec */)) += sig_len - 1
			*(*U8)(unsafe.Pointer(hdr)) = *(*U8)(unsafe.Pointer(hdr + 1))
			*(*U8)(unsafe.Pointer(hdr + 1)) = U8('.')
			*(*U8)(unsafe.Pointer(end)) = U8('e')
			buf = Write_f64_exp(tls, *(*I32)(unsafe.Pointer(bp + 8 /* exp_dec */)), end+uintptr(1))
			return buf
		}

	} else {
		// subnormal number
		sig_bin = sig_raw
		exp_bin = 1 - F64_EXP_BIAS - F64_SIG_BITS

		// binary to decimal
		F64_bin_to_dec(tls, sig_raw, exp_raw, sig_bin, exp_bin, bp, bp+8)

		// write significand part
		buf = Write_u64_len_1_to_17(tls, *(*U64)(unsafe.Pointer(bp /* sig_dec */)), buf+uintptr(1))
		*(*U8)(unsafe.Pointer(hdr)) = *(*U8)(unsafe.Pointer(hdr + 1))
		*(*U8)(unsafe.Pointer(hdr + 1)) = U8('.')
		for __ccgo := true; __ccgo; __ccgo = int32(*(*U8)(unsafe.Pointer(buf))) == '0' {
			buf--
			*(*I32)(unsafe.Pointer(bp + 8 /* exp_dec */))++
		}
		*(*I32)(unsafe.Pointer(bp + 8 /* exp_dec */)) += I32((int64(buf)-int64(hdr))/1 - int64(2))
		buf += uintptr(libc.Bool32(int32(*(*U8)(unsafe.Pointer(buf))) != '.'))
		*(*U8)(unsafe.Pointer(buf)) = U8('e')
		buf++

		// write exponent part
		*(*U8)(unsafe.Pointer(buf)) = U8('-')
		buf++
		*(*I32)(unsafe.Pointer(bp + 8 /* exp_dec */)) = -*(*I32)(unsafe.Pointer(bp + 8 /* exp_dec */))
		hi = U32(*(*I32)(unsafe.Pointer(bp + 8))) * U32(656) >> 16 // exp / 100
		lo = U32(*(*I32)(unsafe.Pointer(bp + 8))) - hi*U32(100)    // exp % 100
		*(*U8)(unsafe.Pointer(buf)) = U8(int32(U8(hi)) + int32(U8('0')))
		*(*V16)(unsafe.Pointer(buf + 1)) = *(*V16)(unsafe.Pointer(uintptr(unsafe.Pointer(&Digit_table)) + uintptr(lo*U32(2))))
		buf += uintptr(3)
		return buf
	}
	return uintptr(0)
}

//* Write a JSON number (requires 32 bytes buffer).
func Write_number(tls *libc.TLS, cur uintptr, val uintptr, flg Yyjson_write_flag) uintptr { /* yyjson.c:6084:4: */
	if (*Yyjson_val)(unsafe.Pointer(val)).Tag&Uint64_t(Uint8_t(int32(2)<<3)) != 0 {
		var raw U64 = *(*Uint64_t)(unsafe.Pointer(val + 8))
		return write_f64_raw(tls, cur, raw, flg)
	} else {
		var pos U64 = *(*Uint64_t)(unsafe.Pointer(val + 8))
		var neg U64 = ^pos + uint64(1)
		var sgn Usize = Usize(libc.Bool32((*Yyjson_val)(unsafe.Pointer(val)).Tag&Uint64_t(Uint8_t(int32(1)<<3)) > uint64(0)) & libc.Bool32(I64(pos) < int64(0)))
		*(*U8)(unsafe.Pointer(cur)) = U8('-')
		return Write_u64(tls, func() uint64 {
			if sgn != 0 {
				return neg
			}
			return pos
		}(), cur+uintptr(sgn))
	}
	return uintptr(0)
}

// ==============================================================================
// String Writer
//============================================================================

//* Character escape type.
type Char_esc_type = U8 /* yyjson.c:6105:12 */

//* Character escape type table: don't escape unicode, don't escape '/'.
//     (generate with misc/make_tables.c)
var esc_table_default = [256]Char_esc_type{
	Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(1), Char_esc_type(1), Char_esc_type(1), Char_esc_type(2), Char_esc_type(1), Char_esc_type(1), Char_esc_type(2), Char_esc_type(2),
	Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(1), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(1), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
} /* yyjson.c:6115:28 */

//* Character escape type table: don't escape unicode, escape '/'.
//     (generate with misc/make_tables.c)
var esc_table_default_with_slashes = [256]Char_esc_type{
	Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(1), Char_esc_type(1), Char_esc_type(1), Char_esc_type(2), Char_esc_type(1), Char_esc_type(1), Char_esc_type(2), Char_esc_type(2),
	Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(1), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(1),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(1), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
} /* yyjson.c:6136:28 */

//* Character escape type table: escape unicode, don't escape '/'.
//     (generate with misc/make_tables.c)
var esc_table_unicode = [256]Char_esc_type{
	Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(1), Char_esc_type(1), Char_esc_type(1), Char_esc_type(2), Char_esc_type(1), Char_esc_type(1), Char_esc_type(2), Char_esc_type(2),
	Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(1), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(1), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3),
	Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3),
	Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4),
	Char_esc_type(5), Char_esc_type(5), Char_esc_type(5), Char_esc_type(5), Char_esc_type(5), Char_esc_type(5), Char_esc_type(5), Char_esc_type(5), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
} /* yyjson.c:6157:28 */

//* Character escape type table: escape unicode, escape '/'.
//     (generate with misc/make_tables.c)
var esc_table_unicode_with_slashes = [256]Char_esc_type{
	Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(1), Char_esc_type(1), Char_esc_type(1), Char_esc_type(2), Char_esc_type(1), Char_esc_type(1), Char_esc_type(2), Char_esc_type(2),
	Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2), Char_esc_type(2),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(1), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(1),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(1), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
	Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3),
	Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3), Char_esc_type(3),
	Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4), Char_esc_type(4),
	Char_esc_type(5), Char_esc_type(5), Char_esc_type(5), Char_esc_type(5), Char_esc_type(5), Char_esc_type(5), Char_esc_type(5), Char_esc_type(5), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0), Char_esc_type(0),
} /* yyjson.c:6178:28 */

//* Escaped hex character table: ["00" "01" "02" ... "FD" "FE" "FF"].
//     (generate with misc/make_tables.c)
var Esc_hex_char_table = [512]U8{
	U8('0'), U8('0'), U8('0'), U8('1'), U8('0'), U8('2'), U8('0'), U8('3'),
	U8('0'), U8('4'), U8('0'), U8('5'), U8('0'), U8('6'), U8('0'), U8('7'),
	U8('0'), U8('8'), U8('0'), U8('9'), U8('0'), U8('A'), U8('0'), U8('B'),
	U8('0'), U8('C'), U8('0'), U8('D'), U8('0'), U8('E'), U8('0'), U8('F'),
	U8('1'), U8('0'), U8('1'), U8('1'), U8('1'), U8('2'), U8('1'), U8('3'),
	U8('1'), U8('4'), U8('1'), U8('5'), U8('1'), U8('6'), U8('1'), U8('7'),
	U8('1'), U8('8'), U8('1'), U8('9'), U8('1'), U8('A'), U8('1'), U8('B'),
	U8('1'), U8('C'), U8('1'), U8('D'), U8('1'), U8('E'), U8('1'), U8('F'),
	U8('2'), U8('0'), U8('2'), U8('1'), U8('2'), U8('2'), U8('2'), U8('3'),
	U8('2'), U8('4'), U8('2'), U8('5'), U8('2'), U8('6'), U8('2'), U8('7'),
	U8('2'), U8('8'), U8('2'), U8('9'), U8('2'), U8('A'), U8('2'), U8('B'),
	U8('2'), U8('C'), U8('2'), U8('D'), U8('2'), U8('E'), U8('2'), U8('F'),
	U8('3'), U8('0'), U8('3'), U8('1'), U8('3'), U8('2'), U8('3'), U8('3'),
	U8('3'), U8('4'), U8('3'), U8('5'), U8('3'), U8('6'), U8('3'), U8('7'),
	U8('3'), U8('8'), U8('3'), U8('9'), U8('3'), U8('A'), U8('3'), U8('B'),
	U8('3'), U8('C'), U8('3'), U8('D'), U8('3'), U8('E'), U8('3'), U8('F'),
	U8('4'), U8('0'), U8('4'), U8('1'), U8('4'), U8('2'), U8('4'), U8('3'),
	U8('4'), U8('4'), U8('4'), U8('5'), U8('4'), U8('6'), U8('4'), U8('7'),
	U8('4'), U8('8'), U8('4'), U8('9'), U8('4'), U8('A'), U8('4'), U8('B'),
	U8('4'), U8('C'), U8('4'), U8('D'), U8('4'), U8('E'), U8('4'), U8('F'),
	U8('5'), U8('0'), U8('5'), U8('1'), U8('5'), U8('2'), U8('5'), U8('3'),
	U8('5'), U8('4'), U8('5'), U8('5'), U8('5'), U8('6'), U8('5'), U8('7'),
	U8('5'), U8('8'), U8('5'), U8('9'), U8('5'), U8('A'), U8('5'), U8('B'),
	U8('5'), U8('C'), U8('5'), U8('D'), U8('5'), U8('E'), U8('5'), U8('F'),
	U8('6'), U8('0'), U8('6'), U8('1'), U8('6'), U8('2'), U8('6'), U8('3'),
	U8('6'), U8('4'), U8('6'), U8('5'), U8('6'), U8('6'), U8('6'), U8('7'),
	U8('6'), U8('8'), U8('6'), U8('9'), U8('6'), U8('A'), U8('6'), U8('B'),
	U8('6'), U8('C'), U8('6'), U8('D'), U8('6'), U8('E'), U8('6'), U8('F'),
	U8('7'), U8('0'), U8('7'), U8('1'), U8('7'), U8('2'), U8('7'), U8('3'),
	U8('7'), U8('4'), U8('7'), U8('5'), U8('7'), U8('6'), U8('7'), U8('7'),
	U8('7'), U8('8'), U8('7'), U8('9'), U8('7'), U8('A'), U8('7'), U8('B'),
	U8('7'), U8('C'), U8('7'), U8('D'), U8('7'), U8('E'), U8('7'), U8('F'),
	U8('8'), U8('0'), U8('8'), U8('1'), U8('8'), U8('2'), U8('8'), U8('3'),
	U8('8'), U8('4'), U8('8'), U8('5'), U8('8'), U8('6'), U8('8'), U8('7'),
	U8('8'), U8('8'), U8('8'), U8('9'), U8('8'), U8('A'), U8('8'), U8('B'),
	U8('8'), U8('C'), U8('8'), U8('D'), U8('8'), U8('E'), U8('8'), U8('F'),
	U8('9'), U8('0'), U8('9'), U8('1'), U8('9'), U8('2'), U8('9'), U8('3'),
	U8('9'), U8('4'), U8('9'), U8('5'), U8('9'), U8('6'), U8('9'), U8('7'),
	U8('9'), U8('8'), U8('9'), U8('9'), U8('9'), U8('A'), U8('9'), U8('B'),
	U8('9'), U8('C'), U8('9'), U8('D'), U8('9'), U8('E'), U8('9'), U8('F'),
	U8('A'), U8('0'), U8('A'), U8('1'), U8('A'), U8('2'), U8('A'), U8('3'),
	U8('A'), U8('4'), U8('A'), U8('5'), U8('A'), U8('6'), U8('A'), U8('7'),
	U8('A'), U8('8'), U8('A'), U8('9'), U8('A'), U8('A'), U8('A'), U8('B'),
	U8('A'), U8('C'), U8('A'), U8('D'), U8('A'), U8('E'), U8('A'), U8('F'),
	U8('B'), U8('0'), U8('B'), U8('1'), U8('B'), U8('2'), U8('B'), U8('3'),
	U8('B'), U8('4'), U8('B'), U8('5'), U8('B'), U8('6'), U8('B'), U8('7'),
	U8('B'), U8('8'), U8('B'), U8('9'), U8('B'), U8('A'), U8('B'), U8('B'),
	U8('B'), U8('C'), U8('B'), U8('D'), U8('B'), U8('E'), U8('B'), U8('F'),
	U8('C'), U8('0'), U8('C'), U8('1'), U8('C'), U8('2'), U8('C'), U8('3'),
	U8('C'), U8('4'), U8('C'), U8('5'), U8('C'), U8('6'), U8('C'), U8('7'),
	U8('C'), U8('8'), U8('C'), U8('9'), U8('C'), U8('A'), U8('C'), U8('B'),
	U8('C'), U8('C'), U8('C'), U8('D'), U8('C'), U8('E'), U8('C'), U8('F'),
	U8('D'), U8('0'), U8('D'), U8('1'), U8('D'), U8('2'), U8('D'), U8('3'),
	U8('D'), U8('4'), U8('D'), U8('5'), U8('D'), U8('6'), U8('D'), U8('7'),
	U8('D'), U8('8'), U8('D'), U8('9'), U8('D'), U8('A'), U8('D'), U8('B'),
	U8('D'), U8('C'), U8('D'), U8('D'), U8('D'), U8('E'), U8('D'), U8('F'),
	U8('E'), U8('0'), U8('E'), U8('1'), U8('E'), U8('2'), U8('E'), U8('3'),
	U8('E'), U8('4'), U8('E'), U8('5'), U8('E'), U8('6'), U8('E'), U8('7'),
	U8('E'), U8('8'), U8('E'), U8('9'), U8('E'), U8('A'), U8('E'), U8('B'),
	U8('E'), U8('C'), U8('E'), U8('D'), U8('E'), U8('E'), U8('E'), U8('F'),
	U8('F'), U8('0'), U8('F'), U8('1'), U8('F'), U8('2'), U8('F'), U8('3'),
	U8('F'), U8('4'), U8('F'), U8('5'), U8('F'), U8('6'), U8('F'), U8('7'),
	U8('F'), U8('8'), U8('F'), U8('9'), U8('F'), U8('A'), U8('F'), U8('B'),
	U8('F'), U8('C'), U8('F'), U8('D'), U8('F'), U8('E'), U8('F'), U8('F'),
} /* yyjson.c:6200:17 */

//* Escaped single character table. (generate with misc/make_tables.c)
var Esc_single_char_table = [512]U8{
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8('\\'), U8('b'), U8('\\'), U8('t'), U8('\\'), U8('n'), U8(' '), U8(' '),
	U8('\\'), U8('f'), U8('\\'), U8('r'), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8('\\'), U8('"'), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8('\\'), U8('/'),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8('\\'), U8('\\'), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
	U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '), U8(' '),
} /* yyjson.c:6269:17 */

//* Returns the escape table with options.
func Get_esc_table_with_flag(tls *libc.TLS, flg Yyjson_read_flag) uintptr { /* yyjson.c:6337:21: */
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_WRITE_ESCAPE_UNICODE != 0)), int64(0)) != 0 {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_WRITE_ESCAPE_SLASHES != 0)), int64(0)) != 0 {
			return uintptr(unsafe.Pointer(&esc_table_unicode_with_slashes))
		} else {
			return uintptr(unsafe.Pointer(&esc_table_unicode))
		}
	} else {
		if libc.X__builtin_expect(tls, libc.BoolInt64(!!(flg&sYYJSON_WRITE_ESCAPE_SLASHES != 0)), int64(0)) != 0 {
			return uintptr(unsafe.Pointer(&esc_table_default_with_slashes))
		} else {
			return uintptr(unsafe.Pointer(&esc_table_default))
		}
	}
	return uintptr(0)
}

//*
//  Write UTF-8 string (requires len * 6 + 2 bytes buffer).
//  If the input string is not valid UTF-8 encoding, undefined behavior may occur.
//  @param cur Buffer cursor.
//  @param str A valid UTF-8 string, null-terminator is not required.
//  @param str_len Length of string in bytes.
//  @param esc_table Escape type table for character escaping.
//  @return The buffer cursor after string.
//
func Write_string(tls *libc.TLS, cur uintptr, str uintptr, str_len Usize, esc_table uintptr) uintptr { /* yyjson.c:6363:4: */
	var end uintptr
	var u U16
	var u1 U16
	var hi U32
	var lo U32
	var u2 U32
	end = str + uintptr(str_len)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('"')

copy_char:
	//
	//      Copy continuous unescaped char, loop unrolling, same as the following code:
	//
	//          while (str < end) (
	//             if (unlikely(esc_table[*str] != CHAR_ESC_NONE)) break;
	//             *cur++ = *str++;
	//          );
	//

__1:
	if !((int64(end)-int64(str))/1 >= int64(16)) {
		goto __2
	}
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __3
	}
	goto stop_char_0
__3:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 1)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __4
	}
	goto stop_char_1
__4:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 2)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __5
	}
	goto stop_char_2
__5:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 3)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __6
	}
	goto stop_char_3
__6:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 4)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __7
	}
	goto stop_char_4
__7:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 5)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __8
	}
	goto stop_char_5
__8:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 6)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __9
	}
	goto stop_char_6
__9:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 7)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __10
	}
	goto stop_char_7
__10:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 8)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __11
	}
	goto stop_char_8
__11:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 9)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __12
	}
	goto stop_char_9
__12:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 10)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __13
	}
	goto stop_char_10
__13:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 11)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __14
	}
	goto stop_char_11
__14:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 12)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __15
	}
	goto stop_char_12
__15:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 13)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __16
	}
	goto stop_char_13
__16:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 14)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __17
	}
	goto stop_char_14
__17:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 15)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __18
	}
	goto stop_char_15
__18:
	;

	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(16), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(16)
	str += uintptr(16)
	goto __1
__2:
	;

__19:
	if !((int64(end)-int64(str))/1 >= int64(4)) {
		goto __20
	}
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __21
	}
	goto stop_char_0
__21:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 1)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __22
	}
	goto stop_char_1
__22:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 2)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __23
	}
	goto stop_char_2
__23:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str + 3)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __24
	}
	goto stop_char_3
__24:
	;

	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(4), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(4)
	str += uintptr(4)
	goto __19
__20:
	;

__25:
	if !(str < end) {
		goto __26
	}
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str)))))) != CHAR_ESC_NONE)), int64(0)) != 0) {
		goto __27
	}
	goto stop_char_0
__27:
	;

	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = *(*U8)(unsafe.Pointer(libc.PostIncUintptr(&str, 1)))
	goto __25
__26:
	;
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('"')
	return cur

stop_char_0:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(0), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(0)
	str += uintptr(0)
	goto copy_next
stop_char_1:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(1), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(1)
	str += uintptr(1)
	goto copy_next
stop_char_2:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(2), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(2)
	str += uintptr(2)
	goto copy_next
stop_char_3:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(3), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(3)
	str += uintptr(3)
	goto copy_next
stop_char_4:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(4), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(4)
	str += uintptr(4)
	goto copy_next
stop_char_5:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(5), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(5)
	str += uintptr(5)
	goto copy_next
stop_char_6:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(6), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(6)
	str += uintptr(6)
	goto copy_next
stop_char_7:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(7), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(7)
	str += uintptr(7)
	goto copy_next
stop_char_8:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(8), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(8)
	str += uintptr(8)
	goto copy_next
stop_char_9:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(9), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(9)
	str += uintptr(9)
	goto copy_next
stop_char_10:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(10), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(10)
	str += uintptr(10)
	goto copy_next
stop_char_11:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(11), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(11)
	str += uintptr(11)
	goto copy_next
stop_char_12:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(12), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(12)
	str += uintptr(12)
	goto copy_next
stop_char_13:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(13), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(13)
	str += uintptr(13)
	goto copy_next
stop_char_14:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(14), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(14)
	str += uintptr(14)
	goto copy_next
stop_char_15:
	libc.X__builtin___memcpy_chk(tls, cur, str, uint64(15), libc.X__builtin_object_size(tls, cur, 0))
	cur += uintptr(15)
	str += uintptr(15)
	goto copy_next

copy_next:
__28:
	if !(str < end) {
		goto __29
	}
	switch int32(*(*Char_esc_type)(unsafe.Pointer(esc_table + uintptr(*(*U8)(unsafe.Pointer(str)))))) {
	case CHAR_ESC_NONE:
		goto __31
	case CHAR_ESC_ASCII:
		goto __32
	case CHAR_ESC_UTF8_1:
		goto __33
	case CHAR_ESC_UTF8_2:
		goto __34
	case CHAR_ESC_UTF8_3:
		goto __35
	case CHAR_ESC_UTF8_4:
		goto __36
	default:
		goto __37
	}
	goto __30
__31:
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = *(*U8)(unsafe.Pointer(libc.PostIncUintptr(&str, 1)))
	goto copy_char

__32:
	*(*V16)(unsafe.Pointer(cur)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Esc_single_char_table))) + uintptr(*(*U8)(unsafe.Pointer(str)))*2))
	cur += uintptr(2)
	str += uintptr(1)
	goto __28

__33:
	*(*V32)(unsafe.Pointer(cur)) = V32_make(tls, int8('\\'), int8('u'), int8('0'), int8('0'))
	*(*V16)(unsafe.Pointer(cur + 2*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Esc_hex_char_table))) + uintptr(*(*U8)(unsafe.Pointer(str)))*2))
	cur += uintptr(6)
	str += uintptr(1)
	goto __28

__34:
	u = U16(int32(U16(int32(*(*U8)(unsafe.Pointer(str)))&0x1F))<<6 | int32(U16(int32(*(*U8)(unsafe.Pointer(str + 1)))&0x3F))<<0)
	*(*V16)(unsafe.Pointer(cur)) = V16_make(tls, int8('\\'), int8('u'))
	*(*V16)(unsafe.Pointer(cur + 1*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Esc_hex_char_table))) + uintptr(int32(u)>>8)*2))
	*(*V16)(unsafe.Pointer(cur + 2*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Esc_hex_char_table))) + uintptr(int32(u)&0xFF)*2))
	cur += uintptr(6)
	str += uintptr(2)
	goto __28

__35:
	u1 = U16(int32(U16(int32(*(*U8)(unsafe.Pointer(str)))&0x0F))<<12 | int32(U16(int32(*(*U8)(unsafe.Pointer(str + 1)))&0x3F))<<6 | int32(U16(int32(*(*U8)(unsafe.Pointer(str + 2)))&0x3F))<<0)
	*(*V16)(unsafe.Pointer(cur)) = V16_make(tls, int8('\\'), int8('u'))
	*(*V16)(unsafe.Pointer(cur + 1*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Esc_hex_char_table))) + uintptr(int32(u1)>>8)*2))
	*(*V16)(unsafe.Pointer(cur + 2*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Esc_hex_char_table))) + uintptr(int32(u1)&0xFF)*2))
	cur += uintptr(6)
	str += uintptr(3)
	goto __28

__36:
	u2 = U32(int32(*(*U8)(unsafe.Pointer(str)))&0x07)<<18 | U32(int32(*(*U8)(unsafe.Pointer(str + 1)))&0x3F)<<12 | U32(int32(*(*U8)(unsafe.Pointer(str + 2)))&0x3F)<<6 | U32(int32(*(*U8)(unsafe.Pointer(str + 3)))&0x3F)<<0
	u2 = u2 - U32(0x10000)
	hi = u2>>10 + U32(0xD800)
	lo = u2&U32(0x3FF) + U32(0xDC00)
	*(*V16)(unsafe.Pointer(cur)) = V16_make(tls, int8('\\'), int8('u'))
	*(*V16)(unsafe.Pointer(cur + 1*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Esc_hex_char_table))) + uintptr(hi>>8)*2))
	*(*V16)(unsafe.Pointer(cur + 2*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Esc_hex_char_table))) + uintptr(hi&U32(0xFF))*2))
	*(*V16)(unsafe.Pointer(cur + 3*2)) = V16_make(tls, int8('\\'), int8('u'))
	*(*V16)(unsafe.Pointer(cur + 4*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Esc_hex_char_table))) + uintptr(lo>>8)*2))
	*(*V16)(unsafe.Pointer(cur + 5*2)) = *(*V16)(unsafe.Pointer(uintptr(uintptr(unsafe.Pointer(&Esc_hex_char_table))) + uintptr(lo&U32(0xFF))*2))
	cur += uintptr(12)
	str += uintptr(4)
	goto __28

__37:
	goto __30
__30:
	;
	goto __28
__29:
	;
	goto copy_end

copy_end:
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('"')
	return cur
}

// ==============================================================================
// Writer Utilities
//============================================================================

//* Write null (requires 8 bytes buffer).
func Write_null(tls *libc.TLS, cur uintptr) uintptr { /* yyjson.c:6486:4: */
	*(*V64)(unsafe.Pointer(cur)) = V64_make(tls, int8('n'), int8('u'), int8('l'), int8('l'), int8(','), int8('\n'), int8(0), int8(0))
	return cur + uintptr(4)
}

//* Write bool (requires 8 bytes buffer).
func Write_bool(tls *libc.TLS, cur uintptr, val uint8) uintptr { /* yyjson.c:6492:4: */
	*(*V64)(unsafe.Pointer(cur)) = func() V641 {
		if val != 0 {
			return V64_make(tls, int8('t'), int8('r'), int8('u'), int8('e'), int8(','), int8('\n'), int8(0), int8(0))
		}
		return V64_make(tls, int8('f'), int8('a'), int8('l'), int8('s'), int8('e'), int8(','), int8('\n'), int8(0))
	}()
	return cur + uintptr(5) - uintptr(val)
}

//* Write indent (requires level * 4 bytes buffer).
func Write_indent(tls *libc.TLS, cur uintptr, level Usize) uintptr { /* yyjson.c:6499:4: */
	for libc.PostDecUint64(&level, 1) > uint64(0) {
		*(*V32)(unsafe.Pointer(cur)) = V32_make(tls, int8(' '), int8(' '), int8(' '), int8(' '))
		cur += uintptr(4)
	}
	return cur
}

//* Write data to file.
func write_dat_to_file(tls *libc.TLS, path uintptr, dat uintptr, len Usize, err uintptr) uint8 { /* yyjson.c:6508:13: */

	var file uintptr = Fopen_writeonly(tls, path)
	if file == uintptr(0) {
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 857 /* "file opening fai..." */
			(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_FILE_OPEN
			if file != 0 {
				libc.Xfclose(tls, file)
			}
			return uint8(False)
		}
	}
	if libc.Xfwrite(tls, dat, len, uint64(1), file) != uint64(1) {
		for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
			(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 918 /* "file writing fai..." */
			(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_FILE_WRITE
			if file != 0 {
				libc.Xfclose(tls, file)
			}
			return uint8(False)
		}
	}
	if libc.Xfclose(tls, file) != 0 {
		file = uintptr(0)
		for __ccgo2 := true; __ccgo2; __ccgo2 = 0 != 0 {
			(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 938 /* "file closing fai..." */
			(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_FILE_WRITE
			if file != 0 {
				libc.Xfclose(tls, file)
			}
			return uint8(False)
		}
	}
	return uint8(True)

}

// ==============================================================================
// JSON Writer Implementation
//============================================================================

type Yyjson_write_ctx1 = struct{ Tag Usize } /* yyjson.c:6540:9 */

// ==============================================================================
// JSON Writer Implementation
//============================================================================

type Yyjson_write_ctx = Yyjson_write_ctx1 /* yyjson.c:6542:3 */

func Yyjson_write_ctx_set(tls *libc.TLS, ctx uintptr, size Usize, is_obj uint8) { /* yyjson.c:6544:6: */
	(*Yyjson_write_ctx)(unsafe.Pointer(ctx)).Tag = size<<1 | Usize(is_obj)
}

func Yyjson_write_ctx_get(tls *libc.TLS, ctx uintptr, size uintptr, is_obj uintptr) { /* yyjson.c:6549:6: */
	var tag Usize = (*Yyjson_write_ctx)(unsafe.Pointer(ctx)).Tag
	*(*Usize)(unsafe.Pointer(size)) = tag >> 1
	*(*uint8)(unsafe.Pointer(is_obj)) = uint8(tag & uint64(1))
}

//* Write single JSON value.
func Yyjson_write_single(tls *libc.TLS, val uintptr, flg Yyjson_write_flag, alc Yyjson_alc, dat_len uintptr, err uintptr) uintptr { /* yyjson.c:6557:4: */
	var hdr uintptr
	var cur uintptr
	var str_len Usize
	var str_ptr uintptr
	var esc_table uintptr
	hdr = uintptr(0)
	esc_table = Get_esc_table_with_flag(tls, flg)

	switch int32(Unsafe_yyjson_get_type(tls, val)) {
	case int32(Uint8_t(5)):
		goto __2

	case int32(Uint8_t(4)):
		goto __3

	case int32(Uint8_t(3)):
		goto __4

	case int32(Uint8_t(2)):
		goto __5

	case int32(Uint8_t(6)):
		goto __6

	case int32(Uint8_t(7)):
		goto __7

	default:
		goto __8
	}
	goto __1
__2:
	str_len = Unsafe_yyjson_get_len(tls, val)
	str_ptr = Unsafe_yyjson_get_str(tls, val)
__9:
	if !(U64(libc.CplUint64(uint64(0))) < U64(0xFFFFFFFF)<<32+0xFFFFFFFF && str_len >= (libc.CplUint64(uint64(0))-uint64(16))/uint64(6)) {
		goto __12
	}
	goto fail_alloc
__12:
	;
	goto __10
__10:
	if 0 != 0 {
		goto __9
	}
	goto __11
__11:
	;
__13:
	hdr = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Malloc})).f(tls, alc.Ctx, str_len*uint64(6)+uint64(4))
	if !!(hdr != 0) {
		goto __16
	}
	goto fail_alloc
__16:
	;
	cur = hdr
	goto __14
__14:
	if 0 != 0 {
		goto __13
	}
	goto __15
__15:
	;
	cur = Write_string(tls, cur, str_ptr, str_len, esc_table)
	goto __1

__3:
__17:
	hdr = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Malloc})).f(tls, alc.Ctx, uint64(32))
	if !!(hdr != 0) {
		goto __20
	}
	goto fail_alloc
__20:
	;
	cur = hdr
	goto __18
__18:
	if 0 != 0 {
		goto __17
	}
	goto __19
__19:
	;
	cur = Write_number(tls, cur, val, flg)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(cur != 0)), int64(0)) != 0) {
		goto __21
	}
	goto fail_num
__21:
	;
	goto __1

__4:
__22:
	hdr = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Malloc})).f(tls, alc.Ctx, uint64(8))
	if !!(hdr != 0) {
		goto __25
	}
	goto fail_alloc
__25:
	;
	cur = hdr
	goto __23
__23:
	if 0 != 0 {
		goto __22
	}
	goto __24
__24:
	;
	cur = Write_bool(tls, cur, Unsafe_yyjson_get_bool(tls, val))
	goto __1

__5:
__26:
	hdr = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Malloc})).f(tls, alc.Ctx, uint64(8))
	if !!(hdr != 0) {
		goto __29
	}
	goto fail_alloc
__29:
	;
	cur = hdr
	goto __27
__27:
	if 0 != 0 {
		goto __26
	}
	goto __28
__28:
	;
	cur = Write_null(tls, cur)
	goto __1

__6:
__30:
	hdr = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Malloc})).f(tls, alc.Ctx, uint64(4))
	if !!(hdr != 0) {
		goto __33
	}
	goto fail_alloc
__33:
	;
	cur = hdr
	goto __31
__31:
	if 0 != 0 {
		goto __30
	}
	goto __32
__32:
	;
	*(*V16)(unsafe.Pointer(cur)) = V16_make(tls, int8('['), int8(']'))
	cur += uintptr(2)
	goto __1

__7:
__34:
	hdr = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Malloc})).f(tls, alc.Ctx, uint64(4))
	if !!(hdr != 0) {
		goto __37
	}
	goto fail_alloc
__37:
	;
	cur = hdr
	goto __35
__35:
	if 0 != 0 {
		goto __34
	}
	goto __36
__36:
	;
	*(*V16)(unsafe.Pointer(cur)) = V16_make(tls, int8('{'), int8('}'))
	cur += uintptr(2)
	goto __1

__8:
	goto fail_type
__1:
	;

	*(*U8)(unsafe.Pointer(cur)) = U8(0)
	*(*Usize)(unsafe.Pointer(dat_len)) = Usize((int64(cur) - int64(hdr)) / 1)
	libc.X__builtin___memset_chk(tls, err, 0, uint64(unsafe.Sizeof(Yyjson_write_err{})), libc.X__builtin_object_size(tls, err, 0))
	return hdr

fail_alloc:
__38:
	if !(hdr != 0) {
		goto __41
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
__41:
	;
	*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_MEMORY_ALLOCATION
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 514 /* "memory allocatio..." */
	return uintptr(0)
	goto __39
__39:
	if 0 != 0 {
		goto __38
	}
	goto __40
__40:
	;
fail_type:
__42:
	if !(hdr != 0) {
		goto __45
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
__45:
	;
	*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_INVALID_VALUE_TYPE
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 958 /* "invalid JSON val..." */
	return uintptr(0)
	goto __43
__43:
	if 0 != 0 {
		goto __42
	}
	goto __44
__44:
	;
fail_num:
__46:
	if !(hdr != 0) {
		goto __49
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
__49:
	;
	*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_NAN_OR_INF
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 982 /* "nan or inf numbe..." */
	return uintptr(0)
	goto __47
__47:
	if 0 != 0 {
		goto __46
	}
	goto __48
__48:
	;
	return uintptr(0)

}

//* Write JSON document minify.
//     The root of this document should be a non-empty container.
func Yyjson_write_minify(tls *libc.TLS, doc uintptr, flg Yyjson_write_flag, alc Yyjson_alc, dat_len uintptr, err uintptr) uintptr { /* yyjson.c:6647:4: */
	bp := tls.Alloc(9)
	defer tls.Free(9)

	var val uintptr
	var val_type Yyjson_type
	// var ctn_len Usize at bp, 8

	var ctn_len_tmp Usize
	// var ctn_obj uint8 at bp+8, 1

	var ctn_obj_tmp uint8
	var is_key uint8
	var hdr uintptr
	var cur uintptr
	var end uintptr
	var tmp uintptr
	var ctx uintptr
	var ctx_tmp uintptr
	var alc_len Usize
	var alc_inc Usize
	var ctx_len Usize
	var ext_len Usize
	var str_len Usize
	var str_ptr uintptr
	var esc_table uintptr
	esc_table = Get_esc_table_with_flag(tls, flg)

	alc_len = (*Yyjson_doc)(unsafe.Pointer(doc)).Val_read*uint64(YYJSON_WRITER_ESTIMATED_MINIFY_RATIO) + uint64(64)
	alc_len = Size_align_up(tls, alc_len, uint64(unsafe.Sizeof(Yyjson_write_ctx{})))
	hdr = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Malloc})).f(tls, alc.Ctx, alc_len)
	if !!(hdr != 0) {
		goto __1
	}
	goto fail_alloc
__1:
	;
	cur = hdr
	end = hdr + uintptr(alc_len)
	ctx = end
	goto doc_begin

doc_begin:
	val = (*Yyjson_doc)(unsafe.Pointer(doc)).Root
	val_type = Unsafe_yyjson_get_type(tls, val)
	*(*uint8)(unsafe.Pointer(bp + 8 /* ctn_obj */)) = uint8(libc.Bool32(int32(val_type) == int32(Uint8_t(7))))
	*(*Usize)(unsafe.Pointer(bp /* ctn_len */)) = Unsafe_yyjson_get_len(tls, val) << int32(U8(*(*uint8)(unsafe.Pointer(bp + 8))))
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('[' | int32(U8(*(*uint8)(unsafe.Pointer(bp + 8))))<<5)
	val += 16

val_begin:
	val_type = Unsafe_yyjson_get_type(tls, val)
	switch int32(val_type) {
	case int32(Uint8_t(5)):
		goto __3

	case int32(Uint8_t(4)):
		goto __4

	case int32(Uint8_t(3)):
		goto __5

	case int32(Uint8_t(2)):
		goto __6

	case int32(Uint8_t(6)):
		goto __7
	case int32(Uint8_t(7)):
		goto __8

	default:
		goto __9
	}
	goto __2
__3:
	is_key = uint8(int32(U8(*(*uint8)(unsafe.Pointer(bp + 8)))) & int32(U8(^*(*Usize)(unsafe.Pointer(bp)))))
	str_len = Unsafe_yyjson_get_len(tls, val)
	str_ptr = Unsafe_yyjson_get_str(tls, val)
__10:
	if !(U64(libc.CplUint64(uint64(0))) < U64(0xFFFFFFFF)<<32+0xFFFFFFFF && str_len >= (libc.CplUint64(uint64(0))-uint64(16))/uint64(6)) {
		goto __13
	}
	goto fail_alloc
__13:
	;
	goto __11
__11:
	if 0 != 0 {
		goto __10
	}
	goto __12
__12:
	;
__14:
	ext_len = str_len*uint64(6) + uint64(16)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __17
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __18
	}
	goto fail_alloc
__18:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __19
	}
	goto fail_alloc
__19:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__17:
	;
	goto __15
__15:
	if 0 != 0 {
		goto __14
	}
	goto __16
__16:
	;
	cur = Write_string(tls, cur, str_ptr, str_len, esc_table)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = func() uint8 {
		if is_key != 0 {
			return uint8(':')
		}
		return uint8(',')
	}()
	goto __2

__4:
__20:
	ext_len = uint64(32)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __23
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __24
	}
	goto fail_alloc
__24:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __25
	}
	goto fail_alloc
__25:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__23:
	;
	goto __21
__21:
	if 0 != 0 {
		goto __20
	}
	goto __22
__22:
	;
	cur = Write_number(tls, cur, val, flg)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(cur != 0)), int64(0)) != 0) {
		goto __26
	}
	goto fail_num
__26:
	;
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(',')
	goto __2

__5:
__27:
	ext_len = uint64(16)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __30
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __31
	}
	goto fail_alloc
__31:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __32
	}
	goto fail_alloc
__32:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__30:
	;
	goto __28
__28:
	if 0 != 0 {
		goto __27
	}
	goto __29
__29:
	;
	cur = Write_bool(tls, cur, Unsafe_yyjson_get_bool(tls, val))
	cur++
	goto __2

__6:
__33:
	ext_len = uint64(16)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __36
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __37
	}
	goto fail_alloc
__37:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __38
	}
	goto fail_alloc
__38:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__36:
	;
	goto __34
__34:
	if 0 != 0 {
		goto __33
	}
	goto __35
__35:
	;
	cur = Write_null(tls, cur)
	cur++
	goto __2

__7:
__8:
	ctn_len_tmp = Unsafe_yyjson_get_len(tls, val)
	ctn_obj_tmp = uint8(libc.Bool32(int32(val_type) == int32(Uint8_t(7))))
__39:
	ext_len = uint64(16)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __42
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __43
	}
	goto fail_alloc
__43:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __44
	}
	goto fail_alloc
__44:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__42:
	;
	goto __40
__40:
	if 0 != 0 {
		goto __39
	}
	goto __41
__41:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctn_len_tmp == uint64(0))), int64(0)) != 0) {
		goto __45
	}
	// write empty container
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('[' | int32(U8(ctn_obj_tmp))<<5)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(']' | int32(U8(ctn_obj_tmp))<<5)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(',')
	goto __2
	goto __46
__45:
	// push context, setup new container
	Yyjson_write_ctx_set(tls, libc.PreDecUintptr(&ctx, 8), *(*Usize)(unsafe.Pointer(bp /* ctn_len */)), *(*uint8)(unsafe.Pointer(bp + 8 /* ctn_obj */)))
	*(*Usize)(unsafe.Pointer(bp /* ctn_len */)) = ctn_len_tmp << int32(U8(ctn_obj_tmp))
	*(*uint8)(unsafe.Pointer(bp + 8 /* ctn_obj */)) = ctn_obj_tmp
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('[' | int32(U8(*(*uint8)(unsafe.Pointer(bp + 8))))<<5)
	val += 16
	goto val_begin
__46:
	;

__9:
	goto fail_type
__2:
	;

	val += 16
	*(*Usize)(unsafe.Pointer(bp /* ctn_len */))--
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*Usize)(unsafe.Pointer(bp)) == uint64(0))), int64(0)) != 0) {
		goto __47
	}
	goto ctn_end
__47:
	;
	goto val_begin

ctn_end:
	cur--
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(']' | int32(U8(*(*uint8)(unsafe.Pointer(bp + 8))))<<5)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(',')
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctx >= end)), int64(0)) != 0) {
		goto __48
	}
	goto doc_end
__48:
	;
	Yyjson_write_ctx_get(tls, libc.PostIncUintptr(&ctx, 8), bp, bp+8)
	*(*Usize)(unsafe.Pointer(bp /* ctn_len */))--
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*Usize)(unsafe.Pointer(bp)) > uint64(0))), int64(1)) != 0) {
		goto __49
	}
	goto val_begin
	goto __50
__49:
	goto ctn_end
__50:
	;

doc_end:
	*(*U8)(unsafe.Pointer(libc.PreDecUintptr(&cur, 1))) = U8(0)
	*(*Usize)(unsafe.Pointer(dat_len)) = Usize((int64(cur) - int64(hdr)) / 1)
	libc.X__builtin___memset_chk(tls, err, 0, uint64(unsafe.Sizeof(Yyjson_write_err{})), libc.X__builtin_object_size(tls, err, 0))
	return hdr

fail_alloc:
__51:
	*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_MEMORY_ALLOCATION
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 514 /* "memory allocatio..." */
	if !(hdr != 0) {
		goto __54
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
__54:
	;
	return uintptr(0)
	goto __52
__52:
	if 0 != 0 {
		goto __51
	}
	goto __53
__53:
	;
fail_type:
__55:
	*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_INVALID_VALUE_TYPE
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 958 /* "invalid JSON val..." */
	if !(hdr != 0) {
		goto __58
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
__58:
	;
	return uintptr(0)
	goto __56
__56:
	if 0 != 0 {
		goto __55
	}
	goto __57
__57:
	;
fail_num:
__59:
	*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_NAN_OR_INF
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 982 /* "nan or inf numbe..." */
	if !(hdr != 0) {
		goto __62
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
__62:
	;
	return uintptr(0)
	goto __60
__60:
	if 0 != 0 {
		goto __59
	}
	goto __61
__61:
	;
	return uintptr(0)

}

//* Write JSON document pretty.
//     The root of this document should be a non-empty container.
func Yyjson_write_pretty(tls *libc.TLS, doc uintptr, flg Yyjson_write_flag, alc Yyjson_alc, dat_len uintptr, err uintptr) uintptr { /* yyjson.c:6806:4: */
	bp := tls.Alloc(9)
	defer tls.Free(9)

	var val uintptr
	var val_type Yyjson_type
	// var ctn_len Usize at bp, 8

	var ctn_len_tmp Usize
	// var ctn_obj uint8 at bp+8, 1

	var ctn_obj_tmp uint8
	var is_key uint8
	var no_indent uint8
	var hdr uintptr
	var cur uintptr
	var end uintptr
	var tmp uintptr
	var ctx uintptr
	var ctx_tmp uintptr
	var alc_len Usize
	var alc_inc Usize
	var ctx_len Usize
	var ext_len Usize
	var str_len Usize
	var level Usize
	var str_ptr uintptr
	var esc_table uintptr
	esc_table = Get_esc_table_with_flag(tls, flg)

	alc_len = (*Yyjson_doc)(unsafe.Pointer(doc)).Val_read*uint64(YYJSON_WRITER_ESTIMATED_PRETTY_RATIO) + uint64(64)
	alc_len = Size_align_up(tls, alc_len, uint64(unsafe.Sizeof(Yyjson_write_ctx{})))
	hdr = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Malloc})).f(tls, alc.Ctx, alc_len)
	if !!(hdr != 0) {
		goto __1
	}
	goto fail_alloc
__1:
	;
	cur = hdr
	end = hdr + uintptr(alc_len)
	ctx = end
	goto doc_begin

doc_begin:
	val = (*Yyjson_doc)(unsafe.Pointer(doc)).Root
	val_type = Unsafe_yyjson_get_type(tls, val)
	*(*uint8)(unsafe.Pointer(bp + 8 /* ctn_obj */)) = uint8(libc.Bool32(int32(val_type) == int32(Uint8_t(7))))
	*(*Usize)(unsafe.Pointer(bp /* ctn_len */)) = Unsafe_yyjson_get_len(tls, val) << int32(U8(*(*uint8)(unsafe.Pointer(bp + 8))))
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('[' | int32(U8(*(*uint8)(unsafe.Pointer(bp + 8))))<<5)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('\n')
	val += 16
	level = uint64(1)

val_begin:
	val_type = Unsafe_yyjson_get_type(tls, val)
	switch int32(val_type) {
	case int32(Uint8_t(5)):
		goto __3

	case int32(Uint8_t(4)):
		goto __4

	case int32(Uint8_t(3)):
		goto __5

	case int32(Uint8_t(2)):
		goto __6

	case int32(Uint8_t(6)):
		goto __7
	case int32(Uint8_t(7)):
		goto __8

	default:
		goto __9
	}
	goto __2
__3:
	is_key = uint8(int32(U8(*(*uint8)(unsafe.Pointer(bp + 8)))) & int32(U8(^*(*Usize)(unsafe.Pointer(bp)))))
	no_indent = uint8(int32(U8(*(*uint8)(unsafe.Pointer(bp + 8)))) & int32(U8(*(*Usize)(unsafe.Pointer(bp)))))
	str_len = Unsafe_yyjson_get_len(tls, val)
	str_ptr = Unsafe_yyjson_get_str(tls, val)
__10:
	if !(U64(libc.CplUint64(uint64(0))) < U64(0xFFFFFFFF)<<32+0xFFFFFFFF && str_len >= (libc.CplUint64(uint64(0))-uint64(16))/uint64(6)) {
		goto __13
	}
	goto fail_alloc
__13:
	;
	goto __11
__11:
	if 0 != 0 {
		goto __10
	}
	goto __12
__12:
	;
__14:
	ext_len = str_len*uint64(6) + uint64(16) + func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level * uint64(4)
	}()
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __17
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __18
	}
	goto fail_alloc
__18:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __19
	}
	goto fail_alloc
__19:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__17:
	;
	goto __15
__15:
	if 0 != 0 {
		goto __14
	}
	goto __16
__16:
	;
	cur = Write_indent(tls, cur, func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level
	}())
	cur = Write_string(tls, cur, str_ptr, str_len, esc_table)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = func() uint8 {
		if is_key != 0 {
			return uint8(':')
		}
		return uint8(',')
	}()
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = func() uint8 {
		if is_key != 0 {
			return uint8(' ')
		}
		return uint8('\n')
	}()
	goto __2

__4:
	no_indent = uint8(int32(U8(*(*uint8)(unsafe.Pointer(bp + 8)))) & int32(U8(*(*Usize)(unsafe.Pointer(bp)))))
__20:
	ext_len = uint64(32) + func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level * uint64(4)
	}()
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __23
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __24
	}
	goto fail_alloc
__24:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __25
	}
	goto fail_alloc
__25:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__23:
	;
	goto __21
__21:
	if 0 != 0 {
		goto __20
	}
	goto __22
__22:
	;
	cur = Write_indent(tls, cur, func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level
	}())
	cur = Write_number(tls, cur, val, flg)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(cur != 0)), int64(0)) != 0) {
		goto __26
	}
	goto fail_num
__26:
	;
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(',')
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('\n')
	goto __2

__5:
	no_indent = uint8(int32(U8(*(*uint8)(unsafe.Pointer(bp + 8)))) & int32(U8(*(*Usize)(unsafe.Pointer(bp)))))
__27:
	ext_len = uint64(16) + func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level * uint64(4)
	}()
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __30
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __31
	}
	goto fail_alloc
__31:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __32
	}
	goto fail_alloc
__32:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__30:
	;
	goto __28
__28:
	if 0 != 0 {
		goto __27
	}
	goto __29
__29:
	;
	cur = Write_indent(tls, cur, func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level
	}())
	cur = Write_bool(tls, cur, Unsafe_yyjson_get_bool(tls, val))
	cur += uintptr(2)
	goto __2

__6:
	no_indent = uint8(int32(U8(*(*uint8)(unsafe.Pointer(bp + 8)))) & int32(U8(*(*Usize)(unsafe.Pointer(bp)))))
__33:
	ext_len = uint64(16) + func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level * uint64(4)
	}()
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __36
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __37
	}
	goto fail_alloc
__37:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __38
	}
	goto fail_alloc
__38:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__36:
	;
	goto __34
__34:
	if 0 != 0 {
		goto __33
	}
	goto __35
__35:
	;
	cur = Write_indent(tls, cur, func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level
	}())
	cur = Write_null(tls, cur)
	cur += uintptr(2)
	goto __2

__7:
__8:
	no_indent = uint8(int32(U8(*(*uint8)(unsafe.Pointer(bp + 8)))) & int32(U8(*(*Usize)(unsafe.Pointer(bp)))))
	ctn_len_tmp = Unsafe_yyjson_get_len(tls, val)
	ctn_obj_tmp = uint8(libc.Bool32(int32(val_type) == int32(Uint8_t(7))))
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctn_len_tmp == uint64(0))), int64(0)) != 0) {
		goto __39
	}
	// write empty container
__41:
	ext_len = uint64(16) + func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level * uint64(4)
	}()
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __44
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __45
	}
	goto fail_alloc
__45:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __46
	}
	goto fail_alloc
__46:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__44:
	;
	goto __42
__42:
	if 0 != 0 {
		goto __41
	}
	goto __43
__43:
	;
	cur = Write_indent(tls, cur, func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level
	}())
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('[' | int32(U8(ctn_obj_tmp))<<5)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(']' | int32(U8(ctn_obj_tmp))<<5)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(',')
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('\n')
	goto __2
	goto __40
__39:
	// push context, setup new container
__47:
	ext_len = uint64(32) + func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level * uint64(4)
	}()
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __50
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __51
	}
	goto fail_alloc
__51:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __52
	}
	goto fail_alloc
__52:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__50:
	;
	goto __48
__48:
	if 0 != 0 {
		goto __47
	}
	goto __49
__49:
	;
	Yyjson_write_ctx_set(tls, libc.PreDecUintptr(&ctx, 8), *(*Usize)(unsafe.Pointer(bp /* ctn_len */)), *(*uint8)(unsafe.Pointer(bp + 8 /* ctn_obj */)))
	*(*Usize)(unsafe.Pointer(bp /* ctn_len */)) = ctn_len_tmp << int32(U8(ctn_obj_tmp))
	*(*uint8)(unsafe.Pointer(bp + 8 /* ctn_obj */)) = ctn_obj_tmp
	cur = Write_indent(tls, cur, func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level
	}())
	level++
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('[' | int32(U8(*(*uint8)(unsafe.Pointer(bp + 8))))<<5)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('\n')
	val += 16
	goto val_begin
__40:
	;

__9:
	goto fail_type
__2:
	;

	val += 16
	*(*Usize)(unsafe.Pointer(bp /* ctn_len */))--
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*Usize)(unsafe.Pointer(bp)) == uint64(0))), int64(0)) != 0) {
		goto __53
	}
	goto ctn_end
__53:
	;
	goto val_begin

ctn_end:
	cur -= uintptr(2)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('\n')
__54:
	ext_len = level * uint64(4)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __57
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __58
	}
	goto fail_alloc
__58:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __59
	}
	goto fail_alloc
__59:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__57:
	;
	goto __55
__55:
	if 0 != 0 {
		goto __54
	}
	goto __56
__56:
	;
	cur = Write_indent(tls, cur, libc.PreDecUint64(&level, 1))
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(']' | int32(U8(*(*uint8)(unsafe.Pointer(bp + 8))))<<5)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctx >= end)), int64(0)) != 0) {
		goto __60
	}
	goto doc_end
__60:
	;
	Yyjson_write_ctx_get(tls, libc.PostIncUintptr(&ctx, 8), bp, bp+8)
	*(*Usize)(unsafe.Pointer(bp /* ctn_len */))--
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(',')
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('\n')
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*Usize)(unsafe.Pointer(bp)) > uint64(0))), int64(1)) != 0) {
		goto __61
	}
	goto val_begin
	goto __62
__61:
	goto ctn_end
__62:
	;

doc_end:
	*(*U8)(unsafe.Pointer(cur)) = U8(0)
	*(*Usize)(unsafe.Pointer(dat_len)) = Usize((int64(cur) - int64(hdr)) / 1)
	libc.X__builtin___memset_chk(tls, err, 0, uint64(unsafe.Sizeof(Yyjson_write_err{})), libc.X__builtin_object_size(tls, err, 0))
	return hdr

fail_alloc:
__63:
	*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_MEMORY_ALLOCATION
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 514 /* "memory allocatio..." */
	if !(hdr != 0) {
		goto __66
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
__66:
	;
	return uintptr(0)
	goto __64
__64:
	if 0 != 0 {
		goto __63
	}
	goto __65
__65:
	;
fail_type:
__67:
	*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_INVALID_VALUE_TYPE
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 958 /* "invalid JSON val..." */
	if !(hdr != 0) {
		goto __70
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
__70:
	;
	return uintptr(0)
	goto __68
__68:
	if 0 != 0 {
		goto __67
	}
	goto __69
__69:
	;
fail_num:
__71:
	*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_NAN_OR_INF
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 982 /* "nan or inf numbe..." */
	if !(hdr != 0) {
		goto __74
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
__74:
	;
	return uintptr(0)
	goto __72
__72:
	if 0 != 0 {
		goto __71
	}
	goto __73
__73:
	;
	return uintptr(0)

}

func Yyjson_write_opts(tls *libc.TLS, doc uintptr, flg Yyjson_write_flag, alc_ptr uintptr, dat_len uintptr, err uintptr) uintptr { /* yyjson.c:6986:6: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var dummy_err Yyjson_write_err at bp, 16

	// var dummy_dat_len Usize at bp+16, 8

	var alc Yyjson_alc

	if err != 0 {
		err = err
	} else {
		err = bp /* &dummy_err */
	}
	if dat_len != 0 {
		dat_len = dat_len
	} else {
		dat_len = bp + 16 /* &dummy_dat_len */
	}
	if alc_ptr != 0 {
		alc = *(*Yyjson_alc)(unsafe.Pointer(alc_ptr))
	} else {
		alc = sYYJSON_DEFAULT_ALC
	}

	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(doc != 0)), int64(0)) != 0 {
		*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
		(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 1015 /* "input JSON docum..." */
		(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_READ_ERROR_INVALID_PARAMETER
		return uintptr(0)
	}

	if (*Yyjson_doc)(unsafe.Pointer(doc)).Val_read == uint64(1) {
		return Yyjson_write_single(tls, (*Yyjson_doc)(unsafe.Pointer(doc)).Root, flg, alc, dat_len, err)
	}
	if flg&sYYJSON_WRITE_PRETTY != 0 {
		return Yyjson_write_pretty(tls, doc, flg, alc, dat_len, err)
	} else {
		return Yyjson_write_minify(tls, doc, flg, alc, dat_len, err)
	}
	return uintptr(0)
}

func Yyjson_write_file(tls *libc.TLS, path uintptr, doc uintptr, flg Yyjson_write_flag, alc_ptr uintptr, err uintptr) uint8 { /* yyjson.c:7017:6: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var dummy_err Yyjson_write_err at bp, 16

	var dat uintptr
	*(*Usize)(unsafe.Pointer(bp + 16 /* dat_len */)) = uint64(0)
	var suc uint8

	// validate input parameters
	if !(err != 0) {
		err = bp /* &dummy_err */
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(path != 0)), int64(0)) != 0 {
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 838 /* "input path is NU..." */
			(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_INVALID_PARAMETER
			return uint8(False)
		}
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*int8)(unsafe.Pointer(path))) == 0)), int64(0)) != 0 {
		for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
			(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 1043 /* "input path is em..." */
			(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_INVALID_PARAMETER
			return uint8(False)
		}
	}

	dat = Yyjson_write_opts(tls, doc, flg, alc_ptr, bp+16, err)
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(dat != 0)), int64(0)) != 0 {
		return uint8(False)
	}
	suc = write_dat_to_file(tls, path, dat, *(*Usize)(unsafe.Pointer(bp + 16 /* dat_len */)), err)
	if alc_ptr != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(alc_ptr)).Free})).f(tls, (*Yyjson_alc)(unsafe.Pointer(alc_ptr)).Ctx, dat)
	} else {
		libc.Xfree(tls, dat)
	}
	return suc

}

// ==============================================================================
// Mutable JSON Writer Implementation
//============================================================================

type Yyjson_mut_write_ctx1 = struct {
	Tag Usize
	Ctn uintptr
} /* yyjson.c:7059:9 */

// ==============================================================================
// Mutable JSON Writer Implementation
//============================================================================

type Yyjson_mut_write_ctx = Yyjson_mut_write_ctx1 /* yyjson.c:7062:3 */

func Yyjson_mut_write_ctx_set(tls *libc.TLS, ctx uintptr, ctn uintptr, size Usize, is_obj uint8) { /* yyjson.c:7064:6: */
	(*Yyjson_mut_write_ctx)(unsafe.Pointer(ctx)).Tag = size<<1 | Usize(is_obj)
	(*Yyjson_mut_write_ctx)(unsafe.Pointer(ctx)).Ctn = ctn
}

func Yyjson_mut_write_ctx_get(tls *libc.TLS, ctx uintptr, ctn uintptr, size uintptr, is_obj uintptr) { /* yyjson.c:7071:6: */
	var tag Usize = (*Yyjson_mut_write_ctx)(unsafe.Pointer(ctx)).Tag
	*(*Usize)(unsafe.Pointer(size)) = tag >> 1
	*(*uint8)(unsafe.Pointer(is_obj)) = uint8(tag & uint64(1))
	*(*uintptr)(unsafe.Pointer(ctn)) = (*Yyjson_mut_write_ctx)(unsafe.Pointer(ctx)).Ctn
}

//* Write single JSON value.
func Yyjson_mut_write_single(tls *libc.TLS, val uintptr, flg Yyjson_write_flag, alc Yyjson_alc, dat_len uintptr, err uintptr) uintptr { /* yyjson.c:7081:4: */
	return Yyjson_write_single(tls, val, flg, alc, dat_len, err)
}

//* Write JSON document minify.
//     The root of this document should be a non-empty container.
func Yyjson_mut_write_minify(tls *libc.TLS, doc uintptr, flg Yyjson_write_flag, alc Yyjson_alc, dat_len uintptr, err uintptr) uintptr { /* yyjson.c:7091:4: */
	bp := tls.Alloc(17)
	defer tls.Free(17)

	var val uintptr
	// var ctn uintptr at bp, 8

	var val_type Yyjson_type
	// var ctn_len Usize at bp+8, 8

	var ctn_len_tmp Usize
	// var ctn_obj uint8 at bp+16, 1

	var ctn_obj_tmp uint8
	var is_key uint8
	var hdr uintptr
	var cur uintptr
	var end uintptr
	var tmp uintptr
	var ctx uintptr
	var ctx_tmp uintptr
	var alc_len Usize
	var alc_inc Usize
	var ctx_len Usize
	var ext_len Usize
	var str_len Usize
	var str_ptr uintptr
	var esc_table uintptr
	esc_table = Get_esc_table_with_flag(tls, flg)

	alc_len = uint64(0*YYJSON_WRITER_ESTIMATED_MINIFY_RATIO + 64)
	alc_len = Size_align_up(tls, alc_len, uint64(unsafe.Sizeof(Yyjson_mut_write_ctx{})))
	hdr = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Malloc})).f(tls, alc.Ctx, alc_len)
	if !!(hdr != 0) {
		goto __1
	}
	goto fail_alloc
__1:
	;
	cur = hdr
	end = hdr + uintptr(alc_len)
	ctx = end
	goto doc_begin

doc_begin:
	val = (*Yyjson_mut_doc)(unsafe.Pointer(doc)).Root
	val_type = Unsafe_yyjson_get_type(tls, val)
	*(*uint8)(unsafe.Pointer(bp + 16 /* ctn_obj */)) = uint8(libc.Bool32(int32(val_type) == int32(Uint8_t(7))))
	*(*Usize)(unsafe.Pointer(bp + 8 /* ctn_len */)) = Unsafe_yyjson_get_len(tls, val) << int32(U8(*(*uint8)(unsafe.Pointer(bp + 16))))
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('[' | int32(U8(*(*uint8)(unsafe.Pointer(bp + 16))))<<5)
	*(*uintptr)(unsafe.Pointer(bp /* ctn */)) = val
	val = *(*uintptr)(unsafe.Pointer(val + 8)) // tail
	if *(*uint8)(unsafe.Pointer(bp + 16)) != 0 {
		val = (*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(val)).Next)).Next
	} else {
		val = (*Yyjson_mut_val)(unsafe.Pointer(val)).Next
	}

val_begin:
	val_type = Unsafe_yyjson_get_type(tls, val)
	switch int32(val_type) {
	case int32(Uint8_t(5)):
		goto __3

	case int32(Uint8_t(4)):
		goto __4

	case int32(Uint8_t(3)):
		goto __5

	case int32(Uint8_t(2)):
		goto __6

	case int32(Uint8_t(6)):
		goto __7
	case int32(Uint8_t(7)):
		goto __8

	default:
		goto __9
	}
	goto __2
__3:
	is_key = uint8(int32(U8(*(*uint8)(unsafe.Pointer(bp + 16)))) & int32(U8(^*(*Usize)(unsafe.Pointer(bp + 8)))))
	str_len = Unsafe_yyjson_get_len(tls, val)
	str_ptr = Unsafe_yyjson_get_str(tls, val)
__10:
	if !(U64(libc.CplUint64(uint64(0))) < U64(0xFFFFFFFF)<<32+0xFFFFFFFF && str_len >= (libc.CplUint64(uint64(0))-uint64(16))/uint64(6)) {
		goto __13
	}
	goto fail_alloc
__13:
	;
	goto __11
__11:
	if 0 != 0 {
		goto __10
	}
	goto __12
__12:
	;
__14:
	ext_len = str_len*uint64(6) + uint64(16)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __17
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_mut_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __18
	}
	goto fail_alloc
__18:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __19
	}
	goto fail_alloc
__19:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__17:
	;
	goto __15
__15:
	if 0 != 0 {
		goto __14
	}
	goto __16
__16:
	;
	cur = Write_string(tls, cur, str_ptr, str_len, esc_table)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = func() uint8 {
		if is_key != 0 {
			return uint8(':')
		}
		return uint8(',')
	}()
	goto __2

__4:
__20:
	ext_len = uint64(32)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __23
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_mut_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __24
	}
	goto fail_alloc
__24:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __25
	}
	goto fail_alloc
__25:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__23:
	;
	goto __21
__21:
	if 0 != 0 {
		goto __20
	}
	goto __22
__22:
	;
	cur = Write_number(tls, cur, val, flg)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(cur != 0)), int64(0)) != 0) {
		goto __26
	}
	goto fail_num
__26:
	;
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(',')
	goto __2

__5:
__27:
	ext_len = uint64(16)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __30
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_mut_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __31
	}
	goto fail_alloc
__31:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __32
	}
	goto fail_alloc
__32:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__30:
	;
	goto __28
__28:
	if 0 != 0 {
		goto __27
	}
	goto __29
__29:
	;
	cur = Write_bool(tls, cur, Unsafe_yyjson_get_bool(tls, val))
	cur++
	goto __2

__6:
__33:
	ext_len = uint64(16)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __36
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_mut_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __37
	}
	goto fail_alloc
__37:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __38
	}
	goto fail_alloc
__38:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__36:
	;
	goto __34
__34:
	if 0 != 0 {
		goto __33
	}
	goto __35
__35:
	;
	cur = Write_null(tls, cur)
	cur++
	goto __2

__7:
__8:
	ctn_len_tmp = Unsafe_yyjson_get_len(tls, val)
	ctn_obj_tmp = uint8(libc.Bool32(int32(val_type) == int32(Uint8_t(7))))
__39:
	ext_len = uint64(16)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __42
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_mut_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __43
	}
	goto fail_alloc
__43:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __44
	}
	goto fail_alloc
__44:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__42:
	;
	goto __40
__40:
	if 0 != 0 {
		goto __39
	}
	goto __41
__41:
	;
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctn_len_tmp == uint64(0))), int64(0)) != 0) {
		goto __45
	}
	// write empty container
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('[' | int32(U8(ctn_obj_tmp))<<5)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(']' | int32(U8(ctn_obj_tmp))<<5)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(',')
	goto __2
	goto __46
__45:
	// push context, setup new container
	Yyjson_mut_write_ctx_set(tls, libc.PreDecUintptr(&ctx, 16), *(*uintptr)(unsafe.Pointer(bp /* ctn */)), *(*Usize)(unsafe.Pointer(bp + 8 /* ctn_len */)), *(*uint8)(unsafe.Pointer(bp + 16 /* ctn_obj */)))
	*(*Usize)(unsafe.Pointer(bp + 8 /* ctn_len */)) = ctn_len_tmp << int32(U8(ctn_obj_tmp))
	*(*uint8)(unsafe.Pointer(bp + 16 /* ctn_obj */)) = ctn_obj_tmp
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('[' | int32(U8(*(*uint8)(unsafe.Pointer(bp + 16))))<<5)
	*(*uintptr)(unsafe.Pointer(bp /* ctn */)) = val
	val = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 8)) // tail
	if *(*uint8)(unsafe.Pointer(bp + 16)) != 0 {
		val = (*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(val)).Next)).Next
	} else {
		val = (*Yyjson_mut_val)(unsafe.Pointer(val)).Next
	}
	goto val_begin
__46:
	;

__9:
	goto fail_type
__2:
	;

	*(*Usize)(unsafe.Pointer(bp + 8 /* ctn_len */))--
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*Usize)(unsafe.Pointer(bp + 8)) == uint64(0))), int64(0)) != 0) {
		goto __47
	}
	goto ctn_end
__47:
	;
	val = (*Yyjson_mut_val)(unsafe.Pointer(val)).Next
	goto val_begin

ctn_end:
	cur--
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(']' | int32(U8(*(*uint8)(unsafe.Pointer(bp + 16))))<<5)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(',')
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctx >= end)), int64(0)) != 0) {
		goto __48
	}
	goto doc_end
__48:
	;
	val = (*Yyjson_mut_val)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* ctn */)))).Next
	Yyjson_mut_write_ctx_get(tls, libc.PostIncUintptr(&ctx, 16), bp, bp+8, bp+16)
	*(*Usize)(unsafe.Pointer(bp + 8 /* ctn_len */))--
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*Usize)(unsafe.Pointer(bp + 8)) > uint64(0))), int64(1)) != 0) {
		goto __49
	}
	goto val_begin
	goto __50
__49:
	goto ctn_end
__50:
	;

doc_end:
	*(*U8)(unsafe.Pointer(libc.PreDecUintptr(&cur, 1))) = U8(0)
	*(*Usize)(unsafe.Pointer(dat_len)) = Usize((int64(cur) - int64(hdr)) / 1)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_SUCCESS
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 1063 /* "success" */
	return hdr

fail_alloc:
__51:
	*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_MEMORY_ALLOCATION
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 514 /* "memory allocatio..." */
	if !(hdr != 0) {
		goto __54
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
__54:
	;
	return uintptr(0)
	goto __52
__52:
	if 0 != 0 {
		goto __51
	}
	goto __53
__53:
	;
fail_type:
__55:
	*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_INVALID_VALUE_TYPE
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 958 /* "invalid JSON val..." */
	if !(hdr != 0) {
		goto __58
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
__58:
	;
	return uintptr(0)
	goto __56
__56:
	if 0 != 0 {
		goto __55
	}
	goto __57
__57:
	;
fail_num:
__59:
	*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_NAN_OR_INF
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 982 /* "nan or inf numbe..." */
	if !(hdr != 0) {
		goto __62
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
__62:
	;
	return uintptr(0)
	goto __60
__60:
	if 0 != 0 {
		goto __59
	}
	goto __61
__61:
	;
	return uintptr(0)

}

//* Write JSON document pretty.
//     The root of this document should be a non-empty container.
func Yyjson_mut_write_pretty(tls *libc.TLS, doc uintptr, flg Yyjson_write_flag, alc Yyjson_alc, dat_len uintptr, err uintptr) uintptr { /* yyjson.c:7256:4: */
	bp := tls.Alloc(17)
	defer tls.Free(17)

	var val uintptr
	// var ctn uintptr at bp, 8

	var val_type Yyjson_type
	// var ctn_len Usize at bp+8, 8

	var ctn_len_tmp Usize
	// var ctn_obj uint8 at bp+16, 1

	var ctn_obj_tmp uint8
	var is_key uint8
	var no_indent uint8
	var hdr uintptr
	var cur uintptr
	var end uintptr
	var tmp uintptr
	var ctx uintptr
	var ctx_tmp uintptr
	var alc_len Usize
	var alc_inc Usize
	var ctx_len Usize
	var ext_len Usize
	var str_len Usize
	var level Usize
	var str_ptr uintptr
	var esc_table uintptr
	esc_table = Get_esc_table_with_flag(tls, flg)

	alc_len = uint64(0*YYJSON_WRITER_ESTIMATED_PRETTY_RATIO + 64)
	alc_len = Size_align_up(tls, alc_len, uint64(unsafe.Sizeof(Yyjson_mut_write_ctx{})))
	hdr = (*struct {
		f func(*libc.TLS, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Malloc})).f(tls, alc.Ctx, alc_len)
	if !!(hdr != 0) {
		goto __1
	}
	goto fail_alloc
__1:
	;
	cur = hdr
	end = hdr + uintptr(alc_len)
	ctx = end
	goto doc_begin

doc_begin:
	val = (*Yyjson_mut_doc)(unsafe.Pointer(doc)).Root
	val_type = Unsafe_yyjson_get_type(tls, val)
	*(*uint8)(unsafe.Pointer(bp + 16 /* ctn_obj */)) = uint8(libc.Bool32(int32(val_type) == int32(Uint8_t(7))))
	*(*Usize)(unsafe.Pointer(bp + 8 /* ctn_len */)) = Unsafe_yyjson_get_len(tls, val) << int32(U8(*(*uint8)(unsafe.Pointer(bp + 16))))
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('[' | int32(U8(*(*uint8)(unsafe.Pointer(bp + 16))))<<5)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('\n')
	*(*uintptr)(unsafe.Pointer(bp /* ctn */)) = val
	val = *(*uintptr)(unsafe.Pointer(val + 8)) // tail
	if *(*uint8)(unsafe.Pointer(bp + 16)) != 0 {
		val = (*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(val)).Next)).Next
	} else {
		val = (*Yyjson_mut_val)(unsafe.Pointer(val)).Next
	}
	level = uint64(1)

val_begin:
	val_type = Unsafe_yyjson_get_type(tls, val)
	switch int32(val_type) {
	case int32(Uint8_t(5)):
		goto __3

	case int32(Uint8_t(4)):
		goto __4

	case int32(Uint8_t(3)):
		goto __5

	case int32(Uint8_t(2)):
		goto __6

	case int32(Uint8_t(6)):
		goto __7
	case int32(Uint8_t(7)):
		goto __8

	default:
		goto __9
	}
	goto __2
__3:
	is_key = uint8(int32(U8(*(*uint8)(unsafe.Pointer(bp + 16)))) & int32(U8(^*(*Usize)(unsafe.Pointer(bp + 8)))))
	no_indent = uint8(int32(U8(*(*uint8)(unsafe.Pointer(bp + 16)))) & int32(U8(*(*Usize)(unsafe.Pointer(bp + 8)))))
	str_len = Unsafe_yyjson_get_len(tls, val)
	str_ptr = Unsafe_yyjson_get_str(tls, val)
__10:
	if !(U64(libc.CplUint64(uint64(0))) < U64(0xFFFFFFFF)<<32+0xFFFFFFFF && str_len >= (libc.CplUint64(uint64(0))-uint64(16))/uint64(6)) {
		goto __13
	}
	goto fail_alloc
__13:
	;
	goto __11
__11:
	if 0 != 0 {
		goto __10
	}
	goto __12
__12:
	;
__14:
	ext_len = str_len*uint64(6) + uint64(16) + func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level * uint64(4)
	}()
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __17
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_mut_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __18
	}
	goto fail_alloc
__18:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __19
	}
	goto fail_alloc
__19:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__17:
	;
	goto __15
__15:
	if 0 != 0 {
		goto __14
	}
	goto __16
__16:
	;
	cur = Write_indent(tls, cur, func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level
	}())
	cur = Write_string(tls, cur, str_ptr, str_len, esc_table)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = func() uint8 {
		if is_key != 0 {
			return uint8(':')
		}
		return uint8(',')
	}()
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = func() uint8 {
		if is_key != 0 {
			return uint8(' ')
		}
		return uint8('\n')
	}()
	goto __2

__4:
	no_indent = uint8(int32(U8(*(*uint8)(unsafe.Pointer(bp + 16)))) & int32(U8(*(*Usize)(unsafe.Pointer(bp + 8)))))
__20:
	ext_len = uint64(32) + func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level * uint64(4)
	}()
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __23
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_mut_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __24
	}
	goto fail_alloc
__24:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __25
	}
	goto fail_alloc
__25:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__23:
	;
	goto __21
__21:
	if 0 != 0 {
		goto __20
	}
	goto __22
__22:
	;
	cur = Write_indent(tls, cur, func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level
	}())
	cur = Write_number(tls, cur, val, flg)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(cur != 0)), int64(0)) != 0) {
		goto __26
	}
	goto fail_num
__26:
	;
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(',')
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('\n')
	goto __2

__5:
	no_indent = uint8(int32(U8(*(*uint8)(unsafe.Pointer(bp + 16)))) & int32(U8(*(*Usize)(unsafe.Pointer(bp + 8)))))
__27:
	ext_len = uint64(16) + func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level * uint64(4)
	}()
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __30
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_mut_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __31
	}
	goto fail_alloc
__31:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __32
	}
	goto fail_alloc
__32:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__30:
	;
	goto __28
__28:
	if 0 != 0 {
		goto __27
	}
	goto __29
__29:
	;
	cur = Write_indent(tls, cur, func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level
	}())
	cur = Write_bool(tls, cur, Unsafe_yyjson_get_bool(tls, val))
	cur += uintptr(2)
	goto __2

__6:
	no_indent = uint8(int32(U8(*(*uint8)(unsafe.Pointer(bp + 16)))) & int32(U8(*(*Usize)(unsafe.Pointer(bp + 8)))))
__33:
	ext_len = uint64(16) + func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level * uint64(4)
	}()
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __36
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_mut_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __37
	}
	goto fail_alloc
__37:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __38
	}
	goto fail_alloc
__38:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__36:
	;
	goto __34
__34:
	if 0 != 0 {
		goto __33
	}
	goto __35
__35:
	;
	cur = Write_indent(tls, cur, func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level
	}())
	cur = Write_null(tls, cur)
	cur += uintptr(2)
	goto __2

__7:
__8:
	no_indent = uint8(int32(U8(*(*uint8)(unsafe.Pointer(bp + 16)))) & int32(U8(*(*Usize)(unsafe.Pointer(bp + 8)))))
	ctn_len_tmp = Unsafe_yyjson_get_len(tls, val)
	ctn_obj_tmp = uint8(libc.Bool32(int32(val_type) == int32(Uint8_t(7))))
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctn_len_tmp == uint64(0))), int64(0)) != 0) {
		goto __39
	}
	// write empty container
__41:
	ext_len = uint64(16) + func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level * uint64(4)
	}()
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __44
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_mut_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __45
	}
	goto fail_alloc
__45:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __46
	}
	goto fail_alloc
__46:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__44:
	;
	goto __42
__42:
	if 0 != 0 {
		goto __41
	}
	goto __43
__43:
	;
	cur = Write_indent(tls, cur, func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level
	}())
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('[' | int32(U8(ctn_obj_tmp))<<5)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(']' | int32(U8(ctn_obj_tmp))<<5)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(',')
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('\n')
	goto __2
	goto __40
__39:
	// push context, setup new container
__47:
	ext_len = uint64(32) + func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level * uint64(4)
	}()
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __50
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_mut_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __51
	}
	goto fail_alloc
__51:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __52
	}
	goto fail_alloc
__52:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__50:
	;
	goto __48
__48:
	if 0 != 0 {
		goto __47
	}
	goto __49
__49:
	;
	Yyjson_mut_write_ctx_set(tls, libc.PreDecUintptr(&ctx, 16), *(*uintptr)(unsafe.Pointer(bp /* ctn */)), *(*Usize)(unsafe.Pointer(bp + 8 /* ctn_len */)), *(*uint8)(unsafe.Pointer(bp + 16 /* ctn_obj */)))
	*(*Usize)(unsafe.Pointer(bp + 8 /* ctn_len */)) = ctn_len_tmp << int32(U8(ctn_obj_tmp))
	*(*uint8)(unsafe.Pointer(bp + 16 /* ctn_obj */)) = ctn_obj_tmp
	cur = Write_indent(tls, cur, func() uint64 {
		if no_indent != 0 {
			return uint64(0)
		}
		return level
	}())
	level++
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('[' | int32(U8(*(*uint8)(unsafe.Pointer(bp + 16))))<<5)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('\n')
	*(*uintptr)(unsafe.Pointer(bp /* ctn */)) = val
	val = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)) + 8)) // tail
	if *(*uint8)(unsafe.Pointer(bp + 16)) != 0 {
		val = (*Yyjson_mut_val)(unsafe.Pointer((*Yyjson_mut_val)(unsafe.Pointer(val)).Next)).Next
	} else {
		val = (*Yyjson_mut_val)(unsafe.Pointer(val)).Next
	}
	goto val_begin
__40:
	;

__9:
	goto fail_type
__2:
	;

	*(*Usize)(unsafe.Pointer(bp + 8 /* ctn_len */))--
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*Usize)(unsafe.Pointer(bp + 8)) == uint64(0))), int64(0)) != 0) {
		goto __53
	}
	goto ctn_end
__53:
	;
	val = (*Yyjson_mut_val)(unsafe.Pointer(val)).Next
	goto val_begin

ctn_end:
	cur -= uintptr(2)
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('\n')
__54:
	ext_len = level * uint64(4)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(cur+uintptr(ext_len) >= ctx)), int64(0)) != 0) {
		goto __57
	}
	alc_inc = func() uint64 {
		if alc_len/uint64(2) > ext_len {
			return alc_len / uint64(2)
		}
		return ext_len
	}()
	alc_inc = Size_align_up(tls, alc_inc, uint64(unsafe.Sizeof(Yyjson_mut_write_ctx{})))
	if !(Size_add_is_overflow(tls, alc_len, alc_inc) != 0) {
		goto __58
	}
	goto fail_alloc
__58:
	;
	alc_len = alc_len + alc_inc
	tmp = (*struct {
		f func(*libc.TLS, uintptr, uintptr, Size_t) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{alc.Realloc})).f(tls, alc.Ctx, hdr, alc_len)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!!(tmp != 0)), int64(0)) != 0) {
		goto __59
	}
	goto fail_alloc
__59:
	;
	ctx_len = Usize((int64(end) - int64(ctx)) / 1)
	ctx_tmp = tmp + uintptr(alc_len-ctx_len)
	libc.X__builtin___memmove_chk(tls, ctx_tmp, tmp+uintptr((int64(ctx)-int64(hdr))/1), ctx_len, libc.X__builtin_object_size(tls, ctx_tmp, 0))
	ctx = ctx_tmp
	cur = tmp + uintptr((int64(cur)-int64(hdr))/1)
	end = tmp + uintptr(alc_len)
	hdr = tmp
__57:
	;
	goto __55
__55:
	if 0 != 0 {
		goto __54
	}
	goto __56
__56:
	;
	cur = Write_indent(tls, cur, libc.PreDecUint64(&level, 1))
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(']' | int32(U8(*(*uint8)(unsafe.Pointer(bp + 16))))<<5)
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(ctx >= end)), int64(0)) != 0) {
		goto __60
	}
	goto doc_end
__60:
	;
	val = (*Yyjson_mut_val)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* ctn */)))).Next
	Yyjson_mut_write_ctx_get(tls, libc.PostIncUintptr(&ctx, 16), bp, bp+8, bp+16)
	*(*Usize)(unsafe.Pointer(bp + 8 /* ctn_len */))--
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8(',')
	*(*U8)(unsafe.Pointer(libc.PostIncUintptr(&cur, 1))) = U8('\n')
	if !(libc.X__builtin_expect(tls, libc.BoolInt64(!!(*(*Usize)(unsafe.Pointer(bp + 8)) > uint64(0))), int64(1)) != 0) {
		goto __61
	}
	goto val_begin
	goto __62
__61:
	goto ctn_end
__62:
	;

doc_end:
	*(*U8)(unsafe.Pointer(cur)) = U8(0)
	*(*Usize)(unsafe.Pointer(dat_len)) = Usize((int64(cur) - int64(hdr)) / 1)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_SUCCESS
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 1063 /* "success" */
	return hdr

fail_alloc:
__63:
	*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_MEMORY_ALLOCATION
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 514 /* "memory allocatio..." */
	if !(hdr != 0) {
		goto __66
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
__66:
	;
	return uintptr(0)
	goto __64
__64:
	if 0 != 0 {
		goto __63
	}
	goto __65
__65:
	;
fail_type:
__67:
	*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_INVALID_VALUE_TYPE
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 958 /* "invalid JSON val..." */
	if !(hdr != 0) {
		goto __70
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
__70:
	;
	return uintptr(0)
	goto __68
__68:
	if 0 != 0 {
		goto __67
	}
	goto __69
__69:
	;
fail_num:
__71:
	*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
	(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_NAN_OR_INF
	(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 982 /* "nan or inf numbe..." */
	if !(hdr != 0) {
		goto __74
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{alc.Free})).f(tls, alc.Ctx, hdr)
__74:
	;
	return uintptr(0)
	goto __72
__72:
	if 0 != 0 {
		goto __71
	}
	goto __73
__73:
	;
	return uintptr(0)

}

func Yyjson_mut_write_opts(tls *libc.TLS, doc uintptr, flg Yyjson_write_flag, alc_ptr uintptr, dat_len uintptr, err uintptr) uintptr { /* yyjson.c:7442:6: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var dummy_err Yyjson_write_err at bp, 16

	// var dummy_dat_len Usize at bp+16, 8

	var alc Yyjson_alc
	var root uintptr

	if err != 0 {
		err = err
	} else {
		err = bp /* &dummy_err */
	}
	if dat_len != 0 {
		dat_len = dat_len
	} else {
		dat_len = bp + 16 /* &dummy_dat_len */
	}
	if alc_ptr != 0 {
		alc = *(*Yyjson_alc)(unsafe.Pointer(alc_ptr))
	} else {
		alc = sYYJSON_DEFAULT_ALC
	}

	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(doc != 0)), int64(0)) != 0 {
		*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 1015 /* "input JSON docum..." */
			(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_INVALID_PARAMETER
			return uintptr(0)
		}
	}
	root = (*Yyjson_mut_doc)(unsafe.Pointer(doc)).Root
	if !(root != 0) {
		*(*Usize)(unsafe.Pointer(dat_len)) = uint64(0)
		for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
			(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 1071 /* "input JSON docum..." */
			(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_INVALID_PARAMETER
			return uintptr(0)
		}
	}

	if !(Unsafe_yyjson_is_ctn(tls, root) != 0) || Unsafe_yyjson_get_len(tls, root) == uint64(0) {
		return Yyjson_mut_write_single(tls, root, flg, alc, dat_len, err)
	}
	if flg&sYYJSON_WRITE_PRETTY != 0 {
		return Yyjson_mut_write_pretty(tls, doc, flg, alc, dat_len, err)
	} else {
		return Yyjson_mut_write_minify(tls, doc, flg, alc, dat_len, err)
	}
	return uintptr(0)
}

func Yyjson_mut_write_file(tls *libc.TLS, path uintptr, doc uintptr, flg Yyjson_write_flag, alc_ptr uintptr, err uintptr) uint8 { /* yyjson.c:7483:6: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var dummy_err Yyjson_write_err at bp, 16

	var dat uintptr
	*(*Usize)(unsafe.Pointer(bp + 16 /* dat_len */)) = uint64(0)
	var suc uint8

	// validate input parameters
	if !(err != 0) {
		err = bp /* &dummy_err */
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(path != 0)), int64(0)) != 0 {
		for __ccgo := true; __ccgo; __ccgo = 0 != 0 {
			(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 838 /* "input path is NU..." */
			(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_INVALID_PARAMETER
			return uint8(False)
		}
	}
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!(int32(*(*int8)(unsafe.Pointer(path))) == 0)), int64(0)) != 0 {
		for __ccgo1 := true; __ccgo1; __ccgo1 = 0 != 0 {
			(*Yyjson_write_err)(unsafe.Pointer(err)).Msg = ts + 1043 /* "input path is em..." */
			(*Yyjson_write_err)(unsafe.Pointer(err)).Code = sYYJSON_WRITE_ERROR_INVALID_PARAMETER
			return uint8(False)
		}
	}

	dat = Yyjson_mut_write_opts(tls, doc, flg, alc_ptr, bp+16, err)
	if libc.X__builtin_expect(tls, libc.BoolInt64(!!!(dat != 0)), int64(0)) != 0 {
		return uint8(False)
	}
	suc = write_dat_to_file(tls, path, dat, *(*Usize)(unsafe.Pointer(bp + 16 /* dat_len */)), err)
	if alc_ptr != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr)
		})(unsafe.Pointer(&struct{ uintptr }{(*Yyjson_alc)(unsafe.Pointer(alc_ptr)).Free})).f(tls, (*Yyjson_alc)(unsafe.Pointer(alc_ptr)).Ctx, dat)
	} else {
		libc.Xfree(tls, dat)
	}
	return suc

}

// ==============================================================================
// Compiler Hint End
//============================================================================

// ==============================================================================
// Compiler Hint End
//============================================================================

func init() {
	*(*func(*libc.TLS, uintptr, Usize) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&sYYJSON_DEFAULT_ALC)) + 0)) = default_malloc           // yyjson.c:979:5:
	*(*func(*libc.TLS, uintptr, uintptr, Usize) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&sYYJSON_DEFAULT_ALC)) + 8)) = default_realloc // yyjson.c:980:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&sYYJSON_DEFAULT_ALC)) + 16)) = default_free                  // yyjson.c:981:5:
}

var ts1 = "null\x00string\x00array\x00object\x00true\x00false\x00uint\x00sint\x00real\x00unknown\x00rb\x00wb\x00alse\x00/*\x00*/\x00\x00\x00//\x00no digit after minus sign\x00no digit after decimal point\x00number with leading zero is not allowed\x00no digit after exponent sign\x00number is infinity when parsed as double\x00invalid UTF-8 encoding in string\x00invalid escaped unicode in string\x00invalid high surrogate in string\x00\\u\x00no matched low surrogate in string\x00invalid low surrogate in string\x00invalid escaped character in string\x00unexpected control character in string\x00unexpected end of data\x00memory allocation failed\x00invalid literal\x00unclosed multiline comment\x00unexpected character\x00unexpected content after document\x00trailing comma is not allowed\x00  \x00,\n\x00: \x00input data is NULL\x00input length is 0\x00input data is empty\x00byte order mark (BOM) is not supported\x00UTF-32 encoding is not supported\x00UTF-16 encoding is not supported\x00input path is NULL\x00file opening failed\x00fail to alloc memory\x00file reading failed\x00file writing failed\x00file closing failed\x00invalid JSON value type\x00nan or inf number is not allowed\x00input JSON document is NULL\x00input path is empty\x00success\x00input JSON document has no root value\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
